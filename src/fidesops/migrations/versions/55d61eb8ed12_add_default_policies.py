"""add default policies

Revision ID: 55d61eb8ed12
Revises: b3b68c87c4a0
Create Date: 2022-06-13 19:26:24.197262

"""
import logging

from alembic import op
from sqlalchemy.orm import Session, sessionmaker

from fidesops.api.v1.scope_registry import SCOPE_REGISTRY
from fidesops.core.config import config
from fidesops.db.base import ClientDetail, Policy, Rule, RuleTarget, StorageConfig
from fidesops.models.policy import ActionType, DrpAction
from fidesops.schemas.storage.storage import StorageType
from fidesops.util.data_category import DataCategory

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

revision = "55d61eb8ed12"
down_revision = "b3b68c87c4a0"
branch_labels = None
depends_on = None

FIDESOPS_AUTOGENERATED_CLIENT_KEY = "fidesops_autogenerated_client"
FIDESOPS_AUTOGENERATED_STORAGE_KEY = "fidesops_autogenerated_storage_destination"
AUTOGENERATED_ACCCES_KEY = "download"
AUTOGENERATED_ERASURE_KEY = "delete"


def upgrade():
    """Data migration only.

    Create an autogenerated client and storage destination, then use those to create
    autogenerated 'download' and 'delete' policies if they don't already exist."""
    if config.is_test_mode:
        logger.info(f"Skipping data migration in test mode'")
        return
    connection = op.get_bind()
    session_maker = sessionmaker(bind=connection.engine)
    db = session_maker(bind=connection)

    logger.info(
        f"Creating autogenerated local storage: '{FIDESOPS_AUTOGENERATED_STORAGE_KEY}'"
    )
    default_local_storage = StorageConfig.create(
        db=db,
        data={
            "name": "Fidesops Autogenerated Local Storage",
            "type": StorageType.local,
            "key": FIDESOPS_AUTOGENERATED_STORAGE_KEY,
            "details": {"naming": "request_id"},
        },
    )

    logger.info(f"Creating autogenerated client: '{FIDESOPS_AUTOGENERATED_CLIENT_KEY}'")
    client, _ = ClientDetail.create_client_and_secret(
        db, SCOPE_REGISTRY, fides_key=FIDESOPS_AUTOGENERATED_CLIENT_KEY
    )

    if not Policy.filter(
        db=db, conditions=(Policy.key == AUTOGENERATED_ACCCES_KEY)
    ).first():
        # Only create a "download" policy if one does not already exist
        autogenerate_access_policy(db, client, default_local_storage)
    if not Policy.filter(
        db=db, conditions=(Policy.key == AUTOGENERATED_ERASURE_KEY)
    ).first():
        # Only create a "delete" policy if one does not already exist
        autogenerate_erasure_policy(db, client)

    db.close()


def downgrade():
    """Data migration only.

    Remove 'download' and delete' policies if they were created by the autogenerated client, and then
    attempt to remove the autogenerated client and local storage destination.
    """
    if config.is_test_mode:
        logger.info(f"Skipping data migration in test mode'")
        return

    connection = op.get_bind()
    session_maker = sessionmaker(bind=connection.engine)
    db = session_maker(bind=connection)

    client = ClientDetail.filter(
        db=db, conditions=(ClientDetail.fides_key == FIDESOPS_AUTOGENERATED_CLIENT_KEY)
    ).first()

    if not client:
        logger.info(f"No autogenerated client: '{FIDESOPS_AUTOGENERATED_CLIENT_KEY}'")
        return

    access_policy = Policy.filter(
        db=db,
        conditions=(
            Policy.key == AUTOGENERATED_ACCCES_KEY and Policy.client_id == client.id
        ),
    ).first()
    if access_policy:
        logger.info(
            f"Deleting autogenerated '{AUTOGENERATED_ACCCES_KEY}' access policy"
        )
        # Only delete "download" policy if it was created by the autogenerated client
        access_policy.delete(db)

    erasure_policy = Policy.filter(
        db=db,
        conditions=(
            Policy.key == AUTOGENERATED_ERASURE_KEY and Policy.client_id == client.id
        ),
    ).first()

    if erasure_policy:
        # Only delete "delete" policy if it was created by the autogenerated client
        logger.info(
            f"Deleting autogenerated '{AUTOGENERATED_ERASURE_KEY}' erasure policy"
        )
        erasure_policy.delete(db)

    try:
        logger.info(
            f"Deleting autogenerated client: '{FIDESOPS_AUTOGENERATED_CLIENT_KEY}'"
        )
        client.delete(db)
        storage = StorageConfig.filter(
            db=db, conditions=(StorageConfig.key == FIDESOPS_AUTOGENERATED_STORAGE_KEY)
        ).first()
        if storage:
            logger.info(
                f"Deleting autogenerated local storage: '{FIDESOPS_AUTOGENERATED_STORAGE_KEY}'"
            )
            storage.delete(db)
    except Exception:
        # It's possible the client or storage config have been attached to other things
        pass

    db.close()


def autogenerate_access_policy(
    db: Session, client: ClientDetail, storage: StorageConfig
) -> None:
    """Create an autogenerated 'download' access policy, with an access rule attached,
    targeting user.provided.identifiable data"""
    logger.info(f"Creating autogenerated '{AUTOGENERATED_ACCCES_KEY}' policy")
    access_policy = Policy.create_or_update(
        db,
        data={
            "name": "Fidesops Autogenerated Access Policy",
            "key": AUTOGENERATED_ACCCES_KEY,
            "drp_action": DrpAction.access,
            "client_id": client.id,
        },
    )

    access_rule = Rule.create(
        db,
        data={
            "name": "Fidesops Autogenerated Access Rule",
            "action_type": ActionType.access.value,
            "policy_id": access_policy.id,
            "client_id": client.id,
            "storage_destination_id": storage.id,
        },
    )

    RuleTarget.create(
        db=db,
        data={
            "name": "Fidesops Autogenerated Access Target",
            "data_category": DataCategory("user.provided.identifiable").value,
            "rule_id": access_rule.id,
            "client_id": client.id,
        },
    )


def autogenerate_erasure_policy(db: Session, client: ClientDetail) -> None:
    """Create an autogenerated 'deletion' erasure policy, with an erasure rule attached,
    targeting user.provided.identifiable data"""
    logger.info(f"Creating autogenerated '{AUTOGENERATED_ERASURE_KEY}' policy")

    erasure_policy = Policy.create_or_update(
        db,
        data={
            "name": "Fidesops Autogenerated Erasure Policy",
            "key": AUTOGENERATED_ERASURE_KEY,
            "drp_action": DrpAction.deletion,
            "client_id": client.id,
        },
    )

    erasure_rule = Rule.create(
        db,
        data={
            "name": "Fidesops Autogenerated Erasure Rule",
            "action_type": ActionType.erasure.value,
            "policy_id": erasure_policy.id,
            "client_id": client.id,
            "masking_strategy": {
                "strategy": "null_rewrite",
                "configuration": {},
            },
        },
    )

    RuleTarget.create(
        db=db,
        data={
            "name": "Fidesops Autogenerated Erasure Target",
            "data_category": DataCategory("user.provided.identifiable").value,
            "rule_id": erasure_rule.id,
            "client_id": client.id,
        },
    )
