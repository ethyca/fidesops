{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fidesops? Fidesops (fee-dez-\u00e4ps, combination of the Latin term \"Fid\u0113s\" + \"operations\") is an open-source, extensible, deployed engine that fulfills any privacy request (e.g. access request, erasure request) by connecting directly to your disparate databases and third party SaaS applications. Key Features Programmable Data Privacy Fidesops connects and orchestrates calls to all of your connected databases and third party systems in order to access, update and delete sensitive data per your policy configuration written in Fideslang. Handle Dependencies Between Datastores Fidesops works by integrating all your datasets into a unified graph and automatically traversing them in order. We know that sensitive data is stored all around your dynamic ecosystem, so fidesops builds these dependencies automatically for each request. Integrate with Compliance Tools Fidesops is open & extensible, meaning it can easily be integrated into your existing privacy compliance management tools like OneTrust to fulfill data subject requests and return results, automatically. Built to Scale Lots of databases? Tons of microservices? Connect as many databases and services as you'd like, and let fidesops do the heavy lifting. How does fidesops work with fidesctl and fideslang? In a software organization, the team that writes and delivers software is normally the same team responsible for executing a privacy request when it comes in from customer support or legal teams. When your organization receives a privacy request, fidesops will automatically fulfill it per the execution policies your legal and business owners have created by querying your databases directly. Your policies and database annotations are written in fideslang : the syntax that describes the attributes of your data and its allowed purposes of use. But after identifying what types of data are in your databases using fideslang, how will your organization know what data is deemed sensitive? And how will your organization prevent inappropriate uses of that data? That's where fidesctl comes in. Fidesctl is a CLI tool that continuously verifies fideslang database annotations against rules defined by your organization's privacy policies. Next Steps To start automating requests with fidesops, visit the Tutorial for a step-by-step walk through!","title":"What is Fidesops?"},{"location":"#what-is-fidesops","text":"Fidesops (fee-dez-\u00e4ps, combination of the Latin term \"Fid\u0113s\" + \"operations\") is an open-source, extensible, deployed engine that fulfills any privacy request (e.g. access request, erasure request) by connecting directly to your disparate databases and third party SaaS applications.","title":"What is Fidesops?"},{"location":"#key-features","text":"","title":"Key Features"},{"location":"#programmable-data-privacy","text":"Fidesops connects and orchestrates calls to all of your connected databases and third party systems in order to access, update and delete sensitive data per your policy configuration written in Fideslang.","title":"Programmable Data Privacy"},{"location":"#handle-dependencies-between-datastores","text":"Fidesops works by integrating all your datasets into a unified graph and automatically traversing them in order. We know that sensitive data is stored all around your dynamic ecosystem, so fidesops builds these dependencies automatically for each request.","title":"Handle Dependencies Between Datastores"},{"location":"#integrate-with-compliance-tools","text":"Fidesops is open & extensible, meaning it can easily be integrated into your existing privacy compliance management tools like OneTrust to fulfill data subject requests and return results, automatically.","title":"Integrate with Compliance Tools"},{"location":"#built-to-scale","text":"Lots of databases? Tons of microservices? Connect as many databases and services as you'd like, and let fidesops do the heavy lifting.","title":"Built to Scale"},{"location":"#how-does-fidesops-work-with-fidesctl-and-fideslang","text":"In a software organization, the team that writes and delivers software is normally the same team responsible for executing a privacy request when it comes in from customer support or legal teams. When your organization receives a privacy request, fidesops will automatically fulfill it per the execution policies your legal and business owners have created by querying your databases directly. Your policies and database annotations are written in fideslang : the syntax that describes the attributes of your data and its allowed purposes of use. But after identifying what types of data are in your databases using fideslang, how will your organization know what data is deemed sensitive? And how will your organization prevent inappropriate uses of that data? That's where fidesctl comes in. Fidesctl is a CLI tool that continuously verifies fideslang database annotations against rules defined by your organization's privacy policies.","title":"How does fidesops work with fidesctl and fideslang?"},{"location":"#next-steps","text":"To start automating requests with fidesops, visit the Tutorial for a step-by-step walk through!","title":"Next Steps"},{"location":"deployment/","text":"Deployment Guide To quickly experiment with fidesops , it's easiest to clone the source repo and use the built-in docker compose configuration to get a fully working demo environment up and running. However, when you want to use fidesops in production, you'll want to deploy it in parts, leveraging whatever cloud infrastructure your organization is most familiar with. Fully deployed, fidesops has three individual systems you'll need to run: Hosted Database : PostgreSQL database server used for permanent storage of configuration data for the web server Hosted Cache : Redis database server used as a temporary cache during execution and scheduling of tasks fidesops Web Server : Main application with API endpoints to configure, execute, and report on privacy requests Optionally the frontend privacy center can be deployed as a pre-built way to handle privacy requests. Let's review each individually. Step 1: Setup Hosted Database Like most web applications, fidesops uses an application database for persistent storage. Any hosted PostgreSQL database solution will work (PostgreSQL version 12+), as long as it's accessible. Good options include: Managed PostgreSQL database services (e.g. AWS RDS, GCP Cloud SQL, Azure Database) Self-hosted PostgreSQL Docker container with a persistent volume mount (e.g. on a Kubernetes cluster) Self-hosted PostgreSQL server (e.g. on an EC2 server) NOTE: there is no reason to expose this database to the public Internet as long as it will be accessible by your fidesops web server! Setting up a production-grade PostgreSQL database is likely something your team is already familiar with, so we won't revisit that here. Once it's up and running, make sure you create a unique user and database to use for fidesops (we recommended calling these both fidesops ) and assign a secure password, then keep track of all those credentials. You'll need those values later to populate these configuration variables for fidesops : Config Variable Example Description FIDESOPS__DATABASE__SERVER postgres.internal hostname for your database server FIDESOPS__DATABASE__USER fidesops username fidesops should use to access the database FIDESOPS__DATABASE__PASSWORD fidesopssecret password fidesops should use to access the database FIDESOPS__DATABASE__DB fidesops database name Fidesops PostgreSQL app database diagram Step 2: Setup Hosted Cache During privacy request execution, fidesops collects result data in a temporary Redis cache that automatically expires to ensure personal data is never retained erroneously. Any hosted Redis database will work for this purpose (Redis version 6.2.0+), from a simple Docker redis container to a managed service (e.g. AWS ElastiCache, GCP Memorystore, Azure Cache, Redis Cloud). NOTE: Similar to PostgreSQL, there is no reason to expose this cache to the public Internet as long as it is will be accessible by your fidesops web server! As with the PostgreSQL deployment, setting up a production-grade Redis cache is outside the scope of these docs. Once your Redis cache is available, ensure you enable a password (via Redis AUTH ) to provide additional security, and then keep track of all the connection credentials as you'll need these to configure fidesops in the next step with the following variables: Config Variable Example Description FIDESOPS__REDIS__HOST redis.internal hostname for your Redis server FIDESOPS__REDIS__PORT 6379 port for your Redis server FIDESOPS__REDIS__PASSWORD fidesopssecret password fidesops should use to access Redis FIDESOPS__REDIS__SSL true Whether we should enable Redis SSL FIDESOPS__REDIS__SSL_CERT_REQS required Hostname verification. If SSL is true, the default is that it is required. Step 3: Setup fidesops Web Server The fidesops web server is a FastAPI application with a Uvicorn server to handle requests. The host requirements for the fidesops web server are pretty minimal: A general purpose web server (e.g. for AWS EC2, a t2.small should be plenty) No persistent storage requirements (this is handled by the hosted database) Docker version 20.10.8 or newer (if installing via Docker) OR Python 3.8 or newer (if installing via Python) Depending on your preferences, you can install fidesops in one of two ways: Docker or Python . Install fidesops via Docker If you typically run your applications via Docker, you'll probably be familiar with pulling images and configuring them with environment variables. Setting up a fidesops container should contain no surprises. First, ensure that Docker is running on your host, with a minimum version of 20.10.8 . You can docker pull ethyca/fidesops to get the latest image from Ethyca's Docker Hub here: ethyca/fidesops . 1 docker pull ethyca/fidesops Once pulled, you can run docker run ethyca/fidesops to start the server. To configure fidesops for your environment, however, you'll need to provide a number of required environment variables through docker run . You can accomplish this either by creating a .env file and passing it in via the --env-file {file} option or by providing individual variables with the --env {VAR} option. At a minimum, you'll need to provide the following as env variables: Config Variable Example Description FIDESOPS__SECURITY__APP_ENCRYPTION_KEY averyveryverysecretencryptionkey AES256 encryption key used for DB & JWE encryption, must be exactly 32 characters (256bits) FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID fidesopsadmin client ID used for the \"root\" OAuth client FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET fidesopsadminsecret client secret used for the \"root\" OAuth client FIDESOPS__DATABASE__SERVER postgres.internal hostname for your database server FIDESOPS__DATABASE__PORT 5432 port for your database server FIDESOPS__DATABASE__USER fidesops username fidesops should use to access the database FIDESOPS__DATABASE__PASSWORD fidesopssecret password fidesops should use to access the database FIDESOPS__DATABASE__DB fidesops database name FIDESOPS__REDIS__HOST redis.internal hostname for your Redis server FIDESOPS__REDIS__PORT 6379 port for your Redis server FIDESOPS__REDIS__PASSWORD fidesopssecret password fidesops should use to access Redis Lastly, you'll also want to ensure you use the -p 8080:8080 option to docker run to bind port 8080 (the web server) to port 8080 on the host, so you can connect from the outside. Putting this together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 docker run \\ -p 8080:8080 \\ --env FIDESOPS__SECURITY__APP_ENCRYPTION_KEY=\"averyveryverysecretencryptionkey\" \\ --env FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID=\"fidesopsadmin\" \\ --env FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET=\"fidesopsadminsecret\" \\ --env FIDESOPS__DATABASE__SERVER=\"postgres.internal\" \\ --env FIDESOPS__DATABASE__PORT=\"5432\" \\ --env FIDESOPS__DATABASE__USER=\"fidesops\" \\ --env FIDESOPS__DATABASE__PASSWORD=\"fidesopssecret\" \\ --env FIDESOPS__DATABASE__DB=\"fidesops\" \\ --env FIDESOPS__REDIS__HOST=\"redis.internal\" \\ --env FIDESOPS__REDIS__PORT=6379 \\ --env FIDESOPS__REDIS__PASSWORD=\"fidesopssecret\" \\ ethyca/fidesops Or if you prefer to create your .env file and pass an --env-file variable, you can use the following: 1 2 3 4 docker run \\ -p 8080:8080 \\ --env-file=<ENV FILE NAME>.env \\ ethyca/fidesops config.env 1 2 3 4 5 6 7 8 9 10 11 FIDESOPS__SECURITY__APP_ENCRYPTION_KEY=\"averyveryverysecretencryptionkey\" FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID=\"fidesopsadmin\" FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET=\"fidesopsadminsecret\" FIDESOPS__DATABASE__SERVER=\"postgres.internal\" FIDESOPS__DATABASE__PORT=\"5432\" FIDESOPS__DATABASE__USER=\"fidesops\" FIDESOPS__DATABASE__PASSWORD=\"fidesopssecret\" FIDESOPS__DATABASE__DB=\"fidesops\" FIDESOPS__REDIS__HOST=\"redis.internal\" FIDESOPS__REDIS__PORT=6379 FIDESOPS__REDIS__PASSWORD=\"fidesopssecret\" Now, for most Docker hosts, you won't be calling docker run directly, and instead will be providing configuration variables to Kubernetes/Swarm/ECS/etc. As you can see in the docker run example above, this config is quite minimal and should just involve specifying (1) the image, (2) the port mapping, (3) all the various environment variables for configuration. Note that there's no need for a persistent volume mount for the web server, it's fully ephemeral and relies on the database for all it's permanent state. Test the Web Server To test that your server is running, visit http://{server_url}/health in your browser (e.g. http://0.0.0.0:8080/health) and you should see {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} . You now have a functional fidesops server running! Now you can use the API to set up your OAuth clients, connect to databases, configure policies, execute privacy requests, etc. To learn more, head to the How-To Guides for details. Step 4: Setup Privacy Center (Optional) Install the fidesops privacy center via Docker First, ensure that Docker is running on your host, with a minimum version of 20.10.8 . You can docker pull ethyca/fides-privacy-center to get the latest image from Ethyca's Docker Hub here: ethyca/fides-privacy-center . 1 docker pull ethyca/fides-privacy-center Once pulled, you can run docker run -rm -p 3000:3000 ethyca/fides-privacy-center:latest to start the server. To configure the privacy center for your environment create a project directory, i.e. ~/custom-privacy-center , and within this directory create a config directory. Copy the config.json and config.css into the config directory and modify to fit your needs. More information about the configuration options can be found here . After the configuration is updated the docker image can be run using your custom settings. From within the ~/custom-privacy-center directory (modify this directory name to match the name you used) start the docker container: 1 docker run --rm -v $(pwd)/config:/app/config -p 3000:3000 ethyca/fides-privacy-center:latest","title":"Deployment Guide"},{"location":"deployment/#deployment-guide","text":"To quickly experiment with fidesops , it's easiest to clone the source repo and use the built-in docker compose configuration to get a fully working demo environment up and running. However, when you want to use fidesops in production, you'll want to deploy it in parts, leveraging whatever cloud infrastructure your organization is most familiar with. Fully deployed, fidesops has three individual systems you'll need to run: Hosted Database : PostgreSQL database server used for permanent storage of configuration data for the web server Hosted Cache : Redis database server used as a temporary cache during execution and scheduling of tasks fidesops Web Server : Main application with API endpoints to configure, execute, and report on privacy requests Optionally the frontend privacy center can be deployed as a pre-built way to handle privacy requests. Let's review each individually.","title":"Deployment Guide"},{"location":"deployment/#step-1-setup-hosted-database","text":"Like most web applications, fidesops uses an application database for persistent storage. Any hosted PostgreSQL database solution will work (PostgreSQL version 12+), as long as it's accessible. Good options include: Managed PostgreSQL database services (e.g. AWS RDS, GCP Cloud SQL, Azure Database) Self-hosted PostgreSQL Docker container with a persistent volume mount (e.g. on a Kubernetes cluster) Self-hosted PostgreSQL server (e.g. on an EC2 server) NOTE: there is no reason to expose this database to the public Internet as long as it will be accessible by your fidesops web server! Setting up a production-grade PostgreSQL database is likely something your team is already familiar with, so we won't revisit that here. Once it's up and running, make sure you create a unique user and database to use for fidesops (we recommended calling these both fidesops ) and assign a secure password, then keep track of all those credentials. You'll need those values later to populate these configuration variables for fidesops : Config Variable Example Description FIDESOPS__DATABASE__SERVER postgres.internal hostname for your database server FIDESOPS__DATABASE__USER fidesops username fidesops should use to access the database FIDESOPS__DATABASE__PASSWORD fidesopssecret password fidesops should use to access the database FIDESOPS__DATABASE__DB fidesops database name","title":"Step 1: Setup Hosted Database"},{"location":"deployment/#fidesops-postgresql-app-database-diagram","text":"","title":"Fidesops PostgreSQL app database diagram"},{"location":"deployment/#step-2-setup-hosted-cache","text":"During privacy request execution, fidesops collects result data in a temporary Redis cache that automatically expires to ensure personal data is never retained erroneously. Any hosted Redis database will work for this purpose (Redis version 6.2.0+), from a simple Docker redis container to a managed service (e.g. AWS ElastiCache, GCP Memorystore, Azure Cache, Redis Cloud). NOTE: Similar to PostgreSQL, there is no reason to expose this cache to the public Internet as long as it is will be accessible by your fidesops web server! As with the PostgreSQL deployment, setting up a production-grade Redis cache is outside the scope of these docs. Once your Redis cache is available, ensure you enable a password (via Redis AUTH ) to provide additional security, and then keep track of all the connection credentials as you'll need these to configure fidesops in the next step with the following variables: Config Variable Example Description FIDESOPS__REDIS__HOST redis.internal hostname for your Redis server FIDESOPS__REDIS__PORT 6379 port for your Redis server FIDESOPS__REDIS__PASSWORD fidesopssecret password fidesops should use to access Redis FIDESOPS__REDIS__SSL true Whether we should enable Redis SSL FIDESOPS__REDIS__SSL_CERT_REQS required Hostname verification. If SSL is true, the default is that it is required.","title":"Step 2: Setup Hosted Cache"},{"location":"deployment/#step-3-setup-fidesops-web-server","text":"The fidesops web server is a FastAPI application with a Uvicorn server to handle requests. The host requirements for the fidesops web server are pretty minimal: A general purpose web server (e.g. for AWS EC2, a t2.small should be plenty) No persistent storage requirements (this is handled by the hosted database) Docker version 20.10.8 or newer (if installing via Docker) OR Python 3.8 or newer (if installing via Python) Depending on your preferences, you can install fidesops in one of two ways: Docker or Python .","title":"Step 3: Setup fidesops Web Server"},{"location":"deployment/#install-fidesops-via-docker","text":"If you typically run your applications via Docker, you'll probably be familiar with pulling images and configuring them with environment variables. Setting up a fidesops container should contain no surprises. First, ensure that Docker is running on your host, with a minimum version of 20.10.8 . You can docker pull ethyca/fidesops to get the latest image from Ethyca's Docker Hub here: ethyca/fidesops . 1 docker pull ethyca/fidesops Once pulled, you can run docker run ethyca/fidesops to start the server. To configure fidesops for your environment, however, you'll need to provide a number of required environment variables through docker run . You can accomplish this either by creating a .env file and passing it in via the --env-file {file} option or by providing individual variables with the --env {VAR} option. At a minimum, you'll need to provide the following as env variables: Config Variable Example Description FIDESOPS__SECURITY__APP_ENCRYPTION_KEY averyveryverysecretencryptionkey AES256 encryption key used for DB & JWE encryption, must be exactly 32 characters (256bits) FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID fidesopsadmin client ID used for the \"root\" OAuth client FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET fidesopsadminsecret client secret used for the \"root\" OAuth client FIDESOPS__DATABASE__SERVER postgres.internal hostname for your database server FIDESOPS__DATABASE__PORT 5432 port for your database server FIDESOPS__DATABASE__USER fidesops username fidesops should use to access the database FIDESOPS__DATABASE__PASSWORD fidesopssecret password fidesops should use to access the database FIDESOPS__DATABASE__DB fidesops database name FIDESOPS__REDIS__HOST redis.internal hostname for your Redis server FIDESOPS__REDIS__PORT 6379 port for your Redis server FIDESOPS__REDIS__PASSWORD fidesopssecret password fidesops should use to access Redis Lastly, you'll also want to ensure you use the -p 8080:8080 option to docker run to bind port 8080 (the web server) to port 8080 on the host, so you can connect from the outside. Putting this together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 docker run \\ -p 8080:8080 \\ --env FIDESOPS__SECURITY__APP_ENCRYPTION_KEY=\"averyveryverysecretencryptionkey\" \\ --env FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID=\"fidesopsadmin\" \\ --env FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET=\"fidesopsadminsecret\" \\ --env FIDESOPS__DATABASE__SERVER=\"postgres.internal\" \\ --env FIDESOPS__DATABASE__PORT=\"5432\" \\ --env FIDESOPS__DATABASE__USER=\"fidesops\" \\ --env FIDESOPS__DATABASE__PASSWORD=\"fidesopssecret\" \\ --env FIDESOPS__DATABASE__DB=\"fidesops\" \\ --env FIDESOPS__REDIS__HOST=\"redis.internal\" \\ --env FIDESOPS__REDIS__PORT=6379 \\ --env FIDESOPS__REDIS__PASSWORD=\"fidesopssecret\" \\ ethyca/fidesops Or if you prefer to create your .env file and pass an --env-file variable, you can use the following: 1 2 3 4 docker run \\ -p 8080:8080 \\ --env-file=<ENV FILE NAME>.env \\ ethyca/fidesops config.env 1 2 3 4 5 6 7 8 9 10 11 FIDESOPS__SECURITY__APP_ENCRYPTION_KEY=\"averyveryverysecretencryptionkey\" FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID=\"fidesopsadmin\" FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET=\"fidesopsadminsecret\" FIDESOPS__DATABASE__SERVER=\"postgres.internal\" FIDESOPS__DATABASE__PORT=\"5432\" FIDESOPS__DATABASE__USER=\"fidesops\" FIDESOPS__DATABASE__PASSWORD=\"fidesopssecret\" FIDESOPS__DATABASE__DB=\"fidesops\" FIDESOPS__REDIS__HOST=\"redis.internal\" FIDESOPS__REDIS__PORT=6379 FIDESOPS__REDIS__PASSWORD=\"fidesopssecret\" Now, for most Docker hosts, you won't be calling docker run directly, and instead will be providing configuration variables to Kubernetes/Swarm/ECS/etc. As you can see in the docker run example above, this config is quite minimal and should just involve specifying (1) the image, (2) the port mapping, (3) all the various environment variables for configuration. Note that there's no need for a persistent volume mount for the web server, it's fully ephemeral and relies on the database for all it's permanent state.","title":"Install fidesops via Docker"},{"location":"deployment/#test-the-web-server","text":"To test that your server is running, visit http://{server_url}/health in your browser (e.g. http://0.0.0.0:8080/health) and you should see {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} . You now have a functional fidesops server running! Now you can use the API to set up your OAuth clients, connect to databases, configure policies, execute privacy requests, etc. To learn more, head to the How-To Guides for details.","title":"Test the Web Server"},{"location":"deployment/#step-4-setup-privacy-center-optional","text":"","title":"Step 4: Setup Privacy Center (Optional)"},{"location":"deployment/#install-the-fidesops-privacy-center-via-docker","text":"First, ensure that Docker is running on your host, with a minimum version of 20.10.8 . You can docker pull ethyca/fides-privacy-center to get the latest image from Ethyca's Docker Hub here: ethyca/fides-privacy-center . 1 docker pull ethyca/fides-privacy-center Once pulled, you can run docker run -rm -p 3000:3000 ethyca/fides-privacy-center:latest to start the server. To configure the privacy center for your environment create a project directory, i.e. ~/custom-privacy-center , and within this directory create a config directory. Copy the config.json and config.css into the config directory and modify to fit your needs. More information about the configuration options can be found here . After the configuration is updated the docker image can be run using your custom settings. From within the ~/custom-privacy-center directory (modify this directory name to match the name you used) start the docker container: 1 docker run --rm -v $(pwd)/config:/app/config -p 3000:3000 ethyca/fides-privacy-center:latest","title":"Install the fidesops privacy center via Docker"},{"location":"ethyca/","text":"About Ethyca The mission of Ethyca is to make Internet-scale technology respectful and ethical. We're a venture-backed privacy technology team headquartered in New York, but working as a distributed team across the US to solve what we believe is the most important problem in technology today: the human right to privacy in vastly complex data-driven systems. What is Fides? Fides is a universally understandable, open-source language that can be used to describe privacy within tech infrastructure. Our existing tools ( fidesctl and fidesops ) use this language to power a low friction set of developer tools that integrate with your existing CI pipelines, making privacy a feature of your tech stack. With Fides, we hope everyone can build better tools for privacy in the next decade and beyond. What we Believe Data privacy is a human right that should be a native feature of any respectful technology. Today building great privacy as a feature in software is friction-filled and complicated. We're building open-source privacy tools for the developer community because we believe the only way to achieve a respectful internet is to make privacy an easy-to-implement layer of any tech stack. The Future We've been working on this problem since 2018 and have a clear view of our next five years. We're excited about the roadmap of features we'll add to Fides in order to make it the comprehensive tool for addressing the major challenges of privacy in both the code management and runtime environments. This means building solutions for automated privacy analysis, context rich data classification, automated data orchestration for privacy rights, semantic access control models, and more. We'd love you to contribute to Fides and you can do this directly as part of the open-source community. If you're interested in solving some of the toughest and most important problems facing internet scale data-driven software, join us now and get paid to work on this problem too! Your Participation Fides' success is predicated on your participation -- Privacy as Code can only become a reality if we ensure it's easy to understand, implement and an interoperable standard for wide adoption. Your feedback, contributions and improvements are encouraged as we work towards building a community with the sole objective of building more respectful software for everyone on the internet.","title":"About Ethyca"},{"location":"ethyca/#about-ethyca","text":"The mission of Ethyca is to make Internet-scale technology respectful and ethical. We're a venture-backed privacy technology team headquartered in New York, but working as a distributed team across the US to solve what we believe is the most important problem in technology today: the human right to privacy in vastly complex data-driven systems.","title":"About Ethyca"},{"location":"ethyca/#what-is-fides","text":"Fides is a universally understandable, open-source language that can be used to describe privacy within tech infrastructure. Our existing tools ( fidesctl and fidesops ) use this language to power a low friction set of developer tools that integrate with your existing CI pipelines, making privacy a feature of your tech stack. With Fides, we hope everyone can build better tools for privacy in the next decade and beyond.","title":"What is Fides?"},{"location":"ethyca/#what-we-believe","text":"Data privacy is a human right that should be a native feature of any respectful technology. Today building great privacy as a feature in software is friction-filled and complicated. We're building open-source privacy tools for the developer community because we believe the only way to achieve a respectful internet is to make privacy an easy-to-implement layer of any tech stack.","title":"What we Believe"},{"location":"ethyca/#the-future","text":"We've been working on this problem since 2018 and have a clear view of our next five years. We're excited about the roadmap of features we'll add to Fides in order to make it the comprehensive tool for addressing the major challenges of privacy in both the code management and runtime environments. This means building solutions for automated privacy analysis, context rich data classification, automated data orchestration for privacy rights, semantic access control models, and more. We'd love you to contribute to Fides and you can do this directly as part of the open-source community. If you're interested in solving some of the toughest and most important problems facing internet scale data-driven software, join us now and get paid to work on this problem too!","title":"The Future"},{"location":"ethyca/#your-participation","text":"Fides' success is predicated on your participation -- Privacy as Code can only become a reality if we ensure it's easy to understand, implement and an interoperable standard for wide adoption. Your feedback, contributions and improvements are encouraged as we work towards building a community with the sole objective of building more respectful software for everyone on the internet.","title":"Your Participation"},{"location":"getting_started/","text":"Getting Started The fidesops repository includes a built-in docker compose configuration for quickly experimenting with a working demo environment. For a more detailed guide on fidesops, the tutorial provides an in-depth introduction, and a full installation guide is available for production deployments. Requirements Docker 12+ Python 3.8+ Build from the fidesops repo Ensure nothing is running on ports 8080 , 5432 , or 6379 prior to these steps. Clone the fidesops repository . Run docker compose up from the root of the fidesops project directory. The provided docker-compose.yml will create the necessary databases and spin up the server. Visit http://0.0.0.0:8080/health in your browser. A response of {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} indicates a successful deployment. Build from your project Note The provided docker instructions are intended only for experimenting in development environments. For production installations, see the deployment guides . Ensure nothing is running on ports 8080 , 5432 , or 6379 prior to these steps. To replicate the demo environment in your own project, create a docker-compose.yml file like the example below in your application's root directory. docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 services : fidesops : image : ethyca/fidesops container_name : fidesops depends_on : - db - redis expose : - 8080 healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://0.0.0.0:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 1s ports : - \"8080:8080\" volumes : - type : bind source : ./ target : /fidesops #Update this to the path of your project directory read_only : False db : image : postgres:12 volumes : - app-db-data:/var/lib/postgresql/data/pgdata environment : - PGDATA=/var/lib/postgresql/data/pgdata - POSTGRES_USER=postgres - POSTGRES_PASSWORD=216f4b49bea5da4f84f05288258471852c3e325cd336821097e1e65ff92b528a - POSTGRES_DB=app expose : - 5432 ports : - \"0.0.0.0:5432:5432\" deploy : placement : constraints : - node.labels.fidesops.app-db-data == true redis : image : \"redis:6.2.5-alpine\" command : redis-server --requirepass testpassword environment : - REDIS_PASSWORD=testpassword expose : - 6379 ports : - \"0.0.0.0:6379:6379\" volumes : app-db-data : Ensure Docker is running, and run docker compose up from the project's root directory. This will pull the latest fidesops Docker image, create the sample databases, and start the server. Visit http://0.0.0.0:8080/health in your browser. A response of {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} indicates a successful deployment.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"The fidesops repository includes a built-in docker compose configuration for quickly experimenting with a working demo environment. For a more detailed guide on fidesops, the tutorial provides an in-depth introduction, and a full installation guide is available for production deployments.","title":"Getting Started"},{"location":"getting_started/#requirements","text":"Docker 12+ Python 3.8+","title":"Requirements"},{"location":"getting_started/#build-from-the-fidesops-repo","text":"Ensure nothing is running on ports 8080 , 5432 , or 6379 prior to these steps. Clone the fidesops repository . Run docker compose up from the root of the fidesops project directory. The provided docker-compose.yml will create the necessary databases and spin up the server. Visit http://0.0.0.0:8080/health in your browser. A response of {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} indicates a successful deployment.","title":"Build from the fidesops repo"},{"location":"getting_started/#build-from-your-project","text":"Note The provided docker instructions are intended only for experimenting in development environments. For production installations, see the deployment guides . Ensure nothing is running on ports 8080 , 5432 , or 6379 prior to these steps. To replicate the demo environment in your own project, create a docker-compose.yml file like the example below in your application's root directory. docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 services : fidesops : image : ethyca/fidesops container_name : fidesops depends_on : - db - redis expose : - 8080 healthcheck : test : [ \"CMD\" , \"curl\" , \"-f\" , \"http://0.0.0.0:8080/health\" ] interval : 30s timeout : 10s retries : 3 start_period : 1s ports : - \"8080:8080\" volumes : - type : bind source : ./ target : /fidesops #Update this to the path of your project directory read_only : False db : image : postgres:12 volumes : - app-db-data:/var/lib/postgresql/data/pgdata environment : - PGDATA=/var/lib/postgresql/data/pgdata - POSTGRES_USER=postgres - POSTGRES_PASSWORD=216f4b49bea5da4f84f05288258471852c3e325cd336821097e1e65ff92b528a - POSTGRES_DB=app expose : - 5432 ports : - \"0.0.0.0:5432:5432\" deploy : placement : constraints : - node.labels.fidesops.app-db-data == true redis : image : \"redis:6.2.5-alpine\" command : redis-server --requirepass testpassword environment : - REDIS_PASSWORD=testpassword expose : - 6379 ports : - \"0.0.0.0:6379:6379\" volumes : app-db-data : Ensure Docker is running, and run docker compose up from the project's root directory. This will pull the latest fidesops Docker image, create the sample databases, and start the server. Visit http://0.0.0.0:8080/health in your browser. A response of {\"webserver\": \"healthy\", \"database\": \"healthy\", \"cache\": \"healthy\"} indicates a successful deployment.","title":"Build from your project"},{"location":"glossary/","text":"Glossary of Key Terms Fidesops terms Privacy Request : A Privacy Request is a fidesops representation of what is more widely known as a Data Subject Request, or Data Subject Access Request. access request: The customer wants to see the data an organization has collected about them. erasure request: The customer wants an organization to delete the data they have collected about them. Policy : Different from a fidesctl Policy, this is a configuration that describes how to handle a Privacy Request. For example, you might define a simple policy that when given an email, it locates all the related data the customer has provided to you, and upload that to a specific S3 bucket. ConnectionConfig : A configuration for how to connect a database to fidesops, so it can retrieve or remove customer data. DatasetConfig : A resource that contains a fidesctl Dataset (the annotation of a database schema) and its related ConnectionConfig StorageConfig : A configuration for where the customer's data is going to be sent after an access request. MaskingStrategy : A configuration for how to erase customer data - for example, you might replace a customer's email with a random string. Identity : A piece of information used to uniquely identify an individual, like an email or a phone number. Identity Graph : A mapping that knows where personal data lives and how to look it up. For example, you might have photos stored in a MySQL database and customer information stored in a PostgreSQL database. The identity graph might say to get the customer id from the PostgreSQL database, and use that to look up the customer's photo in the MySQL database. Traversal : Created from an identity and an identity graph. In short, it says here's the first table I'm going to visit, I'm going to get this Field, cache it, and then use that to get this information from the next Collection, and so on. PolicyPreWebhook : Webhooks configured on a Policy to be triggered before a PrivacyRequest is executed. PolicyPostWebhook : Webhooks configured on a Policy to be triggered after a PrivacyRequest is executed. Database terms: Datasets - Resources at the database level. Datasets can have many Collections. Collections - A table, or a Collection of related data. Collections can have many Fields. Fields - Attributes on Collections. Fidesctl terms See the fidesctl repo for more information, but here's some fidesctl terms that might be helpful in fidesops. Manifest : YAML files that describe different types of objects within Fides, with a high-level \"privacy as code\" language. Policy : Different from a fidesops Policy, this controls what kinds of data you are permitted to commit to source code. For example, you might create a fidesctl policy that says, I am not going to allow any System that takes in provided contact information and uses it for marketing purposes. Dataset : An annotation of a database schema, which describes the Collections in a database, the Fields, the Data Categories of those fields, and the relationships between relevant Collections. System : Systems represent the applications, services, integrations, and any software that processes data for a specific use case. Privacy Data Types: Data Category - What kind of data is it? For example, the Data Category user includes things like contact email and street address. Data Use - Why is it being used? For example, for advertising or to improve the system. Data Subject - Whose data is it? For example, a customer . Data Qualifier - How is the data being protected? For example, it might be aggregated .","title":"Glossary"},{"location":"glossary/#glossary-of-key-terms","text":"","title":"Glossary of Key Terms"},{"location":"glossary/#fidesops-terms","text":"Privacy Request : A Privacy Request is a fidesops representation of what is more widely known as a Data Subject Request, or Data Subject Access Request. access request: The customer wants to see the data an organization has collected about them. erasure request: The customer wants an organization to delete the data they have collected about them. Policy : Different from a fidesctl Policy, this is a configuration that describes how to handle a Privacy Request. For example, you might define a simple policy that when given an email, it locates all the related data the customer has provided to you, and upload that to a specific S3 bucket. ConnectionConfig : A configuration for how to connect a database to fidesops, so it can retrieve or remove customer data. DatasetConfig : A resource that contains a fidesctl Dataset (the annotation of a database schema) and its related ConnectionConfig StorageConfig : A configuration for where the customer's data is going to be sent after an access request. MaskingStrategy : A configuration for how to erase customer data - for example, you might replace a customer's email with a random string. Identity : A piece of information used to uniquely identify an individual, like an email or a phone number. Identity Graph : A mapping that knows where personal data lives and how to look it up. For example, you might have photos stored in a MySQL database and customer information stored in a PostgreSQL database. The identity graph might say to get the customer id from the PostgreSQL database, and use that to look up the customer's photo in the MySQL database. Traversal : Created from an identity and an identity graph. In short, it says here's the first table I'm going to visit, I'm going to get this Field, cache it, and then use that to get this information from the next Collection, and so on. PolicyPreWebhook : Webhooks configured on a Policy to be triggered before a PrivacyRequest is executed. PolicyPostWebhook : Webhooks configured on a Policy to be triggered after a PrivacyRequest is executed. Database terms: Datasets - Resources at the database level. Datasets can have many Collections. Collections - A table, or a Collection of related data. Collections can have many Fields. Fields - Attributes on Collections.","title":"Fidesops terms"},{"location":"glossary/#fidesctl-terms","text":"See the fidesctl repo for more information, but here's some fidesctl terms that might be helpful in fidesops. Manifest : YAML files that describe different types of objects within Fides, with a high-level \"privacy as code\" language. Policy : Different from a fidesops Policy, this controls what kinds of data you are permitted to commit to source code. For example, you might create a fidesctl policy that says, I am not going to allow any System that takes in provided contact information and uses it for marketing purposes. Dataset : An annotation of a database schema, which describes the Collections in a database, the Fields, the Data Categories of those fields, and the relationships between relevant Collections. System : Systems represent the applications, services, integrations, and any software that processes data for a specific use case. Privacy Data Types: Data Category - What kind of data is it? For example, the Data Category user includes things like contact email and street address. Data Use - Why is it being used? For example, for advertising or to improve the system. Data Subject - Whose data is it? For example, a customer . Data Qualifier - How is the data being protected? For example, it might be aggregated .","title":"Fidesctl terms"},{"location":"license/","text":"1 2 3 Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. 1 2 3 4 5 6 7 8 To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at 1 http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"use_cases/","text":"Use Cases The world of privacy is changing quickly and so is your organization's technology stack. Fidesops can help you become compliant with data privacy regulation, as well as help to manage ongoing privacy operations for your company. Privacy Request Management Under various data privacy laws, like the General Data Protection Regulations (GDPR), California Consumer Protection Act (CCPA), or Brazil's LGPD, consumers have the right to request for you to delete or return their personal data to them within a desginated timeframe. Your organization is likely already receiving \"Privacy Requests\", which are also known as: Data Subject Requests (DSR) Data Subject Access Request (DSAR) Right to be forgotten (RTBF) Request to Delete Right to Access Request to Know Request to Opt-In or Opt-Out It's possible you may not know what these are until you're expected to fulfill a request like this. However, your customer support team and your legal and privacy team are probably very familiar with these requests because they typically come in through support channels via email. Generally, the team responsible for fulfilling these requests is a combination of product engineering, marketing, legal, and sales because your organization has customer data stored in so many locations. Fidesops helps to automate the execution of these privacy requests by 1) accepting and responding to privacy requests from an application of your choosing or fidesops' provided Privacy Center , 2) connecting directly to your datasets, and 3) retrieving, updating, and/or deleting data in those datasets. Data Inventory Because fidesops connects directly to your datasets, it is easy to maintain a record of where you're storing personally identifiable data and other potentially sensitive data types. Keeping this updated data inventory helps reduce risk for your organization by making it simple to provide a full auditable report of your data ecosystem. Targeted or Bulk Data Anonymization As machine learning models require more and more data, your organization may decide to remove certain sensitive data from a dataset to be used for analytics purposes. Fidesops allows you to create a custom policy to anonymize data for any use. For example, you can pseudonymize just the email address field with a consistent hash both within a database or between different databases using deterministic pseudonymization ; this way, the email address will have the same hashed value across datasets, which will maintain referential integrity for your analytics reports and dashboards.","title":"Use Cases"},{"location":"use_cases/#use-cases","text":"The world of privacy is changing quickly and so is your organization's technology stack. Fidesops can help you become compliant with data privacy regulation, as well as help to manage ongoing privacy operations for your company.","title":"Use Cases"},{"location":"use_cases/#privacy-request-management","text":"Under various data privacy laws, like the General Data Protection Regulations (GDPR), California Consumer Protection Act (CCPA), or Brazil's LGPD, consumers have the right to request for you to delete or return their personal data to them within a desginated timeframe. Your organization is likely already receiving \"Privacy Requests\", which are also known as: Data Subject Requests (DSR) Data Subject Access Request (DSAR) Right to be forgotten (RTBF) Request to Delete Right to Access Request to Know Request to Opt-In or Opt-Out It's possible you may not know what these are until you're expected to fulfill a request like this. However, your customer support team and your legal and privacy team are probably very familiar with these requests because they typically come in through support channels via email. Generally, the team responsible for fulfilling these requests is a combination of product engineering, marketing, legal, and sales because your organization has customer data stored in so many locations. Fidesops helps to automate the execution of these privacy requests by 1) accepting and responding to privacy requests from an application of your choosing or fidesops' provided Privacy Center , 2) connecting directly to your datasets, and 3) retrieving, updating, and/or deleting data in those datasets.","title":"Privacy Request Management"},{"location":"use_cases/#data-inventory","text":"Because fidesops connects directly to your datasets, it is easy to maintain a record of where you're storing personally identifiable data and other potentially sensitive data types. Keeping this updated data inventory helps reduce risk for your organization by making it simple to provide a full auditable report of your data ecosystem.","title":"Data Inventory"},{"location":"use_cases/#targeted-or-bulk-data-anonymization","text":"As machine learning models require more and more data, your organization may decide to remove certain sensitive data from a dataset to be used for analytics purposes. Fidesops allows you to create a custom policy to anonymize data for any use. For example, you can pseudonymize just the email address field with a consistent hash both within a database or between different databases using deterministic pseudonymization ; this way, the email address will have the same hashed value across datasets, which will maintain referential integrity for your analytics reports and dashboards.","title":"Targeted or Bulk Data Anonymization"},{"location":"api/","text":"API Reference You can view the live, interactive Swagger API docs for fidesops by visiting /docs on a running instance. This is a great way to experiment with the APIs using Swagger's built-in \"Try it out\" functionality. Additionally, you can download our fidesops Postman collection and follow instructions to set up on your machine . Below, we've embedded the latest release's API documentation as a living reference. These work largely the same, but since this documentation site isn't connected to a live instance, the \"Try it out\" and \"Authorize\" buttons won't work, sorry! All fidesops api routes will automatically match with and without a trailing slash / . So /api/v1/config and /api/v1/config/ are both valid API calls. Swagger API Docs const ui = SwaggerUIBundle({ url: 'openapi.json', dom_id: '#swagger-ui', }) /* If there is an anchor tag, reload it after the page loads to scroll to * that section, since the Swagger UI takes some time to render. */ if (location.hash) { setTimeout(function() { location.href = location.href }, 200); }","title":"API"},{"location":"api/#api-reference","text":"You can view the live, interactive Swagger API docs for fidesops by visiting /docs on a running instance. This is a great way to experiment with the APIs using Swagger's built-in \"Try it out\" functionality. Additionally, you can download our fidesops Postman collection and follow instructions to set up on your machine . Below, we've embedded the latest release's API documentation as a living reference. These work largely the same, but since this documentation site isn't connected to a live instance, the \"Try it out\" and \"Authorize\" buttons won't work, sorry! All fidesops api routes will automatically match with and without a trailing slash / . So /api/v1/config and /api/v1/config/ are both valid API calls.","title":"API Reference"},{"location":"api/#swagger-api-docs","text":"const ui = SwaggerUIBundle({ url: 'openapi.json', dom_id: '#swagger-ui', }) /* If there is an anchor tag, reload it after the page loads to scroll to * that section, since the Swagger UI takes some time to render. */ if (location.hash) { setTimeout(function() { location.href = location.href }, 200); }","title":"Swagger API Docs"},{"location":"community/code_of_conduct/","text":"Fides Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct that could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Fides core team at fides@ethyca.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"community/code_of_conduct/#fides-code-of-conduct","text":"","title":"Fides Code of Conduct"},{"location":"community/code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"community/code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct that could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"community/code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"community/code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"community/code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Fides core team at fides@ethyca.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"community/code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"community/github/","text":"Community The Fides project welcomes issues, contributions and discussion from all users, regardless of background or experience level. In order to create a positive and welcoming environment, all interactions are governed by the Fides Code of Conduct . GitHub We have a public GitHub Repo for development and collaboration. GitHub Guidelines Whether it's giving us feedback, raising a question, or showing your Fides-related work, we are looking forward to hearing from you. The Fides community is vibrant because of the quality of its members and the discussions they bring. To keep the workspace inviting and helpful for everyone, there are a few guidelines that we ask all members to follow. Rule 1: Assume Positive Intent Being nice is the most important pillar of the Fides community. We are considerate to each other's effort and time. It's also easy to misinterpret people through Slack, so we make an extra effort to chat in a positive tone. We assume that you are here to learn and exchange ideas, and we ask that you contribute to making a welcoming community. If someone is helping you, be mindful of the effort they are putting in. While we are always happy to help users, we can not help users with step-by-step debugging. Use your professional judgment in discerning whether requests are unreasonable. The Fides team always tries to listen to the community. Please be understanding if your issue or feature request is not deemed an immediate priority. Rule 2: Use threads for larger messages Because of the size of our community and frequency of posts, it's easy for large messages to drown out smaller messages. Using threads helps people see more messages on their screen. Larger code blocks should be posted in threads. Rule 3: Avoid posting sensitive information Community members sometimes need to post code snippets as they ask for help. Be sure to remove sensitive information from posts to the public channels. If your Fides account information is needed to help you, we will ask you to direct message such information. Be cautious of anyone asking for information through direct messages. Rule 4: Write high quality questions The Fides community is here to support you. That said, it is significantly easier to answer well-researched and clearly-written questions. Even adding potentially relevant links to a post helps tremendously. Informative Slack threads are archived by our resident bot Marvin. Having well-written threads helps future users encountering the same problem. Oftentimes your question may have been answered somewhere else; some good resources to start looking before asking a question: Fides Documentation GitHub Issues StackOverflow Rule 5: Don't abuse tagging users Requests for help will be seen by the Fides team, and will be directed to the appropriate person. Tagging individual users is highly discouraged unless it is in the context of a conversation thread. Rule 6: Avoid using DMs to ask for help Fides employees should not be sent questions in DMs unless we specifically ask you to send us private information. There are times when it makes sense to directly message another community member experiencing a similar issue, or working with similar technologies. Just be aware that some people may not want to be messaged. It also helps other people if you post your question publicly. Similar to above, informative Slack threads are archived. Having conversations in public channels drives better quality discussions that can be referenced in the future. Rule 7: Don't advertise material unrelated to Fides Our community is in the channel to learn more about Fides. Showing us Fides-related stuff that you're working on is highly encouraged. Advertising products and events unrelated to Fides will be removed.","title":"GitHub"},{"location":"community/github/#community","text":"The Fides project welcomes issues, contributions and discussion from all users, regardless of background or experience level. In order to create a positive and welcoming environment, all interactions are governed by the Fides Code of Conduct .","title":"Community"},{"location":"community/github/#github","text":"We have a public GitHub Repo for development and collaboration.","title":"GitHub"},{"location":"community/github/#github-guidelines","text":"Whether it's giving us feedback, raising a question, or showing your Fides-related work, we are looking forward to hearing from you. The Fides community is vibrant because of the quality of its members and the discussions they bring. To keep the workspace inviting and helpful for everyone, there are a few guidelines that we ask all members to follow.","title":"GitHub Guidelines"},{"location":"community/github/#rule-1-assume-positive-intent","text":"Being nice is the most important pillar of the Fides community. We are considerate to each other's effort and time. It's also easy to misinterpret people through Slack, so we make an extra effort to chat in a positive tone. We assume that you are here to learn and exchange ideas, and we ask that you contribute to making a welcoming community. If someone is helping you, be mindful of the effort they are putting in. While we are always happy to help users, we can not help users with step-by-step debugging. Use your professional judgment in discerning whether requests are unreasonable. The Fides team always tries to listen to the community. Please be understanding if your issue or feature request is not deemed an immediate priority.","title":"Rule 1: Assume Positive Intent"},{"location":"community/github/#rule-2-use-threads-for-larger-messages","text":"Because of the size of our community and frequency of posts, it's easy for large messages to drown out smaller messages. Using threads helps people see more messages on their screen. Larger code blocks should be posted in threads.","title":"Rule 2: Use threads for larger messages"},{"location":"community/github/#rule-3-avoid-posting-sensitive-information","text":"Community members sometimes need to post code snippets as they ask for help. Be sure to remove sensitive information from posts to the public channels. If your Fides account information is needed to help you, we will ask you to direct message such information. Be cautious of anyone asking for information through direct messages.","title":"Rule 3: Avoid posting sensitive information"},{"location":"community/github/#rule-4-write-high-quality-questions","text":"The Fides community is here to support you. That said, it is significantly easier to answer well-researched and clearly-written questions. Even adding potentially relevant links to a post helps tremendously. Informative Slack threads are archived by our resident bot Marvin. Having well-written threads helps future users encountering the same problem. Oftentimes your question may have been answered somewhere else; some good resources to start looking before asking a question: Fides Documentation GitHub Issues StackOverflow","title":"Rule 4: Write high quality questions"},{"location":"community/github/#rule-5-dont-abuse-tagging-users","text":"Requests for help will be seen by the Fides team, and will be directed to the appropriate person. Tagging individual users is highly discouraged unless it is in the context of a conversation thread.","title":"Rule 5: Don't abuse tagging users"},{"location":"community/github/#rule-6-avoid-using-dms-to-ask-for-help","text":"Fides employees should not be sent questions in DMs unless we specifically ask you to send us private information. There are times when it makes sense to directly message another community member experiencing a similar issue, or working with similar technologies. Just be aware that some people may not want to be messaged. It also helps other people if you post your question publicly. Similar to above, informative Slack threads are archived. Having conversations in public channels drives better quality discussions that can be referenced in the future.","title":"Rule 6: Avoid using DMs to ask for help"},{"location":"community/github/#rule-7-dont-advertise-material-unrelated-to-fides","text":"Our community is in the channel to learn more about Fides. Showing us Fides-related stuff that you're working on is highly encouraged. Advertising products and events unrelated to Fides will be removed.","title":"Rule 7: Don't advertise material unrelated to Fides"},{"location":"development/code_style/","text":"Code Style Black formatting Fides's code is formatted using the black style. This style is checked in a CI step, and merges to master are prevented if code does not conform. To apply black to your code, run black from the root fidesops directory: 1 2 cd fidesops black . A number of extensions are available for popular editors that will automatically apply black to your code. Pylint Fides's code is linted using pylint . Linter checks run as part of a CI step and merges to master are prevented if code does not conform. To apply pylint to your code, run pylint from the root fidesops directory: 1 2 cd fidesops pylint src Mypy typing Fides's code is statically-typed using mypy . Type checking is validated as a CI step, and merges to master are prevented if code does not pass type checks. As a general rule, mypy typing requires all function arguments and return values to be annotated. 1 2 cd fidesops mypy src","title":"Code Style"},{"location":"development/code_style/#code-style","text":"","title":"Code Style"},{"location":"development/code_style/#black-formatting","text":"Fides's code is formatted using the black style. This style is checked in a CI step, and merges to master are prevented if code does not conform. To apply black to your code, run black from the root fidesops directory: 1 2 cd fidesops black . A number of extensions are available for popular editors that will automatically apply black to your code.","title":"Black formatting"},{"location":"development/code_style/#pylint","text":"Fides's code is linted using pylint . Linter checks run as part of a CI step and merges to master are prevented if code does not conform. To apply pylint to your code, run pylint from the root fidesops directory: 1 2 cd fidesops pylint src","title":"Pylint"},{"location":"development/code_style/#mypy-typing","text":"Fides's code is statically-typed using mypy . Type checking is validated as a CI step, and merges to master are prevented if code does not pass type checks. As a general rule, mypy typing requires all function arguments and return values to be annotated. 1 2 cd fidesops mypy src","title":"Mypy typing"},{"location":"development/contributing_details/","text":"Contributing Details API Endpoints Postman API Collection Our fidesops Postman Collection can be used to test fidesops endpoints. Follow our Using Postman guide to learn more about the how to use the collection. API URLs We define API URLs for specific API versions as constants within fidesops.ops.api.v1.urn_registry (where v1 can be substituted for that particular API version), then import those URLs into their specific API views. Since we are on the first version, there is no clear precedent set for overriding URLs between versions yet. The most likely change is that we'll override the APIRouter class instantiation with a different base path (ie. /api/v2 instead of /api/v1 ). For example: 1 2 PRIVACY_REQUEST = \"/privacy-request\" PRIVACY_REQUEST_DETAIL = \"/privacy-request/{privacy_request_id}\" would both resolve as /api/v1/privacy-request and /api/v1/privacy-request/{privacy_request_id} respectively. Database and Models The ORM -- SQLAlchemy SQLAlchemy is an Object Relational Mapper, allowing us to avoid writing direct database queries within our codebase, and access the database via Python code instead. The ORM provides an additional configuration layer allowing user-defined Python classes to be mapped to database tables and other constructs, as well as an object persistence mechanism known as the Session . Some common uses cases are listed below, for a more comprehensive guide see: https://docs.sqlalchemy.org/en/14/tutorial/index.html Adding models Database tables are defined with model classes. Model files should live in src/app/models/ . Individual model classes must inherit from our custom base class at app.db.base_class.Base to ensure uniformity within the database. Multiple models per file are encouraged so long as they fit the same logical delineation within the project. An example model declaration is added below. For a comprehensive guide see: https://docs.sqlalchemy.org/en/14/orm/mapping_styles.html#declarative-mapping You should also import your model in src/fidesops/db/base.py so it is visible for alembic. 1 2 3 4 5 6 7 class Book(Base): __tablename__ = 'book' id = Column(Integer, primary_key=True) name = Column(String, index=True) page_count = Column(Integer, nullable=True) author_id = Column(Integer, ForeignKey(\"author.id\"), nullable=False) When models are added to the project, we must then add them to the database in a recordable and repeatable fashion using migrations. Using the database via models Once you've added database tables via project models, you're ready to read, write and update them via Python code. Some examples of common use cases here are listed below. Official documentation is here: https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query . Import our application's database session: from fidesops.ops.db.session import get_db_session Instantiate the database interaction object: 1 2 SessionLocal = get_db_session(config) db = SessionLocal() Create a new row in a table: 1 2 3 4 5 6 7 8 9 db_obj = User( email=\"admin@fidesops.app\", full_name=\"Fidesops Admin\", is_superuser=True, is_active=True, ) db.add(db_obj) db.commit() db.refresh(db_obj) Fetch all objects in a table: users = db.query(User).all() Fetch all objects in a table that meet some criteria: active_users = db.query(User).filter(User.is_active == True) Get a specific row in a table: user = db.query(User).get(User.email == \"admin@fidesops.app\") Update a specific row in a table: 1 2 3 4 user.email = \"updated@fidesops.app\" db.add(user) db.commit() db.refresh() Connecting to the database When you run nox -s dev , the database will be spun up in a Docker container with port 5432 exposed on localhost. You can connect to it using the credentials found in .fidesops.toml , e.g. Hostname: localhost Port: 5432 Username: see database.user in .fidesops.toml Password: see database.password in .fidesops.toml Alembic migrations Some common Alembic commands are listed below. For a comprehensive guide see: https://alembic.sqlalchemy.org/en/latest/tutorial.html . The commands will need to be run inside a shell on your Docker containers, which can be opened with nox -s dev -- shell . In the /src/fidesops directory: Migrate your database to the latest state: alembic upgrade head Get revision id of previous migration: alembic current Automatically generate a new migration: alembic revision --autogenerate -m \"<a message describing your changes>\" Create a new migration file to manually fill out: alembic revision -m \"<a message describing your changes>\" Migrate your database to a specific state alembic upgrade <revision-id> or alembic downgrade <revision-id> , (or if you want to be smart alembic upgrade <revision-id> || alembic downgrade <revision-id> is handy when you don't know whether the target revision is an upgrade or downgrade) NB. You can find the revision-id inside each migration file in alembic/versions/ on line 3 next to Revision ID: ... When working on a PR with a migration, ensure that down_revision in the generated migration file correctly references the previous migration before submitting/merging the PR. Exception Handling Our preference for exception handling is by overriding the nearest sensible error, for example: 1 2 3 4 5 6 class SomeException(ValueError): \"a docstring\" def some_method(): raise SomeException(\"a message\") General debugging -- pdb The project uses pdb for debugging as a dev-requirement . You can set breakpoints with pdb in much the same way you'd set them using debugger in Javascript. Insert import pdb; pdb.set_trace() into the line where you want the breakpoint to set, then run your Python code. Docker Occasionally when developing you'll run into issues where it's beneficial to remove all existing Docker instances in order to recreate them based on some updated spec. Some commands to do this are below: Stop all running containers: docker-compose down Delete all local containers: docker rm -f $(docker ps -a -q) Delete all local Docker volumes: docker volume rm $(docker volume ls -q) Remove temp. files, installed dependencies, all local Docker containers and all local Docker volumes: nox -s clean Delete all stopped containers, all networks not used by a container, all dangling images, and all build cache: docker system prune Recreate the project: nox -s \"build(dev)\"","title":"Contributing Details"},{"location":"development/contributing_details/#contributing-details","text":"","title":"Contributing Details"},{"location":"development/contributing_details/#api-endpoints","text":"","title":"API Endpoints"},{"location":"development/contributing_details/#postman-api-collection","text":"Our fidesops Postman Collection can be used to test fidesops endpoints. Follow our Using Postman guide to learn more about the how to use the collection.","title":"Postman API Collection"},{"location":"development/contributing_details/#api-urls","text":"We define API URLs for specific API versions as constants within fidesops.ops.api.v1.urn_registry (where v1 can be substituted for that particular API version), then import those URLs into their specific API views. Since we are on the first version, there is no clear precedent set for overriding URLs between versions yet. The most likely change is that we'll override the APIRouter class instantiation with a different base path (ie. /api/v2 instead of /api/v1 ). For example: 1 2 PRIVACY_REQUEST = \"/privacy-request\" PRIVACY_REQUEST_DETAIL = \"/privacy-request/{privacy_request_id}\" would both resolve as /api/v1/privacy-request and /api/v1/privacy-request/{privacy_request_id} respectively.","title":"API URLs"},{"location":"development/contributing_details/#database-and-models","text":"","title":"Database and Models"},{"location":"development/contributing_details/#the-orm-sqlalchemy","text":"SQLAlchemy is an Object Relational Mapper, allowing us to avoid writing direct database queries within our codebase, and access the database via Python code instead. The ORM provides an additional configuration layer allowing user-defined Python classes to be mapped to database tables and other constructs, as well as an object persistence mechanism known as the Session . Some common uses cases are listed below, for a more comprehensive guide see: https://docs.sqlalchemy.org/en/14/tutorial/index.html","title":"The ORM -- SQLAlchemy"},{"location":"development/contributing_details/#adding-models","text":"Database tables are defined with model classes. Model files should live in src/app/models/ . Individual model classes must inherit from our custom base class at app.db.base_class.Base to ensure uniformity within the database. Multiple models per file are encouraged so long as they fit the same logical delineation within the project. An example model declaration is added below. For a comprehensive guide see: https://docs.sqlalchemy.org/en/14/orm/mapping_styles.html#declarative-mapping You should also import your model in src/fidesops/db/base.py so it is visible for alembic. 1 2 3 4 5 6 7 class Book(Base): __tablename__ = 'book' id = Column(Integer, primary_key=True) name = Column(String, index=True) page_count = Column(Integer, nullable=True) author_id = Column(Integer, ForeignKey(\"author.id\"), nullable=False) When models are added to the project, we must then add them to the database in a recordable and repeatable fashion using migrations.","title":"Adding models"},{"location":"development/contributing_details/#using-the-database-via-models","text":"Once you've added database tables via project models, you're ready to read, write and update them via Python code. Some examples of common use cases here are listed below. Official documentation is here: https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query . Import our application's database session: from fidesops.ops.db.session import get_db_session Instantiate the database interaction object: 1 2 SessionLocal = get_db_session(config) db = SessionLocal() Create a new row in a table: 1 2 3 4 5 6 7 8 9 db_obj = User( email=\"admin@fidesops.app\", full_name=\"Fidesops Admin\", is_superuser=True, is_active=True, ) db.add(db_obj) db.commit() db.refresh(db_obj) Fetch all objects in a table: users = db.query(User).all() Fetch all objects in a table that meet some criteria: active_users = db.query(User).filter(User.is_active == True) Get a specific row in a table: user = db.query(User).get(User.email == \"admin@fidesops.app\") Update a specific row in a table: 1 2 3 4 user.email = \"updated@fidesops.app\" db.add(user) db.commit() db.refresh()","title":"Using the database via models"},{"location":"development/contributing_details/#connecting-to-the-database","text":"When you run nox -s dev , the database will be spun up in a Docker container with port 5432 exposed on localhost. You can connect to it using the credentials found in .fidesops.toml , e.g. Hostname: localhost Port: 5432 Username: see database.user in .fidesops.toml Password: see database.password in .fidesops.toml","title":"Connecting to the database"},{"location":"development/contributing_details/#alembic-migrations","text":"Some common Alembic commands are listed below. For a comprehensive guide see: https://alembic.sqlalchemy.org/en/latest/tutorial.html . The commands will need to be run inside a shell on your Docker containers, which can be opened with nox -s dev -- shell . In the /src/fidesops directory: Migrate your database to the latest state: alembic upgrade head Get revision id of previous migration: alembic current Automatically generate a new migration: alembic revision --autogenerate -m \"<a message describing your changes>\" Create a new migration file to manually fill out: alembic revision -m \"<a message describing your changes>\" Migrate your database to a specific state alembic upgrade <revision-id> or alembic downgrade <revision-id> , (or if you want to be smart alembic upgrade <revision-id> || alembic downgrade <revision-id> is handy when you don't know whether the target revision is an upgrade or downgrade) NB. You can find the revision-id inside each migration file in alembic/versions/ on line 3 next to Revision ID: ... When working on a PR with a migration, ensure that down_revision in the generated migration file correctly references the previous migration before submitting/merging the PR.","title":"Alembic migrations"},{"location":"development/contributing_details/#exception-handling","text":"Our preference for exception handling is by overriding the nearest sensible error, for example: 1 2 3 4 5 6 class SomeException(ValueError): \"a docstring\" def some_method(): raise SomeException(\"a message\")","title":"Exception Handling"},{"location":"development/contributing_details/#general-debugging-pdb","text":"The project uses pdb for debugging as a dev-requirement . You can set breakpoints with pdb in much the same way you'd set them using debugger in Javascript. Insert import pdb; pdb.set_trace() into the line where you want the breakpoint to set, then run your Python code.","title":"General debugging -- pdb"},{"location":"development/contributing_details/#docker","text":"Occasionally when developing you'll run into issues where it's beneficial to remove all existing Docker instances in order to recreate them based on some updated spec. Some commands to do this are below: Stop all running containers: docker-compose down Delete all local containers: docker rm -f $(docker ps -a -q) Delete all local Docker volumes: docker volume rm $(docker volume ls -q) Remove temp. files, installed dependencies, all local Docker containers and all local Docker volumes: nox -s clean Delete all stopped containers, all networks not used by a container, all dangling images, and all build cache: docker system prune Recreate the project: nox -s \"build(dev)\"","title":"Docker"},{"location":"development/documentation/","text":"Documentation Documentation is incredibly important to Fides, both for explaining its concepts to general audiences and describing its usage to developers. Concepts Fides includes a great deal of \"concept\" documentation, which covers features, tutorials, guides, and examples separately from the auto-generated API reference. This page is part of the concept documentation for development! To write concept docs, add Markdown files to the docs/fidesops/docs/ directory (or one of its subdirectories). To ensure that your page is displayed in the navigation, edit mkdocs.yml to include a reference to it. Semantics Capitalization Concepts that refer to proper nouns or are trademarked should always be capitalized, including \"Fides\". Fides tools, such as \"fidesops\" and \"fidesctl\" should always be lowercase. Other Fides terms, like \"Data Category\" or \"System\", should also be capitalized to be clear about the fact that a Fides resource is being referenced. When a System is applied, it is either created or updated through the FidesAPI. The System model requires a field called fides_key . Previewing docs locally Documentation (including both concepts and API references) is built and deployed with every merge to Fides's master branch. If you're using VS Code Dev Containers, the docs will automatically be available at localhost:8000 , otherwise you'll need to run the following command: 1 nox -s docs_serve You'll see a status update as the docs build, and then an announcement that they are available on http://127.0.0.1:8000 .","title":"Documentation"},{"location":"development/documentation/#documentation","text":"Documentation is incredibly important to Fides, both for explaining its concepts to general audiences and describing its usage to developers.","title":"Documentation"},{"location":"development/documentation/#concepts","text":"Fides includes a great deal of \"concept\" documentation, which covers features, tutorials, guides, and examples separately from the auto-generated API reference. This page is part of the concept documentation for development! To write concept docs, add Markdown files to the docs/fidesops/docs/ directory (or one of its subdirectories). To ensure that your page is displayed in the navigation, edit mkdocs.yml to include a reference to it.","title":"Concepts"},{"location":"development/documentation/#semantics","text":"","title":"Semantics"},{"location":"development/documentation/#capitalization","text":"Concepts that refer to proper nouns or are trademarked should always be capitalized, including \"Fides\". Fides tools, such as \"fidesops\" and \"fidesctl\" should always be lowercase. Other Fides terms, like \"Data Category\" or \"System\", should also be capitalized to be clear about the fact that a Fides resource is being referenced. When a System is applied, it is either created or updated through the FidesAPI. The System model requires a field called fides_key .","title":"Capitalization"},{"location":"development/documentation/#previewing-docs-locally","text":"Documentation (including both concepts and API references) is built and deployed with every merge to Fides's master branch. If you're using VS Code Dev Containers, the docs will automatically be available at localhost:8000 , otherwise you'll need to run the following command: 1 nox -s docs_serve You'll see a status update as the docs build, and then an announcement that they are available on http://127.0.0.1:8000 .","title":"Previewing docs locally"},{"location":"development/fideslog/","text":"Fideslog Analytics Fidesops includes an implementation of fideslog to provide Ethyca with an understanding of user interactions with fides tooling. All collected analytics are anonymized, and only used in either product roadmap determination, or as insight into product adoption. Information collected by fideslog is received via HTTPs request, stored in a secure database, and never shared with third parties unless required by law. More information on use, implementation, and configuration can be found in the fideslog repository . Collected Data Fideslog collects information on instances of fidesops by recording internal events. Using fidesops may result in sending any or all of the following analytics data to Ethyca: Parameter Description docker If fidesops is run in a docker container. event The type of analytics event - currently, either a server start or endpoint call . event_created The time of the event. endpoint The endpoint accessed. status_code The status result of the request. error Error information, if any. Disabling Fideslog To opt out of analytics, set either the following fidesops environment variable or .toml configuration variable to True . Variable Default Use analytics_opt_out False Include in your fidesops.toml file. FIDESOPS__USER__ANALYTICS_OPT_OUT False Include in your environment variables. For more information, see the fidesops configuration guide .","title":"Fideslog Analytics"},{"location":"development/fideslog/#fideslog-analytics","text":"Fidesops includes an implementation of fideslog to provide Ethyca with an understanding of user interactions with fides tooling. All collected analytics are anonymized, and only used in either product roadmap determination, or as insight into product adoption. Information collected by fideslog is received via HTTPs request, stored in a secure database, and never shared with third parties unless required by law. More information on use, implementation, and configuration can be found in the fideslog repository .","title":"Fideslog Analytics"},{"location":"development/fideslog/#collected-data","text":"Fideslog collects information on instances of fidesops by recording internal events. Using fidesops may result in sending any or all of the following analytics data to Ethyca: Parameter Description docker If fidesops is run in a docker container. event The type of analytics event - currently, either a server start or endpoint call . event_created The time of the event. endpoint The endpoint accessed. status_code The status result of the request. error Error information, if any.","title":"Collected Data"},{"location":"development/fideslog/#disabling-fideslog","text":"To opt out of analytics, set either the following fidesops environment variable or .toml configuration variable to True . Variable Default Use analytics_opt_out False Include in your fidesops.toml file. FIDESOPS__USER__ANALYTICS_OPT_OUT False Include in your environment variables. For more information, see the fidesops configuration guide .","title":"Disabling Fideslog"},{"location":"development/jetbrains_debugging/","text":"Debugging fidesops in IntelliJ IDEA Ultimate This guide will show how to use the IntelliJ debugger with fidesops running in Docker. The setup for PyCharm Professional should be very similar. Prerequisites Intellij IDEA Ultimate or PyCharm Professional Docker plugin Python plugin (this is needed for Intellij) Docker Desktop Fidesops Setup Connect to Docker daemon This step will allow the IDE to connect to Docker Desktop. Go to: Settings/Preferences -> Docker -> + Select Docker for \"your operating system\" See the screenshot below: Configure Python Remote Interpreter Define a Docker-based remote interpreter. Go to: File -> Project Structure... -> Platform Settings -> SDKs -> + Set Server to Docker Set Configuration files to .docker-compose.yml Set Python interpreter path to python After clicking OK the Remote Python Docker Compose should be listed as an SDK. See screenshots below: Run/Debug Configuration Set up a Run/Debug Configuration so that breakpoints can be hit in the f sourcecode. Go to: Run/Debug Configurations -> + -> Python To debug fidesops, debug the <path on your machine>/src/fidesops/main.py script Make sure to select Use specified interpreter set the Remote Python Docker Compose (created in the previous section) Add FIDES__CONFIG_PATH=/fidesops to Environment variables See screenshot below: Hit a Breakpoint Now the IDE is ready to debug the source code. Click the debug button for main (setup in the previous section) . Try firing a http request to fidesops from Postman or Curl and hit a break point. There is a postman collection in this repo: docs/fidesops/docs/postman/Fidesops.postman_collection.json Screenshot of hit breakpoint below: Links The information is this guide is largely based on these docs https://www.jetbrains.com/help/pycharm/using-docker-as-a-remote-interpreter.html https://www.jetbrains.com/help/idea/configuring-local-python-interpreters.html","title":"Debugging fidesops in IntelliJ IDEA Ultimate"},{"location":"development/jetbrains_debugging/#debugging-fidesops-in-intellij-idea-ultimate","text":"This guide will show how to use the IntelliJ debugger with fidesops running in Docker. The setup for PyCharm Professional should be very similar.","title":"Debugging fidesops in IntelliJ IDEA Ultimate"},{"location":"development/jetbrains_debugging/#prerequisites","text":"Intellij IDEA Ultimate or PyCharm Professional Docker plugin Python plugin (this is needed for Intellij) Docker Desktop Fidesops","title":"Prerequisites"},{"location":"development/jetbrains_debugging/#setup","text":"","title":"Setup"},{"location":"development/jetbrains_debugging/#connect-to-docker-daemon","text":"This step will allow the IDE to connect to Docker Desktop. Go to: Settings/Preferences -> Docker -> + Select Docker for \"your operating system\" See the screenshot below:","title":"Connect to Docker daemon"},{"location":"development/jetbrains_debugging/#configure-python-remote-interpreter","text":"Define a Docker-based remote interpreter. Go to: File -> Project Structure... -> Platform Settings -> SDKs -> + Set Server to Docker Set Configuration files to .docker-compose.yml Set Python interpreter path to python After clicking OK the Remote Python Docker Compose should be listed as an SDK. See screenshots below:","title":"Configure Python Remote Interpreter"},{"location":"development/jetbrains_debugging/#rundebug-configuration","text":"Set up a Run/Debug Configuration so that breakpoints can be hit in the f sourcecode. Go to: Run/Debug Configurations -> + -> Python To debug fidesops, debug the <path on your machine>/src/fidesops/main.py script Make sure to select Use specified interpreter set the Remote Python Docker Compose (created in the previous section) Add FIDES__CONFIG_PATH=/fidesops to Environment variables See screenshot below:","title":"Run/Debug Configuration"},{"location":"development/jetbrains_debugging/#hit-a-breakpoint","text":"Now the IDE is ready to debug the source code. Click the debug button for main (setup in the previous section) . Try firing a http request to fidesops from Postman or Curl and hit a break point. There is a postman collection in this repo: docs/fidesops/docs/postman/Fidesops.postman_collection.json Screenshot of hit breakpoint below:","title":"Hit a Breakpoint"},{"location":"development/jetbrains_debugging/#links","text":"The information is this guide is largely based on these docs https://www.jetbrains.com/help/pycharm/using-docker-as-a-remote-interpreter.html https://www.jetbrains.com/help/idea/configuring-local-python-interpreters.html","title":"Links"},{"location":"development/overview/","text":"Development Overview Thanks for contributing to fidesops! This section of the docs is designed to help you become familiar with how we work, the standards we apply, and how to ensure your contribution is successful. If you're stuck, don't be shy about asking for help on GitHub . Getting started with fidesops in Docker The recommended way to run fidesops is to launch it with Docker and Docker Compose. Make commands wrap docker-compose commands to give you different functionality. System Requirements Install Docker: https://docs.docker.com/desktop/#download-and-install Create a fork of fidesops Clone your fork git clone https://github.com/<your-fork-location>/fidesops.git cd fidesops Available nox commands An up-to-date list of build commands is available by running nox from within the project directory. Issues MSSQL: Known issues around connecting to MSSQL exist today for Apple M1 users. M1 users that wish to install pyodbc locally, please reference the workaround here . Package not found: When running nox -s dev , if you get a importlib.metadata.PackageNotFoundError: fidesops , do nox -s dev -- shell , and then run pip install -e . . Verify fidesops is installed with pip list . Write your code See the contributing details guide to get familiar with writing and testing API endpoints, database models, and more. We want to help you ensure your code plays nicely with the rest of the fidesops ecosystem. Many projects describe code style and documentation as a suggestion; in fidesops it's a CI-checked requirement. To learn how to style your code, see the style guide . To learn how to document your code, see the docs guide . To learn how to test your code, see the tests guide . To learn what format your PR should follow, make sure to follow the pull request guidelines . Submit your code In order to submit code to fidesops, please: Fork the fidesops repository Add the original as a remote (I'm naming it upstream ), to keep your fork in sync 1 git remote add upstream https://github.com/ethyca/fidesops.git Create a new branch on your fork bash git checkout main git fetch upstream git merge upstream/main git push origin main git checkout -b my-new-branch git push origin my-new-branch Open a Pull Request once your work is ready for review Submit the pull request from your repo. Pull requests should be submitted with a clear description of the issue being handled, including links to any external specifications or Github issues. PRs should not be merged by the person submitting them, except in rare and urgent circumstances. Once automated tests have passed, a maintainer will review your PR and provide feedback on any changes it requires to be approved. Once approved, your PR will be merged into fidesops. Congratulations You're a fidesops contributor - welcome to the team! \ud83c\udf89","title":"Overview"},{"location":"development/overview/#development-overview","text":"Thanks for contributing to fidesops! This section of the docs is designed to help you become familiar with how we work, the standards we apply, and how to ensure your contribution is successful. If you're stuck, don't be shy about asking for help on GitHub .","title":"Development Overview"},{"location":"development/overview/#getting-started-with-fidesops-in-docker","text":"The recommended way to run fidesops is to launch it with Docker and Docker Compose. Make commands wrap docker-compose commands to give you different functionality.","title":"Getting started with fidesops in Docker"},{"location":"development/overview/#system-requirements","text":"Install Docker: https://docs.docker.com/desktop/#download-and-install Create a fork of fidesops Clone your fork git clone https://github.com/<your-fork-location>/fidesops.git cd fidesops","title":"System Requirements"},{"location":"development/overview/#available-nox-commands","text":"An up-to-date list of build commands is available by running nox from within the project directory.","title":"Available nox commands"},{"location":"development/overview/#issues","text":"MSSQL: Known issues around connecting to MSSQL exist today for Apple M1 users. M1 users that wish to install pyodbc locally, please reference the workaround here . Package not found: When running nox -s dev , if you get a importlib.metadata.PackageNotFoundError: fidesops , do nox -s dev -- shell , and then run pip install -e . . Verify fidesops is installed with pip list .","title":"Issues"},{"location":"development/overview/#write-your-code","text":"See the contributing details guide to get familiar with writing and testing API endpoints, database models, and more. We want to help you ensure your code plays nicely with the rest of the fidesops ecosystem. Many projects describe code style and documentation as a suggestion; in fidesops it's a CI-checked requirement. To learn how to style your code, see the style guide . To learn how to document your code, see the docs guide . To learn how to test your code, see the tests guide . To learn what format your PR should follow, make sure to follow the pull request guidelines .","title":"Write your code"},{"location":"development/overview/#submit-your-code","text":"In order to submit code to fidesops, please: Fork the fidesops repository Add the original as a remote (I'm naming it upstream ), to keep your fork in sync 1 git remote add upstream https://github.com/ethyca/fidesops.git Create a new branch on your fork bash git checkout main git fetch upstream git merge upstream/main git push origin main git checkout -b my-new-branch git push origin my-new-branch Open a Pull Request once your work is ready for review Submit the pull request from your repo. Pull requests should be submitted with a clear description of the issue being handled, including links to any external specifications or Github issues. PRs should not be merged by the person submitting them, except in rare and urgent circumstances. Once automated tests have passed, a maintainer will review your PR and provide feedback on any changes it requires to be approved. Once approved, your PR will be merged into fidesops.","title":"Submit your code"},{"location":"development/overview/#congratulations","text":"You're a fidesops contributor - welcome to the team! \ud83c\udf89","title":"Congratulations"},{"location":"development/pull_requests/","text":"Pull Requests Pull Requests are the primary unit of work within the Fides project. All code changes are expected to be submitted via a PR, and as such here are a few requirements for submitting PRs: Completely fill out the provided pull request template If you're unsure about a potential feature implementation or there is anything else that needs discussing, feel free to ask for an early review/feedback in the comments of the PR. Make sure that all checks are passing and all boxes have been checked before passing it off to a reviewer for a final approval. PR reviews require other people to spend their time, so please be courteous and double-check your work before passing it to a reviewer. If there is a bug in a PR, fix it within that PR, do not create another PR to fix a bug in a separate PR.","title":"Pull Requests"},{"location":"development/pull_requests/#pull-requests","text":"Pull Requests are the primary unit of work within the Fides project. All code changes are expected to be submitted via a PR, and as such here are a few requirements for submitting PRs: Completely fill out the provided pull request template If you're unsure about a potential feature implementation or there is anything else that needs discussing, feel free to ask for an early review/feedback in the comments of the PR. Make sure that all checks are passing and all boxes have been checked before passing it off to a reviewer for a final approval. PR reviews require other people to spend their time, so please be courteous and double-check your work before passing it to a reviewer. If there is a bug in a PR, fix it within that PR, do not create another PR to fix a bug in a separate PR.","title":"Pull Requests"},{"location":"development/release_checklist/","text":"Release Checklist Documentation [ ] Quickstart verified working and up-to-date [ ] Tutorial verified working and up-to-date [ ] Fidesdemo verified working and up-to-date [ ] New/updated API endpoints described in the Guides [ ] New/updated API endpoints included in the Postman collections [ ] New tables/columns added to database diagram [ ] If appropriate, confirm no regressions in core UI flows for the Admin UI [ ] If appropriate, confirm no regressions in core UI flows for the Privacy Centre","title":"Release Checklist"},{"location":"development/release_checklist/#release-checklist","text":"","title":"Release Checklist"},{"location":"development/release_checklist/#documentation","text":"[ ] Quickstart verified working and up-to-date [ ] Tutorial verified working and up-to-date [ ] Fidesdemo verified working and up-to-date [ ] New/updated API endpoints described in the Guides [ ] New/updated API endpoints included in the Postman collections [ ] New tables/columns added to database diagram [ ] If appropriate, confirm no regressions in core UI flows for the Admin UI [ ] If appropriate, confirm no regressions in core UI flows for the Privacy Centre","title":"Documentation"},{"location":"development/releases/","text":"Releases Fides uses semantic versioning. Each release version has a corresponding GitHub Project assigned to it. Issues are then assigned to them as a way to determine what new features/bug fixes will be included in each release. When a release project is complete, a new version is cut using GitHub's release page here . This will trigger a GitHub Action that pushes the new version to PyPi. Hotfixes are an exception to this and can be added and pushed mid-release as needed.","title":"Releases"},{"location":"development/releases/#releases","text":"Fides uses semantic versioning. Each release version has a corresponding GitHub Project assigned to it. Issues are then assigned to them as a way to determine what new features/bug fixes will be included in each release. When a release project is complete, a new version is cut using GitHub's release page here . This will trigger a GitHub Action that pushes the new version to PyPi. Hotfixes are an exception to this and can be added and pushed mid-release as needed.","title":"Releases"},{"location":"development/testing/","text":"Testing Fides loves tests! There are a few important reasons to write tests: Make sure your code works when it's supposed to Tests ensure that your code does the thing you intend it to do. If you have a function that adds two numbers, you'll want to test that it does, in fact, return their sum. If behavior depends on a configuration setting, ensure that changing that setting changes the behavior. In short, if you wrote a line of code, you should test that line works as expected. Make sure your code doesn't work when it's not supposed to It may seem silly, but another important reason to write tests is to ensure that your code behaves as expected even when it's broken . This is especially important for a project like Fides, which is focused on helping engineers when something unexpected happens to their code. For example, you could write tests about what you expect to happen if your function is called with incorrect (or no) arguments, or to ensure that any errors are properly trapped and handled. Tests are documentation Ultimately, your tests are the best documentation for your code. Another developer should be able to look at your tests and understand what your code does, how to invoke it, and what edge cases it contains. Therefore, try to write short, self-explanatory tests with descriptive titles. Help future developers As Fides grows, your code will be reused in more and more places, by developers who may not be familiar with the details of your implementation. Therefore, your tests are an opportunity to ensure that your code is used correctly in the future. For example, if your code needs to be used in a certain way, or expects a certain configuration, or is always expected to return a certain output, or has any other details that might impact its ability to be used in the framework, write a test for it! At minimum, you'll help a future developer understand that you consciously chose to design your code a certain way. Writing tests Fides's tests are stored in the tests directory. Tests should have descriptive names that make it clear what you're testing. If necessary, add a docstring or comment to explain why you're testing this specific thing. 1 2 3 4 5 6 def test_dry_evaluate_system_fail ( server_url , resources_dict ): ... # bad test name def test_dry_evaluate (): ... Fidesops has a few pytest fixtures available for testing; see conftest.py for details. Running tests Fidesops uses pytest for unit testing. As with other make commands, you have the option to run pytest in command-line or in application shell: In shell: Enter the fidesops container shell using nox -s dev -- shell , or pass in the datastores you want to start for integration testing (i.e., nox -s dev -- shell mssql mariadb ). You can then invoke pytest from the root fidesops directory: 1 2 cd fidesops pytest From regular command-line: 1 nox -s pytest_unit Running specific tests To run a subset of tests, provide a filename or directory; to match a specific test name, use the -k flag: 1 2 # run all tests in the tests/ops/integration directory that contain the word \"api\" in their title pytest tests/ops/integration/ -k api Other commands you may need are listed below. The full documentation can be found at: https://docs.pytest.org/en/6.2.x/ . Run all unit tests, except those that talk to integration databases - nox -s pytest_unit Run all integration tests, except those on external datastores - nox -s pytest_integration Run all tests that rely on third-party databases and services - nox -s pytest_integration_external Run all SaaS tests that rely on third-party databases and services - nox -s pytest_saas Debugging For debugging, we recommend installing the pdbpp package and running pytest with the --pdb flag (which will open the debugger on any error) or setting breakpoint() appropriately. Stepwise execution The --sw flag will exit pytest the first time it encounters an error; subsequent runs with the same flag will skip any tests that succeeded and run the failed test first. CI Workflows CI will run automatically against any PR you open. Please run your tests locally first to avoid \"debugging in CI\", as this takes up resources that could be used by other contributors.","title":"Testing"},{"location":"development/testing/#testing","text":"Fides loves tests! There are a few important reasons to write tests: Make sure your code works when it's supposed to Tests ensure that your code does the thing you intend it to do. If you have a function that adds two numbers, you'll want to test that it does, in fact, return their sum. If behavior depends on a configuration setting, ensure that changing that setting changes the behavior. In short, if you wrote a line of code, you should test that line works as expected. Make sure your code doesn't work when it's not supposed to It may seem silly, but another important reason to write tests is to ensure that your code behaves as expected even when it's broken . This is especially important for a project like Fides, which is focused on helping engineers when something unexpected happens to their code. For example, you could write tests about what you expect to happen if your function is called with incorrect (or no) arguments, or to ensure that any errors are properly trapped and handled. Tests are documentation Ultimately, your tests are the best documentation for your code. Another developer should be able to look at your tests and understand what your code does, how to invoke it, and what edge cases it contains. Therefore, try to write short, self-explanatory tests with descriptive titles. Help future developers As Fides grows, your code will be reused in more and more places, by developers who may not be familiar with the details of your implementation. Therefore, your tests are an opportunity to ensure that your code is used correctly in the future. For example, if your code needs to be used in a certain way, or expects a certain configuration, or is always expected to return a certain output, or has any other details that might impact its ability to be used in the framework, write a test for it! At minimum, you'll help a future developer understand that you consciously chose to design your code a certain way.","title":"Testing"},{"location":"development/testing/#writing-tests","text":"Fides's tests are stored in the tests directory. Tests should have descriptive names that make it clear what you're testing. If necessary, add a docstring or comment to explain why you're testing this specific thing. 1 2 3 4 5 6 def test_dry_evaluate_system_fail ( server_url , resources_dict ): ... # bad test name def test_dry_evaluate (): ... Fidesops has a few pytest fixtures available for testing; see conftest.py for details.","title":"Writing tests"},{"location":"development/testing/#running-tests","text":"Fidesops uses pytest for unit testing. As with other make commands, you have the option to run pytest in command-line or in application shell: In shell: Enter the fidesops container shell using nox -s dev -- shell , or pass in the datastores you want to start for integration testing (i.e., nox -s dev -- shell mssql mariadb ). You can then invoke pytest from the root fidesops directory: 1 2 cd fidesops pytest From regular command-line: 1 nox -s pytest_unit","title":"Running tests"},{"location":"development/testing/#running-specific-tests","text":"To run a subset of tests, provide a filename or directory; to match a specific test name, use the -k flag: 1 2 # run all tests in the tests/ops/integration directory that contain the word \"api\" in their title pytest tests/ops/integration/ -k api Other commands you may need are listed below. The full documentation can be found at: https://docs.pytest.org/en/6.2.x/ . Run all unit tests, except those that talk to integration databases - nox -s pytest_unit Run all integration tests, except those on external datastores - nox -s pytest_integration Run all tests that rely on third-party databases and services - nox -s pytest_integration_external Run all SaaS tests that rely on third-party databases and services - nox -s pytest_saas","title":"Running specific tests"},{"location":"development/testing/#debugging","text":"For debugging, we recommend installing the pdbpp package and running pytest with the --pdb flag (which will open the debugger on any error) or setting breakpoint() appropriately.","title":"Debugging"},{"location":"development/testing/#stepwise-execution","text":"The --sw flag will exit pytest the first time it encounters an error; subsequent runs with the same flag will skip any tests that succeeded and run the failed test first.","title":"Stepwise execution"},{"location":"development/testing/#ci-workflows","text":"CI will run automatically against any PR you open. Please run your tests locally first to avoid \"debugging in CI\", as this takes up resources that could be used by other contributors.","title":"CI Workflows"},{"location":"development/update_erd_diagram/","text":"Updating database diagram If you make updates to the fidesops application database, you should update our DB Architecture diagram in the documentation. Connect DBeaver to our app DB container DBeaver > Database > New Database Connection > PostgreSQL Add configuration details Right-click on postgres connection > Create > Other Select ER Diagram, Click Next Drill down to Postgres > app > Schemas > public and click the checkbox. Add a name to your ER Diagram Click Finish Drag and drop tables so they are less messy. File > Save As (app_database.png) Replace img/app_database.png with the new file","title":"Updating database diagram"},{"location":"development/update_erd_diagram/#updating-database-diagram","text":"If you make updates to the fidesops application database, you should update our DB Architecture diagram in the documentation. Connect DBeaver to our app DB container DBeaver > Database > New Database Connection > PostgreSQL Add configuration details Right-click on postgres connection > Create > Other Select ER Diagram, Click Next Drill down to Postgres > app > Schemas > public and click the checkbox. Add a name to your ER Diagram Click Finish Drag and drop tables so they are less messy. File > Save As (app_database.png) Replace img/app_database.png with the new file","title":"Updating database diagram"},{"location":"guides/complex_fields/","text":"Annotate Complex Fields Fidesops can retrieve and mask data from complex objects and arrays in MongoDB, although this involves annotating your dataset files to let fidesops know about your complex data. Declare an object field To declare an object field, you should define nested fields underneath that field. You can optionally add the data_type: object annotation, but the object type will be inferred by the presence of the nested fields. In the example below, workplace_info is an object field with two nested fields: employer and position . Data categories cannot be specified at the object level due to potential conflicts with nested fields. Instead, annotate the scalar fields within the object field. Here, the workplace_info.position field has data_category user.job_title . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dataset : - fides_key : mongo_nested_object_example name : Mongo Example with Nested Objects description : Example of a Mongo dataset that contains 'details' about customers defined in the 'postgres_example_test_dataset' collections : - name : customer_details fields : - ... - name : workplace_info fidesops_meta : data_type : object fields : - name : employer fidesops_meta : data_type : string - name : position data_categories : [ user.job_title ] fidesops_meta : data_type : string - name : id Reference a nested field To define a relationship between a field on one collection and a nested field on another collection, use dot notation in the fidesops_meta references for as many levels are necessary. In the example below, we might add a separate customer collection that references the nested field workplace_info.id field in the customer_details collection. Under references, this field is denoted by <collection_name>.<field_name>.<sub_field> name, or customer_details.workplace_info.id . If we preferred, we could instead define this relationship on the customer_details.workplace_info.id field itself, with a direction of from , with field mydatabase.customer.workplace_id , and dataset mydatabase . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : workplace_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mongo_nested_object_example field : customer_details.workplace_info.id direction : to ... Declare an array field There is not an official array type per se, since arrays can store scalar values or objects. Instead, an array is represented by a [] flag on a field. Declare an array of scalar values In this example, our mydatabase:customer collection has a travel_identifiers field that is an array of strings, described by data_type: string[] . An array of integers would be described by data_type: integer[] . 1 2 3 4 5 6 7 8 9 10 11 12 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - ... - name : travel_identifiers fidesops_meta : data_type : string[] data_categories : [ system.operations ] Declare a nested array In this example, our mydatabase:customer collection has a nested workplace_info.direct_reports array, that is an array of strings. In other words, we have a workplace_info object field, with sub-fields employer , postion , and direct_reports , where direct_reports is an array. We define direct_reports as a subfield under workplace_info , as well as add the data_type string[] to direct_reports . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : workplace_info fidesops_meta : data_type : object fields : - name : employer fidesops_meta : data_type : string - name : position data_categories : [ user.job_title ] fidesops_meta : data_type : string - name : direct_reports data_categories : [ user.name ] fidesops_meta : data_type : string[] Declare an array of objects In this example, our mydatabase:customer collection has an emergency_contacts field which is an array of objects, or embedded documents, denoted by data_type: object[] . Each object in the emergency_contacts array can contain a name , relationship , and phone field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : emergency_contacts fidesops_meta : data_type : object[] fields : - name : name data_categories : [ user.name ] fidesops_meta : data_type : string - name : relationship fidesops_meta : data_type : string - name : phone data_categories : [ user.contact.phone_number ] fidesops_meta : data_type : string Reference an array Generally, reference an array field as if it is any other field. You cannot currently reference a specific index in an array field, but you can point a field to an array field, and we would search for matches within that array. In this example, mydatabase:flights.plane is an integer field that will be used to lookup records that match an integer in the mydatabase:aircraft.planes array. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : flights fields : - ... - name : passenger_information fields : - name : passenger_ids fidesops_meta : data_type : string[] - name : plane data_categories : [ system.operations ] fidesops_meta : data_type : integer - name : aircraft fields : - name : _id data_categories : [ system.operations ] fidesops_meta : primary_key : True data_type : object_id - name : planes data_categories : [ system.operations ] fidesops_meta : data_type : integer[] references : - dataset : mydatabase field : flights.plane direction : from - name : model data_categories : [ system.operations ] fidesops_meta : data_type : string In this more complicated example, a field in an array of objects is used to look up a different field in an array of objects in another collection. Potentially multiple values from mydatabase:customer.comments.comment_id can be used to query for corresponding values in mydatabase:conversations.thread.comment . Because this field is in an array of objects, multiple matches may be found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : comments fidesops_meta : data_type : object[] fields : - name : comment_id fidesops_meta : data_type : string references : - dataset : mydatabase field : conversations.thread.comment direction : to - name : conversations fidesops_meta : data_type : object[] fields : - name : thread fields : - name : comment fidesops_meta : data_type : string - name : message fidesops_meta : data_type : string - name : chat_name data_categories : [ user.name ] fidesops_meta : data_type : string Query an array There are some assumptions made with array querying that may or may not fit with how your data is structured. If an array is an entrypoint into a collection (in other words, one collection references its array field), there is ambiguity around how the queries should be built - for example, AND versus OR, and whether only the matched indices or matched embedded documents within arrays should be considered. Assumptions 1) If an array is the entry point into a node, we will search for corresponding matches across the entire array. You cannot specify a certain index. 2) Everything is basically an \"OR\" query. Data returned from multiple array fields will be flattened before being passed into the next collection. 1) For example, say Collection A returned values [1, 2, 3] and Collection B returned values [4, 5, 6]. Collection C has an array field that depends on both Collection A and Collection B. We search Collection C's array field to return any record that contains one of the values [1, 2, 3, 4, 5, 6] in the array. 3. By default, if an array field is an entry point to a node, only matching indices in that array are considered, both for access and erasures, as well as for subsequent queries on dependent collections where applicable. 1. For example, a query on Collection A only matched indices 0 and 1 in an array. Only the data located at indices 0 and 1 will be returned, and used to query data on dependent collection C. 2. This can be overridden by specifying return_all_elements: true on an entrypoint array field, in which case, the query will return the entire array and/or mask the entire array. 4. Individual array elements are masked, not the entire array, e.g. [\"MASKED\", \"MASKED\", \"MASKED\"] Example query traversal This is an example traversal created from our test postgres_example and mongo_test datasets. Multiple collections are point to or from complex objects and arrays. See the mongo_example_test_dataset.yml for more information.","title":"Annotate Complex Fields"},{"location":"guides/complex_fields/#annotate-complex-fields","text":"Fidesops can retrieve and mask data from complex objects and arrays in MongoDB, although this involves annotating your dataset files to let fidesops know about your complex data.","title":"Annotate Complex Fields"},{"location":"guides/complex_fields/#declare-an-object-field","text":"To declare an object field, you should define nested fields underneath that field. You can optionally add the data_type: object annotation, but the object type will be inferred by the presence of the nested fields. In the example below, workplace_info is an object field with two nested fields: employer and position . Data categories cannot be specified at the object level due to potential conflicts with nested fields. Instead, annotate the scalar fields within the object field. Here, the workplace_info.position field has data_category user.job_title . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dataset : - fides_key : mongo_nested_object_example name : Mongo Example with Nested Objects description : Example of a Mongo dataset that contains 'details' about customers defined in the 'postgres_example_test_dataset' collections : - name : customer_details fields : - ... - name : workplace_info fidesops_meta : data_type : object fields : - name : employer fidesops_meta : data_type : string - name : position data_categories : [ user.job_title ] fidesops_meta : data_type : string - name : id","title":"Declare an object field"},{"location":"guides/complex_fields/#reference-a-nested-field","text":"To define a relationship between a field on one collection and a nested field on another collection, use dot notation in the fidesops_meta references for as many levels are necessary. In the example below, we might add a separate customer collection that references the nested field workplace_info.id field in the customer_details collection. Under references, this field is denoted by <collection_name>.<field_name>.<sub_field> name, or customer_details.workplace_info.id . If we preferred, we could instead define this relationship on the customer_details.workplace_info.id field itself, with a direction of from , with field mydatabase.customer.workplace_id , and dataset mydatabase . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : workplace_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mongo_nested_object_example field : customer_details.workplace_info.id direction : to ...","title":"Reference a nested field"},{"location":"guides/complex_fields/#declare-an-array-field","text":"There is not an official array type per se, since arrays can store scalar values or objects. Instead, an array is represented by a [] flag on a field.","title":"Declare an array field"},{"location":"guides/complex_fields/#declare-an-array-of-scalar-values","text":"In this example, our mydatabase:customer collection has a travel_identifiers field that is an array of strings, described by data_type: string[] . An array of integers would be described by data_type: integer[] . 1 2 3 4 5 6 7 8 9 10 11 12 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - ... - name : travel_identifiers fidesops_meta : data_type : string[] data_categories : [ system.operations ]","title":"Declare an array of scalar values"},{"location":"guides/complex_fields/#declare-a-nested-array","text":"In this example, our mydatabase:customer collection has a nested workplace_info.direct_reports array, that is an array of strings. In other words, we have a workplace_info object field, with sub-fields employer , postion , and direct_reports , where direct_reports is an array. We define direct_reports as a subfield under workplace_info , as well as add the data_type string[] to direct_reports . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : workplace_info fidesops_meta : data_type : object fields : - name : employer fidesops_meta : data_type : string - name : position data_categories : [ user.job_title ] fidesops_meta : data_type : string - name : direct_reports data_categories : [ user.name ] fidesops_meta : data_type : string[]","title":"Declare a nested array"},{"location":"guides/complex_fields/#declare-an-array-of-objects","text":"In this example, our mydatabase:customer collection has an emergency_contacts field which is an array of objects, or embedded documents, denoted by data_type: object[] . Each object in the emergency_contacts array can contain a name , relationship , and phone field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : emergency_contacts fidesops_meta : data_type : object[] fields : - name : name data_categories : [ user.name ] fidesops_meta : data_type : string - name : relationship fidesops_meta : data_type : string - name : phone data_categories : [ user.contact.phone_number ] fidesops_meta : data_type : string","title":"Declare an array of objects"},{"location":"guides/complex_fields/#reference-an-array","text":"Generally, reference an array field as if it is any other field. You cannot currently reference a specific index in an array field, but you can point a field to an array field, and we would search for matches within that array. In this example, mydatabase:flights.plane is an integer field that will be used to lookup records that match an integer in the mydatabase:aircraft.planes array. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : flights fields : - ... - name : passenger_information fields : - name : passenger_ids fidesops_meta : data_type : string[] - name : plane data_categories : [ system.operations ] fidesops_meta : data_type : integer - name : aircraft fields : - name : _id data_categories : [ system.operations ] fidesops_meta : primary_key : True data_type : object_id - name : planes data_categories : [ system.operations ] fidesops_meta : data_type : integer[] references : - dataset : mydatabase field : flights.plane direction : from - name : model data_categories : [ system.operations ] fidesops_meta : data_type : string In this more complicated example, a field in an array of objects is used to look up a different field in an array of objects in another collection. Potentially multiple values from mydatabase:customer.comments.comment_id can be used to query for corresponding values in mydatabase:conversations.thread.comment . Because this field is in an array of objects, multiple matches may be found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : customer fields : - name : comments fidesops_meta : data_type : object[] fields : - name : comment_id fidesops_meta : data_type : string references : - dataset : mydatabase field : conversations.thread.comment direction : to - name : conversations fidesops_meta : data_type : object[] fields : - name : thread fields : - name : comment fidesops_meta : data_type : string - name : message fidesops_meta : data_type : string - name : chat_name data_categories : [ user.name ] fidesops_meta : data_type : string","title":"Reference an array"},{"location":"guides/complex_fields/#query-an-array","text":"There are some assumptions made with array querying that may or may not fit with how your data is structured. If an array is an entrypoint into a collection (in other words, one collection references its array field), there is ambiguity around how the queries should be built - for example, AND versus OR, and whether only the matched indices or matched embedded documents within arrays should be considered.","title":"Query an array"},{"location":"guides/complex_fields/#assumptions","text":"1) If an array is the entry point into a node, we will search for corresponding matches across the entire array. You cannot specify a certain index. 2) Everything is basically an \"OR\" query. Data returned from multiple array fields will be flattened before being passed into the next collection. 1) For example, say Collection A returned values [1, 2, 3] and Collection B returned values [4, 5, 6]. Collection C has an array field that depends on both Collection A and Collection B. We search Collection C's array field to return any record that contains one of the values [1, 2, 3, 4, 5, 6] in the array. 3. By default, if an array field is an entry point to a node, only matching indices in that array are considered, both for access and erasures, as well as for subsequent queries on dependent collections where applicable. 1. For example, a query on Collection A only matched indices 0 and 1 in an array. Only the data located at indices 0 and 1 will be returned, and used to query data on dependent collection C. 2. This can be overridden by specifying return_all_elements: true on an entrypoint array field, in which case, the query will return the entire array and/or mask the entire array. 4. Individual array elements are masked, not the entire array, e.g. [\"MASKED\", \"MASKED\", \"MASKED\"]","title":"Assumptions"},{"location":"guides/complex_fields/#example-query-traversal","text":"This is an example traversal created from our test postgres_example and mongo_test datasets. Multiple collections are point to or from complex objects and arrays. See the mongo_example_test_dataset.yml for more information.","title":"Example query traversal"},{"location":"guides/configuration_reference/","text":"Application Configuration Reference How to configure the fidesops application The fidesops application configuration variables are provided in the fidesops.toml file in .toml format. Fidesops will take the first config file it finds from the following locations: The location according to the FIDES__CONFIG_PATH environment variable The current working directory ( ./fidesops.toml ) The parent of the current working directory ( ../fidesops.toml ) The user's home directory ( ~/fidesops.toml ) Fidesops is also able to be run exclusively from environment variables. For more information and examples, see Deployment . Configuration variable reference The fidesops.toml file should specify the following variables: TOML Variable ENV Variable Type Example Default Description port --- int 8080 8080 The port at which the webserver will run. Database Variables --- --- --- --- --- server FIDESOPS__DATABASE__SERVER string postgres.internal N/A The networking address for the fideops Postgres database server user FIDESOPS__DATABASE__USER string postgres N/A The database user with which to login to the fidesops application database password FIDESOPS__DATABASE__PASSWORD string apassword N/A The password with which to login to the fidesops application database port FIDESOPS__DATABASE__PORT int 5432 5432 The port at which the fidesops application database will be accessible db FIDESOPS__DATABASE__DB string db N/A The name of the database to use in the fidesops application database enabled FIDESOPS__DATABASE__ENABLED bool True True Whether the application database should be enabled. Only set to false for certain narrow uses of the application that do not require a backing application database. Redis Variables --- --- --- --- --- host FIDESOPS__REDIS__HOST string redis.internal N/A The networking address for the fidesops application Redis cache port FIDESOPS__REDIS__PORT int 6379 6379 The port at which the fidesops application cache will be accessible user FIDESOPS__REDIS__USER string testuser N/A The user with which to login to the Redis cache password FIDESOPS__REDIS__PASSWORD string anotherpassword N/A The password with which to login to the fidesops application cache db_index FIDESOPS__REDIS__DB_INDEX int 0 N/A The fidesops application will use this index in the Redis cache to cache data connection_url FIDESOPS__REDIS__CONNECTION_URL string redis://:testpassword@redis:6379/0 N/A If not specified this URL is automatically assembled from the host , port , password and db_index specified above default_ttl_seconds FIDESOPS__REDIS__DEFAULT_TTL_SECONDS int 3600 604800 The number of seconds for which data will live in Redis before automatically expiring enabled FIDESOPS__REDIS__ENABLED bool True True Whether the application's redis cache should be enabled. Only set to false for certain narrow uses of the application that do not require a backing redis cache. Security Variables --- --- --- --- --- app_encryption_key FIDESOPS__SECURITY__APP_ENCRYPTION_KEY string OLMkv91j8DHiDAULnK5Lxx3kSCov30b3 N/A The key used to sign fidesops API access tokens cors_origins FIDESOPS__SECURITY__CORS_ORIGINS List[AnyHttpUrl] [\"https://a-client.com/\", \"https://another-client.com\"/] N/A A list of pre-approved addresses of clients allowed to communicate with the fidesops application server log_level FIDESOPS__SECURITY__LOG_LEVEL string INFO N/A The log level used for fidesops. Must be one of DEBUG, INFO, WARNING, ERROR, or CRITICAL oauth_root_client_id FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID string fidesopsadmin N/A The value used to identify the fidesops application root API client oauth_root_client_secret FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET string fidesopsadminsecret N/A The secret value used to authenticate the fidesops application root API client oauth_access_token_expire_minutes FIDESOPS__SECURITY__OAUTH_ACCESS_TOKEN_EXPIRE_MINUTES int 1 11520 The time period fidesops API tokens will be valid root_username FIDESOPS__SECURITY__ROOT_USERNAME string root_user None If set this can be used in conjunction with root_password to log in as a root user without first needing to create a user in the database. root_password FIDESOPS__SECURITY__ROOT_PASSWORD string apassword None If set this can be used in conjunction with root_username to log in as a root user without first needing to create a user in the database. root_user_scopes FIDESOPS__SECURITY__ROOT_USER_SCOPES list of strings [\"client:create\", \"client:update\"] All available scopes The scopes granted to the root user when logging in with root_username and root_password . subject_request_download_link_ttl_seconds FIDESOPS__SECURITY__SUBJECT_REQUEST_DOWNLOAD_LINK_TTL_SECONDS int 86400 86400 Time in seconds for a subject data package download link to remain valid, default to 1 day. Execution Variables --- --- --- --- --- privacy_request_delay_timeout FIDESOPS__EXECUTION__PRIVACY_REQUEST_DELAY_TIMEOUT int 3600 3600 The amount of time to wait for actions delaying privacy requests, for example pre and post processing webhooks. task_retry_count FIDESOPS__EXECUTION__TASK_RETRY_COUNT int 5 0 The number of times a failed request will be retried task_retry_delay FIDESOPS__EXECUTION__TASK_RETRY_DELAY int 20 1 The delays between retries in seconds task_retry_backoff FIDESOPS__EXECUTION__TASK_RETRY_BACKOFF int 2 1 The backoff factor for retries, to space out repeated retries. subject_identity_verification_required FIDESOPS__EXECUTION__SUBJECT_IDENTITY_VERIFICATION_REQUIRED bool False False Whether privacy requests require user identity verification require_manual_request_approval FIDESOPS__EXECUTION__REQUIRE_MANUAL_REQUEST_APPROVAL bool False False Whether privacy requests require explicit approval to execute masking_strict FIDESOPS__EXECUTION__MASKING_STRICT bool True True If masking_strict is True, we only use \"update\" requests to mask data. (For third-party integrations, you should define an update endpoint to use.) If masking_strict is False, you are allowing fidesops to use any defined DELETE or GDPR DELETE endpoints to remove PII. In this case, you should define delete or data_protection_request endpoints for your third-party integrations. Note that setting masking_strict to False means that data may be deleted beyond the specific data categories that you've configured in your Policy. celery_config_path FIDESOPS__EXECUTION__CELERY_CONFIG_PATH string data/config/celery.toml N/A An optional override for the Celery configuration file path. worker_enabled FIDESOPS__EXECUTION__WORKER_ENABLED bool True True By default, fidesops uses a dedicated Celery worker to process privacy requests asynchronously. Setting worker_enabled to False will run the worker on the same node as the webserver. Analytics --- --- --- --- --- analytics_opt_out FIDESOPS__ROOT_USER__ANALYTICS_OPT_OUT bool False False Opt out of sending anonymous usage data to Ethyca to improve the product experience. Admin UI Variables --- --- --- --- --- enabled FIDESOPS__ADMIN_UI__ENABLED bool False True Toggle whether the Admin UI is served from / Fidesops Notification Variables --- --- --- --- --- send_request_completion_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_COMPLETION_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request completion send_request_receipt_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_RECEIPT_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request receipt send_request_review_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_REVIEW_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request review An example fidesops.toml configuration file 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 port = 8080 [database] server = \"db\" user = \"postgres\" password = \"a-password\" db = \"app\" test_db = \"test\" enabled = true [redis] host = \"redis\" password = \"testpassword\" port = 6379 charset = \"utf8\" default_ttl_seconds = 3600 db_index = 0 enabled = true [security] app_encryption_key = \"OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\" cors_origins = [ \"http://localhost\", \"http://localhost:8080\", \"http://localhost:3000\", \"http://localhost:3001\",] encoding = \"UTF-8\" oauth_root_client_id = \"fidesopsadmin\" oauth_root_client_secret = \"fidesopsadminsecret\" log_level = \"INFO\" root_username = \"root_user\" root_password = \"Testpassword1!\" subject_request_download_link_ttl_seconds = 86400 [execution] masking_strict = true require_manual_request_approval = true subject_identity_verification_required = false task_retry_count = 3 task_retry_delay = 20 task_retry_backoff = 2 worker_enabled = true celery_config_path=\"data/config/celery.toml\" [root_user] analytics_opt_out = false [admin_ui] enabled = true [notifications] send_request_completion_notification = true send_request_receipt_notification = true send_request_review_notification = true Note: The configuration is case-sensitive, so the variables must be specified in lowercase . Additional environment variables ENV Variable Default Description FIDESOPS__LOG_PII False If this is set to \"True\", pii values will display unmasked in log output. This variable should always be set to \"False\" in production systems. FIDESOPS__HOT_RELOAD False If \"True\", the fidesops server will reload code changes without you needing to restart the server. This variable should always be set to \"False\" in production systems. FIDESOPS__DEV_MODE False If \"True\", the fidesops server will log error tracebacks, and log details of third party requests. This variable should always be set to \"False\" in production systems. FIDES__CONFIG_PATH None If this variable is set to a path, that path will be used to load .toml files first. That is, any .toml files on this path will override any installed .toml files. FIDESOPS__DATABASE__SQLALCHEMY_DATABASE_URI None An optional override for the URI used for the database connection, in the form of postgresql://<user>:<password>@<hostname>:<port>/<database> . TESTING False This variable does not need to be set - Pytest will set it to True when running unit tests, so we run against the test database. Celery configuration Fidesops uses Celery for asynchronous task management. The celery.toml file provided contains a brief configuration reference for managing Celery variables. By default, fidesops will look for this file in the root directory of your application, but this location can be optionally overridden by specifying an alternate celery_config_path in your fidesops.toml . For a full list of possible variable overrides, see the Celery configuration documentation. Example celery.toml 1 2 3 task_default_queue = \"fidesops\" broker_url = \"redis://:testpassword@redis:6379/1\" result_backend = \"redis://:testpassword@redis:6379/1\" Celery Variable Example Description task_default_queue fidesops A name to use for your Celery task queue. broker_url redis://:testpassword@redis:6379/1 The datastore to use as a Celery broker , which maintains an ordered list of asynchronous tasks to execute. If not specified, fidesops will default to the connection_url or Redis config values specified in your fidesops.toml . result_backend redis://:testpassword@redis:6379/1 The backend datastore where Celery will store results from asynchronously processed tasks. If not specified, fidesops will default to the connection_url or Redis config values specified in your fidesops.toml . Reporting a running application's configuration You can view the currently running configuration of a fidesops application with the following request: GET /api/v1/config Please note: fidesops will filter out any sensitive configuration variables. The full list of variables deemed safe to return is: Postgres database server user port db test_db Redis cache host port charset decode_responses default_ttl_seconds db_index Security settings cors_origins encoding oauth_access_token_expire_minutes Execution settings task_retry_count task_retry_delay task_retry_backoff require_manual_request_approval masking_strict For more information please see the api docs .","title":"Configuration Reference"},{"location":"guides/configuration_reference/#application-configuration-reference","text":"","title":"Application Configuration Reference"},{"location":"guides/configuration_reference/#how-to-configure-the-fidesops-application","text":"The fidesops application configuration variables are provided in the fidesops.toml file in .toml format. Fidesops will take the first config file it finds from the following locations: The location according to the FIDES__CONFIG_PATH environment variable The current working directory ( ./fidesops.toml ) The parent of the current working directory ( ../fidesops.toml ) The user's home directory ( ~/fidesops.toml ) Fidesops is also able to be run exclusively from environment variables. For more information and examples, see Deployment .","title":"How to configure the fidesops application"},{"location":"guides/configuration_reference/#configuration-variable-reference","text":"The fidesops.toml file should specify the following variables: TOML Variable ENV Variable Type Example Default Description port --- int 8080 8080 The port at which the webserver will run. Database Variables --- --- --- --- --- server FIDESOPS__DATABASE__SERVER string postgres.internal N/A The networking address for the fideops Postgres database server user FIDESOPS__DATABASE__USER string postgres N/A The database user with which to login to the fidesops application database password FIDESOPS__DATABASE__PASSWORD string apassword N/A The password with which to login to the fidesops application database port FIDESOPS__DATABASE__PORT int 5432 5432 The port at which the fidesops application database will be accessible db FIDESOPS__DATABASE__DB string db N/A The name of the database to use in the fidesops application database enabled FIDESOPS__DATABASE__ENABLED bool True True Whether the application database should be enabled. Only set to false for certain narrow uses of the application that do not require a backing application database. Redis Variables --- --- --- --- --- host FIDESOPS__REDIS__HOST string redis.internal N/A The networking address for the fidesops application Redis cache port FIDESOPS__REDIS__PORT int 6379 6379 The port at which the fidesops application cache will be accessible user FIDESOPS__REDIS__USER string testuser N/A The user with which to login to the Redis cache password FIDESOPS__REDIS__PASSWORD string anotherpassword N/A The password with which to login to the fidesops application cache db_index FIDESOPS__REDIS__DB_INDEX int 0 N/A The fidesops application will use this index in the Redis cache to cache data connection_url FIDESOPS__REDIS__CONNECTION_URL string redis://:testpassword@redis:6379/0 N/A If not specified this URL is automatically assembled from the host , port , password and db_index specified above default_ttl_seconds FIDESOPS__REDIS__DEFAULT_TTL_SECONDS int 3600 604800 The number of seconds for which data will live in Redis before automatically expiring enabled FIDESOPS__REDIS__ENABLED bool True True Whether the application's redis cache should be enabled. Only set to false for certain narrow uses of the application that do not require a backing redis cache. Security Variables --- --- --- --- --- app_encryption_key FIDESOPS__SECURITY__APP_ENCRYPTION_KEY string OLMkv91j8DHiDAULnK5Lxx3kSCov30b3 N/A The key used to sign fidesops API access tokens cors_origins FIDESOPS__SECURITY__CORS_ORIGINS List[AnyHttpUrl] [\"https://a-client.com/\", \"https://another-client.com\"/] N/A A list of pre-approved addresses of clients allowed to communicate with the fidesops application server log_level FIDESOPS__SECURITY__LOG_LEVEL string INFO N/A The log level used for fidesops. Must be one of DEBUG, INFO, WARNING, ERROR, or CRITICAL oauth_root_client_id FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_ID string fidesopsadmin N/A The value used to identify the fidesops application root API client oauth_root_client_secret FIDESOPS__SECURITY__OAUTH_ROOT_CLIENT_SECRET string fidesopsadminsecret N/A The secret value used to authenticate the fidesops application root API client oauth_access_token_expire_minutes FIDESOPS__SECURITY__OAUTH_ACCESS_TOKEN_EXPIRE_MINUTES int 1 11520 The time period fidesops API tokens will be valid root_username FIDESOPS__SECURITY__ROOT_USERNAME string root_user None If set this can be used in conjunction with root_password to log in as a root user without first needing to create a user in the database. root_password FIDESOPS__SECURITY__ROOT_PASSWORD string apassword None If set this can be used in conjunction with root_username to log in as a root user without first needing to create a user in the database. root_user_scopes FIDESOPS__SECURITY__ROOT_USER_SCOPES list of strings [\"client:create\", \"client:update\"] All available scopes The scopes granted to the root user when logging in with root_username and root_password . subject_request_download_link_ttl_seconds FIDESOPS__SECURITY__SUBJECT_REQUEST_DOWNLOAD_LINK_TTL_SECONDS int 86400 86400 Time in seconds for a subject data package download link to remain valid, default to 1 day. Execution Variables --- --- --- --- --- privacy_request_delay_timeout FIDESOPS__EXECUTION__PRIVACY_REQUEST_DELAY_TIMEOUT int 3600 3600 The amount of time to wait for actions delaying privacy requests, for example pre and post processing webhooks. task_retry_count FIDESOPS__EXECUTION__TASK_RETRY_COUNT int 5 0 The number of times a failed request will be retried task_retry_delay FIDESOPS__EXECUTION__TASK_RETRY_DELAY int 20 1 The delays between retries in seconds task_retry_backoff FIDESOPS__EXECUTION__TASK_RETRY_BACKOFF int 2 1 The backoff factor for retries, to space out repeated retries. subject_identity_verification_required FIDESOPS__EXECUTION__SUBJECT_IDENTITY_VERIFICATION_REQUIRED bool False False Whether privacy requests require user identity verification require_manual_request_approval FIDESOPS__EXECUTION__REQUIRE_MANUAL_REQUEST_APPROVAL bool False False Whether privacy requests require explicit approval to execute masking_strict FIDESOPS__EXECUTION__MASKING_STRICT bool True True If masking_strict is True, we only use \"update\" requests to mask data. (For third-party integrations, you should define an update endpoint to use.) If masking_strict is False, you are allowing fidesops to use any defined DELETE or GDPR DELETE endpoints to remove PII. In this case, you should define delete or data_protection_request endpoints for your third-party integrations. Note that setting masking_strict to False means that data may be deleted beyond the specific data categories that you've configured in your Policy. celery_config_path FIDESOPS__EXECUTION__CELERY_CONFIG_PATH string data/config/celery.toml N/A An optional override for the Celery configuration file path. worker_enabled FIDESOPS__EXECUTION__WORKER_ENABLED bool True True By default, fidesops uses a dedicated Celery worker to process privacy requests asynchronously. Setting worker_enabled to False will run the worker on the same node as the webserver. Analytics --- --- --- --- --- analytics_opt_out FIDESOPS__ROOT_USER__ANALYTICS_OPT_OUT bool False False Opt out of sending anonymous usage data to Ethyca to improve the product experience. Admin UI Variables --- --- --- --- --- enabled FIDESOPS__ADMIN_UI__ENABLED bool False True Toggle whether the Admin UI is served from / Fidesops Notification Variables --- --- --- --- --- send_request_completion_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_COMPLETION_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request completion send_request_receipt_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_RECEIPT_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request receipt send_request_review_notification FIDESOPS__NOTIFICATIONS__SEND_REQUEST_REVIEW_NOTIFICATION bool True True Whether a notification will be sent to data subjects upon privacy request review","title":"Configuration variable reference"},{"location":"guides/configuration_reference/#an-example-fidesopstoml-configuration-file","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 port = 8080 [database] server = \"db\" user = \"postgres\" password = \"a-password\" db = \"app\" test_db = \"test\" enabled = true [redis] host = \"redis\" password = \"testpassword\" port = 6379 charset = \"utf8\" default_ttl_seconds = 3600 db_index = 0 enabled = true [security] app_encryption_key = \"OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\" cors_origins = [ \"http://localhost\", \"http://localhost:8080\", \"http://localhost:3000\", \"http://localhost:3001\",] encoding = \"UTF-8\" oauth_root_client_id = \"fidesopsadmin\" oauth_root_client_secret = \"fidesopsadminsecret\" log_level = \"INFO\" root_username = \"root_user\" root_password = \"Testpassword1!\" subject_request_download_link_ttl_seconds = 86400 [execution] masking_strict = true require_manual_request_approval = true subject_identity_verification_required = false task_retry_count = 3 task_retry_delay = 20 task_retry_backoff = 2 worker_enabled = true celery_config_path=\"data/config/celery.toml\" [root_user] analytics_opt_out = false [admin_ui] enabled = true [notifications] send_request_completion_notification = true send_request_receipt_notification = true send_request_review_notification = true Note: The configuration is case-sensitive, so the variables must be specified in lowercase .","title":"An example fidesops.toml configuration file"},{"location":"guides/configuration_reference/#additional-environment-variables","text":"ENV Variable Default Description FIDESOPS__LOG_PII False If this is set to \"True\", pii values will display unmasked in log output. This variable should always be set to \"False\" in production systems. FIDESOPS__HOT_RELOAD False If \"True\", the fidesops server will reload code changes without you needing to restart the server. This variable should always be set to \"False\" in production systems. FIDESOPS__DEV_MODE False If \"True\", the fidesops server will log error tracebacks, and log details of third party requests. This variable should always be set to \"False\" in production systems. FIDES__CONFIG_PATH None If this variable is set to a path, that path will be used to load .toml files first. That is, any .toml files on this path will override any installed .toml files. FIDESOPS__DATABASE__SQLALCHEMY_DATABASE_URI None An optional override for the URI used for the database connection, in the form of postgresql://<user>:<password>@<hostname>:<port>/<database> . TESTING False This variable does not need to be set - Pytest will set it to True when running unit tests, so we run against the test database.","title":"Additional environment variables"},{"location":"guides/configuration_reference/#celery-configuration","text":"Fidesops uses Celery for asynchronous task management. The celery.toml file provided contains a brief configuration reference for managing Celery variables. By default, fidesops will look for this file in the root directory of your application, but this location can be optionally overridden by specifying an alternate celery_config_path in your fidesops.toml . For a full list of possible variable overrides, see the Celery configuration documentation. Example celery.toml 1 2 3 task_default_queue = \"fidesops\" broker_url = \"redis://:testpassword@redis:6379/1\" result_backend = \"redis://:testpassword@redis:6379/1\" Celery Variable Example Description task_default_queue fidesops A name to use for your Celery task queue. broker_url redis://:testpassword@redis:6379/1 The datastore to use as a Celery broker , which maintains an ordered list of asynchronous tasks to execute. If not specified, fidesops will default to the connection_url or Redis config values specified in your fidesops.toml . result_backend redis://:testpassword@redis:6379/1 The backend datastore where Celery will store results from asynchronously processed tasks. If not specified, fidesops will default to the connection_url or Redis config values specified in your fidesops.toml .","title":"Celery configuration"},{"location":"guides/configuration_reference/#reporting-a-running-applications-configuration","text":"You can view the currently running configuration of a fidesops application with the following request: GET /api/v1/config Please note: fidesops will filter out any sensitive configuration variables. The full list of variables deemed safe to return is:","title":"Reporting a running application's configuration"},{"location":"guides/configuration_reference/#postgres-database","text":"server user port db test_db","title":"Postgres database"},{"location":"guides/configuration_reference/#redis-cache","text":"host port charset decode_responses default_ttl_seconds db_index","title":"Redis cache"},{"location":"guides/configuration_reference/#security-settings","text":"cors_origins encoding oauth_access_token_expire_minutes","title":"Security settings"},{"location":"guides/configuration_reference/#execution-settings","text":"task_retry_count task_retry_delay task_retry_backoff require_manual_request_approval masking_strict For more information please see the api docs .","title":"Execution settings"},{"location":"guides/connection_types/","text":"Connection Types Available Connection Types To view a list of all available connection types, visit GET /api/v1/connection_type . This endpoint can be filtered with a search query param or a system_type query param and is subject to change. We include database options and third party API services with which fidesops can communicate. GET /api/v1/connection_type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 { \"items\" : [ { \"identifier\" : \"bigquery\" , \"type\" : \"database\" , \"human_readable\" : \"BigQuery\" }, { \"identifier\" : \"mariadb\" , \"type\" : \"database\" , \"human_readable\" : \"MariaDB\" }, { \"identifier\" : \"mongodb\" , \"type\" : \"database\" , \"human_readable\" : \"MongoDB\" }, { \"identifier\" : \"mssql\" , \"type\" : \"database\" , \"human_readable\" : \"Microsoft SQL Server\" }, { \"identifier\" : \"mysql\" , \"type\" : \"database\" , \"human_readable\" : \"MySQL\" }, { \"identifier\" : \"postgres\" , \"type\" : \"database\" , \"human_readable\" : \"PostgreSQL\" }, { \"identifier\" : \"redshift\" , \"type\" : \"database\" , \"human_readable\" : \"Amazon Redshift\" }, { \"identifier\" : \"snowflake\" , \"type\" : \"database\" , \"human_readable\" : \"Snowflake\" }, { \"identifier\" : \"adobe_campaign\" , \"type\" : \"saas\" , \"human_readable\" : \"Adobe Campaign\" }, { \"identifier\" : \"auth0\" , \"type\" : \"saas\" , \"human_readable\" : \"Auth0\" }, { \"identifier\" : \"datadog\" , \"type\" : \"saas\" , \"human_readable\" : \"Datadog\" }, { \"identifier\" : \"hubspot\" , \"type\" : \"saas\" , \"human_readable\" : \"HubSpot\" }, { \"identifier\" : \"mailchimp\" , \"type\" : \"saas\" , \"human_readable\" : \"Mailchimp\" }, { \"identifier\" : \"outreach\" , \"type\" : \"saas\" , \"human_readable\" : \"Outreach\" }, { \"identifier\" : \"salesforce\" , \"type\" : \"saas\" , \"human_readable\" : \"Salesforce\" }, { \"identifier\" : \"segment\" , \"type\" : \"saas\" , \"human_readable\" : \"Segment\" }, { \"identifier\" : \"sendgrid\" , \"type\" : \"saas\" , \"human_readable\" : \"SendGrid\" }, { \"identifier\" : \"sentry\" , \"type\" : \"saas\" , \"human_readable\" : \"Sentry\" }, { \"identifier\" : \"shopify\" , \"type\" : \"saas\" , \"human_readable\" : \"Shopify\" }, { \"identifier\" : \"stripe\" , \"type\" : \"saas\" , \"human_readable\" : \"Stripe\" }, { \"identifier\" : \"zendesk\" , \"type\" : \"saas\" , \"human_readable\" : \"Zendesk\" }, { \"identifier\" : \"manual_webhook\" , \"type\" : \"manual\" , \"human_readable\" : \"Manual Webhook\" } ], \"total\" : 23 , \"page\" : 1 , \"size\" : 50 } Required Connection Secrets To view the secrets needed to authenticate with a given connection, visit GET /api/v1/connection_type/<connection_type>/secret . Example GET /api/v1/connection_type/sentry/secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"title\" : \"sentry_schema\" , \"description\" : \"Sentry secrets schema\" , \"type\" : \"object\" , \"properties\" : { \"access_token\" : { \"title\" : \"Access Token\" , \"type\" : \"string\" }, \"domain\" : { \"title\" : \"Domain\" , \"default\" : \"sentry.io\" , \"type\" : \"string\" } }, \"required\" : [ \"access_token\" ], \"additionalProperties\" : false } Setting up a SaaS Connector from a Template To create all the resources necessary to set up a SaaS Connector in one request, you can create a connector from a template. This creates a saas ConnectionConfig for you with your supplied name and description, with your supplied secrets . In the example below, we're creating a mailchimp saas connector, so you should supply the relevant mailchimp secrets . Your instance_key will become the identifier for the related DatasetConfig resource. By default, the saas connection config is enabled, with write access. POST /connection/instantiate/mailchimp 1 2 3 4 5 6 7 8 9 10 { \"name\" : \"My Mailchimp connector\" , \"description\" : \"Production Mailchimp Instance\" , \"secrets\" : { \"domain\" : \"{{mailchimp_domain}}\" , \"api_key\" : \"{{mailchimp_api_key}}\" , \"username\" : \"{{mailchimp_username}}\" }, \"instance_key\" : \"primary_mailchimp\" , }","title":"View Available Connection Types"},{"location":"guides/connection_types/#connection-types","text":"","title":"Connection Types"},{"location":"guides/connection_types/#available-connection-types","text":"To view a list of all available connection types, visit GET /api/v1/connection_type . This endpoint can be filtered with a search query param or a system_type query param and is subject to change. We include database options and third party API services with which fidesops can communicate. GET /api/v1/connection_type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 { \"items\" : [ { \"identifier\" : \"bigquery\" , \"type\" : \"database\" , \"human_readable\" : \"BigQuery\" }, { \"identifier\" : \"mariadb\" , \"type\" : \"database\" , \"human_readable\" : \"MariaDB\" }, { \"identifier\" : \"mongodb\" , \"type\" : \"database\" , \"human_readable\" : \"MongoDB\" }, { \"identifier\" : \"mssql\" , \"type\" : \"database\" , \"human_readable\" : \"Microsoft SQL Server\" }, { \"identifier\" : \"mysql\" , \"type\" : \"database\" , \"human_readable\" : \"MySQL\" }, { \"identifier\" : \"postgres\" , \"type\" : \"database\" , \"human_readable\" : \"PostgreSQL\" }, { \"identifier\" : \"redshift\" , \"type\" : \"database\" , \"human_readable\" : \"Amazon Redshift\" }, { \"identifier\" : \"snowflake\" , \"type\" : \"database\" , \"human_readable\" : \"Snowflake\" }, { \"identifier\" : \"adobe_campaign\" , \"type\" : \"saas\" , \"human_readable\" : \"Adobe Campaign\" }, { \"identifier\" : \"auth0\" , \"type\" : \"saas\" , \"human_readable\" : \"Auth0\" }, { \"identifier\" : \"datadog\" , \"type\" : \"saas\" , \"human_readable\" : \"Datadog\" }, { \"identifier\" : \"hubspot\" , \"type\" : \"saas\" , \"human_readable\" : \"HubSpot\" }, { \"identifier\" : \"mailchimp\" , \"type\" : \"saas\" , \"human_readable\" : \"Mailchimp\" }, { \"identifier\" : \"outreach\" , \"type\" : \"saas\" , \"human_readable\" : \"Outreach\" }, { \"identifier\" : \"salesforce\" , \"type\" : \"saas\" , \"human_readable\" : \"Salesforce\" }, { \"identifier\" : \"segment\" , \"type\" : \"saas\" , \"human_readable\" : \"Segment\" }, { \"identifier\" : \"sendgrid\" , \"type\" : \"saas\" , \"human_readable\" : \"SendGrid\" }, { \"identifier\" : \"sentry\" , \"type\" : \"saas\" , \"human_readable\" : \"Sentry\" }, { \"identifier\" : \"shopify\" , \"type\" : \"saas\" , \"human_readable\" : \"Shopify\" }, { \"identifier\" : \"stripe\" , \"type\" : \"saas\" , \"human_readable\" : \"Stripe\" }, { \"identifier\" : \"zendesk\" , \"type\" : \"saas\" , \"human_readable\" : \"Zendesk\" }, { \"identifier\" : \"manual_webhook\" , \"type\" : \"manual\" , \"human_readable\" : \"Manual Webhook\" } ], \"total\" : 23 , \"page\" : 1 , \"size\" : 50 }","title":"Available Connection Types"},{"location":"guides/connection_types/#required-connection-secrets","text":"To view the secrets needed to authenticate with a given connection, visit GET /api/v1/connection_type/<connection_type>/secret .","title":"Required Connection Secrets"},{"location":"guides/connection_types/#example","text":"GET /api/v1/connection_type/sentry/secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"title\" : \"sentry_schema\" , \"description\" : \"Sentry secrets schema\" , \"type\" : \"object\" , \"properties\" : { \"access_token\" : { \"title\" : \"Access Token\" , \"type\" : \"string\" }, \"domain\" : { \"title\" : \"Domain\" , \"default\" : \"sentry.io\" , \"type\" : \"string\" } }, \"required\" : [ \"access_token\" ], \"additionalProperties\" : false }","title":"Example"},{"location":"guides/connection_types/#setting-up-a-saas-connector-from-a-template","text":"To create all the resources necessary to set up a SaaS Connector in one request, you can create a connector from a template. This creates a saas ConnectionConfig for you with your supplied name and description, with your supplied secrets . In the example below, we're creating a mailchimp saas connector, so you should supply the relevant mailchimp secrets . Your instance_key will become the identifier for the related DatasetConfig resource. By default, the saas connection config is enabled, with write access. POST /connection/instantiate/mailchimp 1 2 3 4 5 6 7 8 9 10 { \"name\" : \"My Mailchimp connector\" , \"description\" : \"Production Mailchimp Instance\" , \"secrets\" : { \"domain\" : \"{{mailchimp_domain}}\" , \"api_key\" : \"{{mailchimp_api_key}}\" , \"username\" : \"{{mailchimp_username}}\" }, \"instance_key\" : \"primary_mailchimp\" , }","title":"Setting up a SaaS Connector from a Template"},{"location":"guides/data_rights_protocol/","text":"Data Rights Protocol The Data Rights Protocol (DRP) is a technical standard for exchanging data rights requests under regulations like the California Consumer Privacy Act (CCPA). As a Privacy Infrastructure Provider (PIP), fidesops conforms to the DRP standards to receive and process Data Rights Requests. The following endpoints and actions are available in fidesops for working within the DRP specifications. DRP Actions A DRP action may be defined when creating or editing a policy . These actions associate a fidesops policy with a DRP-standardized protocol for receiving and processing Data Rights Requests. A given action may only be associated to a single policy: PATCH /api/v1/policy 1 2 3 4 5 6 7 [ { \"name\" : \"User Email Address\" , \"key\" : \"user_email_address_policy\" , \"drp_action\" : \"access\" } ] Available actions The following actions may be associated to a policy via the drp_action attribute, which correspond to the DRP's set of supported rights . Action Use sale:opt_out Right to opt out of data sale sale:opt_in Reconsent, or opt-in to data sale deletion Right to Delete access Right to Know access:categories Right to Know access:specific Right to Know Endpoints Once a policy is associated with an action, the following DRP-standardized endpoints are available. Exercise The /exercise endpoint creates a new DRP privacy request. Fidesops will execute this request based on the policy associated to the DRP action specified in exercise . All identity information should be encapsulated in the provided identity field using RFC7515-encoded JSON Web Tokens . More about identity ecapsulation can be found in the DRP standard . POST /api/v1/drp/exercise 1 2 3 4 5 6 7 8 9 { \"meta\" : { \"version\" : \"0.5\" }, \"exercise\" : [ \"sale:opt-out\" ], \"identity\" : \"jwt\" , } Response 1 2 3 4 5 6 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"received_at\" : \"20210902T152725.403-0700\" , \"expected_by\" : \"20211015T152725.403-0700\" , \"status\" : \"open\" , } Status The current status of an existing privacy request may be returned via the /status endpoint, which must be queried using a privacy request ID. GET /api/v1/drp/status?request_id={privacy_request_id} 1 2 3 4 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"status\" : \"open\" , } Data Rights All data rights associated with existing policies may be returned via the /data-rights endpoint. Note that the v1 in the below URL does not correspond to DRP version, but instead corresponds to fidesops version. GET /api/v1/drp/data-rights 1 2 3 4 5 6 7 8 { \"version\" : \"0.5\" , \"api_base\" : null , \"actions\" : [ \"access\" ], \"user_relationships\" : null } Revoke You can revoke a pending privacy request via the /revoke endpoint. GET /api/v1/drp/revoke 1 2 3 4 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"reason\" : \"Accidentally submitted\" }","title":"Data Rights Protocol"},{"location":"guides/data_rights_protocol/#data-rights-protocol","text":"The Data Rights Protocol (DRP) is a technical standard for exchanging data rights requests under regulations like the California Consumer Privacy Act (CCPA). As a Privacy Infrastructure Provider (PIP), fidesops conforms to the DRP standards to receive and process Data Rights Requests. The following endpoints and actions are available in fidesops for working within the DRP specifications.","title":"Data Rights Protocol"},{"location":"guides/data_rights_protocol/#drp-actions","text":"A DRP action may be defined when creating or editing a policy . These actions associate a fidesops policy with a DRP-standardized protocol for receiving and processing Data Rights Requests. A given action may only be associated to a single policy: PATCH /api/v1/policy 1 2 3 4 5 6 7 [ { \"name\" : \"User Email Address\" , \"key\" : \"user_email_address_policy\" , \"drp_action\" : \"access\" } ]","title":"DRP Actions"},{"location":"guides/data_rights_protocol/#available-actions","text":"The following actions may be associated to a policy via the drp_action attribute, which correspond to the DRP's set of supported rights . Action Use sale:opt_out Right to opt out of data sale sale:opt_in Reconsent, or opt-in to data sale deletion Right to Delete access Right to Know access:categories Right to Know access:specific Right to Know","title":"Available actions"},{"location":"guides/data_rights_protocol/#endpoints","text":"Once a policy is associated with an action, the following DRP-standardized endpoints are available.","title":"Endpoints"},{"location":"guides/data_rights_protocol/#exercise","text":"The /exercise endpoint creates a new DRP privacy request. Fidesops will execute this request based on the policy associated to the DRP action specified in exercise . All identity information should be encapsulated in the provided identity field using RFC7515-encoded JSON Web Tokens . More about identity ecapsulation can be found in the DRP standard . POST /api/v1/drp/exercise 1 2 3 4 5 6 7 8 9 { \"meta\" : { \"version\" : \"0.5\" }, \"exercise\" : [ \"sale:opt-out\" ], \"identity\" : \"jwt\" , } Response 1 2 3 4 5 6 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"received_at\" : \"20210902T152725.403-0700\" , \"expected_by\" : \"20211015T152725.403-0700\" , \"status\" : \"open\" , }","title":"Exercise"},{"location":"guides/data_rights_protocol/#status","text":"The current status of an existing privacy request may be returned via the /status endpoint, which must be queried using a privacy request ID. GET /api/v1/drp/status?request_id={privacy_request_id} 1 2 3 4 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"status\" : \"open\" , }","title":"Status"},{"location":"guides/data_rights_protocol/#data-rights","text":"All data rights associated with existing policies may be returned via the /data-rights endpoint. Note that the v1 in the below URL does not correspond to DRP version, but instead corresponds to fidesops version. GET /api/v1/drp/data-rights 1 2 3 4 5 6 7 8 { \"version\" : \"0.5\" , \"api_base\" : null , \"actions\" : [ \"access\" ], \"user_relationships\" : null }","title":"Data Rights"},{"location":"guides/data_rights_protocol/#revoke","text":"You can revoke a pending privacy request via the /revoke endpoint. GET /api/v1/drp/revoke 1 2 3 4 { \"request_id\" : \"c789ff35-7644-4ceb-9981-4b35c264aac3\" , \"reason\" : \"Accidentally submitted\" }","title":"Revoke"},{"location":"guides/database_connectors/","text":"Connect to SQL and NoSQL Databases What is a connection? A connection links your databases to fidesops, so you can gather and update selected PII categories. Supported databases Fidesops supports connections to the following databases: PostgreSQL MongoDB MySQL MariaDB Microsoft SQLServer Amazon Redshift Snowflake Google BigQuery Timescale DB Other platforms will be added in future releases. Create a ConnectionConfig object The connection between fidesops and your database is represented by a ConnectionConfig object. To create a ConnectionConfig, you issue a request to the Create a ConnectionConfig operation, passing a payload that contains the properties listed below. name is a human-readable name for your database. key is a string token that uniquely identifies your ConnectionConfig object. If you don't supply a key , the name value, converted to snake-case, is used. For example, if the name is Application PostgreSQL DB , the converted key is application_postgresql_db . connection-type specifies the type of database. Valid values are postgres , mongodb , mysql , mariadb , mssql , redshift , snowflake , and bigquery . access sets the connection's permissions, one of \"read\" (fidesops may only read from your database) or \"write\" (fidesops can read from and write to your database). disabled determines whether the ConnectionConfig is active. If True, we skip running queries for any collection associated with that ConnectionConfig. description is an extra field to add further details about your connection. While the ConnectionConfig object contains meta information about the database, you'll notice that it doesn't actually identify the database itself. We'll get to that when we set the ConnectionConfig's \"secrets\". PostgreSQL PATCH api/v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"Application PostgreSQL DB\" , \"key\" : \"application_postgresql_db\" , \"connection_type\" : \"postgres\" , \"access\" : \"read\" } ] MongoDB PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Mongo DB\" , \"key\" : \"my_mongo_db\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"disabled\" : false } ] MySQL PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My MySQL DB\" , \"key\" : \"my_mysql_db\" , \"connection_type\" : \"mysql\" , \"access\" : \"write\" , \"disabled\" : false } ] MariaDB PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Maria DB\" , \"key\" : \"my_maria_db\" , \"connection_type\" : \"mariadb\" , \"access\" : \"write\" , \"disabled\" : false } ] MsSQL PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My MsSQL DB\" , \"key\" : \"my_mssql_db\" , \"connection_type\" : \"mssql\" , \"access\" : \"write\" , \"disabled\" : false } ] Manual connections PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 10 [ { \"name\" : \"Manual connector\" , \"key\" : \"manual_connector\" , \"connection_type\" : \"manual\" , \"access\" : \"read\" , \"disabled\" : false , \"description\" : \"Connector describing manual actions\" } ] TimescaleDB PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Timescale DB\" , \"key\" : \"my_timescaledb\" , \"connection_type\" : \"timescale\" , \"access\" : \"write\" , \"disabled\" : false } ] Set ConnectionConfig secrets After you create a ConnectionConfig, you explain how to connect to it by setting its \"secrets\": host, port, user, and password (note that the secrets used are specific to the DB connector). You do this by creating a ConnectionConfig Secrets object by calling the Set a ConnectionConfig's Secrets operation. You can set the object's attributes separately, or supply a single url string that encodes them all. If you set the verify query parameter to true , the operation will test the connection by issuing a trivial request to the database. The test_status response property announces the success of the connection attempt as succeeded or failed . If the attempt has failed, the failure_reason property gives further details about the failure. To skip the connection test, set verify to false . Note: fidesops encrypts all ConnectionConfig secrets values before they're stored. Set the secrets separately This example sets the database secrets through separate properties and then tests the connection. PUT /api/v1/connection/application-postgresql-db/secret?verify=true 1 2 3 4 5 6 7 { \"host\" : \"host.docker.internal\" , \"port\" : 5432 , \"dbname\" : \"postgres_example\" , \"username\" : \"postgres\" , \"password\" : \"postgres\" } Set the secrets as a URL This example sets the database secrets as a single url property, and skips the connection test. PUT api/v1/connection/my_mongo_db/secret?verify=false 1 2 3 { \"url\" : \"mongodb://mongo_user:mongo_pass@mongodb_example/mongo_test\" } Amazon Redshift This Amazon Redshift example sets the database secrets as a url property and a db_schema property. Redshift databases have one or more schemas, with the default being named public . If you need to set a different schema, specify db_schema for Redshift, and it will be set as the search_path when querying. PUT api/v1/connection/my_redshift_db/secret 1 2 3 4 { \"url\" : \"redshift+psycopg2://username@host.amazonaws.com:5439/database\" , \"db_schema\" : \"my_test_schema\" } Google BigQuery For Google BigQuery, there are 2 items needed for secrets: dataset - Name of your dataset. BigQuery datasets are top-level containers (within a project) that are used to organize and control access to your tables and views. keyfile_creds - Credentials from your service account JSON keyfile, accessible for download from the GCP console. Here's an example of what this looks like: PUT api/v1/connection/my_bigquery_db/secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"dataset\" : \"some-dataset\" , \"keyfile_creds\" : { \"type\" : \"service_account\" , \"project_id\" : \"project-12345\" , \"private_key_id\" : \"qo28cy4nlwu\" , \"private_key\" : \"-----BEGIN PRIVATE KEY-----\\nqi2unhflhncflkjas\\nkqiu34c\\n-----END PRIVATE KEY-----\\n\" , \"client_email\" : \"something@project-12345.iam.gserviceaccount.com\" , \"client_id\" : \"287345028734538\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://oauth2.googleapis.com/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/something%40project-12345.iam.gserviceaccount.com\" } } Test your connection You can verify that a ConnectionConfig's secrets are valid at any time by calling the Test a ConnectionConfig's Secrets operation: 1 GET /api/v1/connection/application-postgresql-db/test Once again, the test_status and failure_reason properties describe the success or failure of the test. If the test failed, you should adjust the ConnectionConfig Secrets properties through additional calls to Set a ConnectionConfig's Secrets Connection succeeded 1 2 3 4 5 { \"msg\" : \"Test completed for ConnectionConfig with key: app_postgres_db.\" , \"test_status\" : \"succeeded\" , \"failure_reason\" : null } Connection failed 1 2 3 4 5 { \"msg\" : \"Secrets updated for ConnectionConfig with key: app_mongo_db.\" , \"test_status\" : \"failed\" , \"failure_reason\" : \"Operation Failure connecting to MongoDB.\" } Associate a Dataset Once you have a working ConnectionConfig, it can be associated to an existing dataset by calling the /dataset endpoint, with a JSON version of your dataset as the request body: PATCH /api/v1/connection/my_connection_key/dataset 1 2 3 4 5 6 [{ \"fides_key\" : \"example_test_dataset\" , \"name\" : \"Example Test Dataset\" , \"description\" : \"Example of a dataset containing a variety of related tables like customers, products, addresses, etc.\" , \"collections\" : [ ... ] }] Filtering ConnectionConfigs Current available filters are the connection_type and whether the connection is disabled . Connection type filter Including multiple connection_type query params and values will result in a query that looks for any connections with that type. GET api/v1//connection/?connection_type=mariadb&connection_type=postgres 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"items\" : [ { \"name\" : \"Application Maria DB\" , \"key\" : \"app_mariadb_db\" , \"description\" : null , \"connection_type\" : \"mariadb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:21:02.353226+00:00\" , \"updated_at\" : \"2022-06-16T22:21:02.353226+00:00\" , \"disabled\" : false , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null }, { \"name\" : \"Application PostgreSQL DB\" , \"key\" : \"app_postgres_db\" , \"description\" : \"postgres backup\" , \"connection_type\" : \"postgres\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:24.972539+00:00\" , \"updated_at\" : \"2022-06-16T22:20:24.972539+00:00\" , \"disabled\" : false , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 2 , \"page\" : 1 , \"size\" : 50 } Disabled filter The disabled filter can show which datastores are skipped as part of privacy request execution. GET api/v1/connection/?disabled=true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } Testing_Status filter The testing_status filter queries on the status of the last successful test: GET api/v1/connection/?test_status=false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : 2022-06-16 T 22 : 20 : 34.122212+00 : 00 , \"last_test_succeeded\" : false } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } System_Status filter The system_status filter surfaces either database or saas -type connectors: GET api/v1/connection/?system_type=database 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : 2022-06-16 T 22 : 20 : 34.122212+00 : 00 , \"last_test_succeeded\" : false } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } Search a ConnectionConfig You can search the name , key , and description fields of your ConnectionConfigs with the search query parameter. GET /api/v1/connection/?search=application mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"items\" : [ { \"name\" : \"Application MySQL DB\" , \"key\" : \"app_mysql_db\" , \"description\" : \"My Backup MySQL DB\" , \"connection_type\" : \"mysql\" , \"access\" : \"read\" , \"created_at\" : \"2022-06-13T18:03:28.404091+00:00\" , \"updated_at\" : \"2022-06-13T18:03:28.404091+00:00\" , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } How do ConnectionConfigs differ from Datasets? A Dataset is an annotation of your database schema; it describes the PII category (or Data Categories) for each field that the database contains. A ConnectionConfig holds the secrets to connect to the database. Each Dataset has a foreign key to a ConnectionConfig. After fidesops connects to your database, it generates valid queries by consulting the annotations in the Dataset. Here is an example of how a \"person\" table in your PostgreSQL database might map to a fidesops Dataset: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Person : id : str name : str email : str dataset : - fides_key : my_app name : App Dataset description : ... collections : - name : person fields : - name : name data_categories : [ user.contact.name ] - name : email data_categories : [ user.contact.email ] - name : id data_categories : [ system.operations ] See Configuring Datasets for more information.","title":"Connect to Databases"},{"location":"guides/database_connectors/#connect-to-sql-and-nosql-databases","text":"","title":"Connect to SQL and NoSQL Databases"},{"location":"guides/database_connectors/#what-is-a-connection","text":"A connection links your databases to fidesops, so you can gather and update selected PII categories.","title":"What is a connection?"},{"location":"guides/database_connectors/#supported-databases","text":"Fidesops supports connections to the following databases: PostgreSQL MongoDB MySQL MariaDB Microsoft SQLServer Amazon Redshift Snowflake Google BigQuery Timescale DB Other platforms will be added in future releases.","title":"Supported databases"},{"location":"guides/database_connectors/#create-a-connectionconfig-object","text":"The connection between fidesops and your database is represented by a ConnectionConfig object. To create a ConnectionConfig, you issue a request to the Create a ConnectionConfig operation, passing a payload that contains the properties listed below. name is a human-readable name for your database. key is a string token that uniquely identifies your ConnectionConfig object. If you don't supply a key , the name value, converted to snake-case, is used. For example, if the name is Application PostgreSQL DB , the converted key is application_postgresql_db . connection-type specifies the type of database. Valid values are postgres , mongodb , mysql , mariadb , mssql , redshift , snowflake , and bigquery . access sets the connection's permissions, one of \"read\" (fidesops may only read from your database) or \"write\" (fidesops can read from and write to your database). disabled determines whether the ConnectionConfig is active. If True, we skip running queries for any collection associated with that ConnectionConfig. description is an extra field to add further details about your connection. While the ConnectionConfig object contains meta information about the database, you'll notice that it doesn't actually identify the database itself. We'll get to that when we set the ConnectionConfig's \"secrets\".","title":"Create a ConnectionConfig object"},{"location":"guides/database_connectors/#postgresql","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"Application PostgreSQL DB\" , \"key\" : \"application_postgresql_db\" , \"connection_type\" : \"postgres\" , \"access\" : \"read\" } ]","title":"PostgreSQL"},{"location":"guides/database_connectors/#mongodb","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Mongo DB\" , \"key\" : \"my_mongo_db\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"disabled\" : false } ]","title":"MongoDB"},{"location":"guides/database_connectors/#mysql","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My MySQL DB\" , \"key\" : \"my_mysql_db\" , \"connection_type\" : \"mysql\" , \"access\" : \"write\" , \"disabled\" : false } ]","title":"MySQL"},{"location":"guides/database_connectors/#mariadb","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Maria DB\" , \"key\" : \"my_maria_db\" , \"connection_type\" : \"mariadb\" , \"access\" : \"write\" , \"disabled\" : false } ]","title":"MariaDB"},{"location":"guides/database_connectors/#mssql","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My MsSQL DB\" , \"key\" : \"my_mssql_db\" , \"connection_type\" : \"mssql\" , \"access\" : \"write\" , \"disabled\" : false } ]","title":"MsSQL"},{"location":"guides/database_connectors/#manual-connections","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 10 [ { \"name\" : \"Manual connector\" , \"key\" : \"manual_connector\" , \"connection_type\" : \"manual\" , \"access\" : \"read\" , \"disabled\" : false , \"description\" : \"Connector describing manual actions\" } ]","title":"Manual connections"},{"location":"guides/database_connectors/#timescaledb","text":"PATCH api/v1/connection 1 2 3 4 5 6 7 8 9 [ { \"name\" : \"My Timescale DB\" , \"key\" : \"my_timescaledb\" , \"connection_type\" : \"timescale\" , \"access\" : \"write\" , \"disabled\" : false } ]","title":"TimescaleDB"},{"location":"guides/database_connectors/#set-connectionconfig-secrets","text":"After you create a ConnectionConfig, you explain how to connect to it by setting its \"secrets\": host, port, user, and password (note that the secrets used are specific to the DB connector). You do this by creating a ConnectionConfig Secrets object by calling the Set a ConnectionConfig's Secrets operation. You can set the object's attributes separately, or supply a single url string that encodes them all. If you set the verify query parameter to true , the operation will test the connection by issuing a trivial request to the database. The test_status response property announces the success of the connection attempt as succeeded or failed . If the attempt has failed, the failure_reason property gives further details about the failure. To skip the connection test, set verify to false . Note: fidesops encrypts all ConnectionConfig secrets values before they're stored.","title":"Set ConnectionConfig secrets"},{"location":"guides/database_connectors/#set-the-secrets-separately","text":"This example sets the database secrets through separate properties and then tests the connection. PUT /api/v1/connection/application-postgresql-db/secret?verify=true 1 2 3 4 5 6 7 { \"host\" : \"host.docker.internal\" , \"port\" : 5432 , \"dbname\" : \"postgres_example\" , \"username\" : \"postgres\" , \"password\" : \"postgres\" }","title":"Set the secrets separately"},{"location":"guides/database_connectors/#set-the-secrets-as-a-url","text":"This example sets the database secrets as a single url property, and skips the connection test. PUT api/v1/connection/my_mongo_db/secret?verify=false 1 2 3 { \"url\" : \"mongodb://mongo_user:mongo_pass@mongodb_example/mongo_test\" }","title":"Set the secrets as a URL"},{"location":"guides/database_connectors/#amazon-redshift","text":"This Amazon Redshift example sets the database secrets as a url property and a db_schema property. Redshift databases have one or more schemas, with the default being named public . If you need to set a different schema, specify db_schema for Redshift, and it will be set as the search_path when querying. PUT api/v1/connection/my_redshift_db/secret 1 2 3 4 { \"url\" : \"redshift+psycopg2://username@host.amazonaws.com:5439/database\" , \"db_schema\" : \"my_test_schema\" }","title":"Amazon Redshift"},{"location":"guides/database_connectors/#google-bigquery","text":"For Google BigQuery, there are 2 items needed for secrets: dataset - Name of your dataset. BigQuery datasets are top-level containers (within a project) that are used to organize and control access to your tables and views. keyfile_creds - Credentials from your service account JSON keyfile, accessible for download from the GCP console. Here's an example of what this looks like: PUT api/v1/connection/my_bigquery_db/secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"dataset\" : \"some-dataset\" , \"keyfile_creds\" : { \"type\" : \"service_account\" , \"project_id\" : \"project-12345\" , \"private_key_id\" : \"qo28cy4nlwu\" , \"private_key\" : \"-----BEGIN PRIVATE KEY-----\\nqi2unhflhncflkjas\\nkqiu34c\\n-----END PRIVATE KEY-----\\n\" , \"client_email\" : \"something@project-12345.iam.gserviceaccount.com\" , \"client_id\" : \"287345028734538\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://oauth2.googleapis.com/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/something%40project-12345.iam.gserviceaccount.com\" } }","title":"Google BigQuery"},{"location":"guides/database_connectors/#test-your-connection","text":"You can verify that a ConnectionConfig's secrets are valid at any time by calling the Test a ConnectionConfig's Secrets operation: 1 GET /api/v1/connection/application-postgresql-db/test Once again, the test_status and failure_reason properties describe the success or failure of the test. If the test failed, you should adjust the ConnectionConfig Secrets properties through additional calls to Set a ConnectionConfig's Secrets","title":"Test your connection"},{"location":"guides/database_connectors/#connection-succeeded","text":"1 2 3 4 5 { \"msg\" : \"Test completed for ConnectionConfig with key: app_postgres_db.\" , \"test_status\" : \"succeeded\" , \"failure_reason\" : null }","title":"Connection succeeded"},{"location":"guides/database_connectors/#connection-failed","text":"1 2 3 4 5 { \"msg\" : \"Secrets updated for ConnectionConfig with key: app_mongo_db.\" , \"test_status\" : \"failed\" , \"failure_reason\" : \"Operation Failure connecting to MongoDB.\" }","title":"Connection failed"},{"location":"guides/database_connectors/#associate-a-dataset","text":"Once you have a working ConnectionConfig, it can be associated to an existing dataset by calling the /dataset endpoint, with a JSON version of your dataset as the request body: PATCH /api/v1/connection/my_connection_key/dataset 1 2 3 4 5 6 [{ \"fides_key\" : \"example_test_dataset\" , \"name\" : \"Example Test Dataset\" , \"description\" : \"Example of a dataset containing a variety of related tables like customers, products, addresses, etc.\" , \"collections\" : [ ... ] }]","title":"Associate a Dataset"},{"location":"guides/database_connectors/#filtering-connectionconfigs","text":"Current available filters are the connection_type and whether the connection is disabled .","title":"Filtering ConnectionConfigs"},{"location":"guides/database_connectors/#connection-type-filter","text":"Including multiple connection_type query params and values will result in a query that looks for any connections with that type. GET api/v1//connection/?connection_type=mariadb&connection_type=postgres 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"items\" : [ { \"name\" : \"Application Maria DB\" , \"key\" : \"app_mariadb_db\" , \"description\" : null , \"connection_type\" : \"mariadb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:21:02.353226+00:00\" , \"updated_at\" : \"2022-06-16T22:21:02.353226+00:00\" , \"disabled\" : false , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null }, { \"name\" : \"Application PostgreSQL DB\" , \"key\" : \"app_postgres_db\" , \"description\" : \"postgres backup\" , \"connection_type\" : \"postgres\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:24.972539+00:00\" , \"updated_at\" : \"2022-06-16T22:20:24.972539+00:00\" , \"disabled\" : false , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 2 , \"page\" : 1 , \"size\" : 50 }","title":"Connection type filter"},{"location":"guides/database_connectors/#disabled-filter","text":"The disabled filter can show which datastores are skipped as part of privacy request execution. GET api/v1/connection/?disabled=true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Disabled filter"},{"location":"guides/database_connectors/#testing_status-filter","text":"The testing_status filter queries on the status of the last successful test: GET api/v1/connection/?test_status=false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : 2022-06-16 T 22 : 20 : 34.122212+00 : 00 , \"last_test_succeeded\" : false } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Testing_Status filter"},{"location":"guides/database_connectors/#system_status-filter","text":"The system_status filter surfaces either database or saas -type connectors: GET api/v1/connection/?system_type=database 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"name\" : \"My Mongo DB\" , \"key\" : \"app_mongo_db\" , \"description\" : \"Primary Mongo DB\" , \"connection_type\" : \"mongodb\" , \"access\" : \"write\" , \"created_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"updated_at\" : \"2022-06-16T22:20:34.122212+00:00\" , \"disabled\" : true , \"last_test_timestamp\" : 2022-06-16 T 22 : 20 : 34.122212+00 : 00 , \"last_test_succeeded\" : false } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"System_Status filter"},{"location":"guides/database_connectors/#search-a-connectionconfig","text":"You can search the name , key , and description fields of your ConnectionConfigs with the search query parameter. GET /api/v1/connection/?search=application mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"items\" : [ { \"name\" : \"Application MySQL DB\" , \"key\" : \"app_mysql_db\" , \"description\" : \"My Backup MySQL DB\" , \"connection_type\" : \"mysql\" , \"access\" : \"read\" , \"created_at\" : \"2022-06-13T18:03:28.404091+00:00\" , \"updated_at\" : \"2022-06-13T18:03:28.404091+00:00\" , \"last_test_timestamp\" : null , \"last_test_succeeded\" : null } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Search a ConnectionConfig"},{"location":"guides/database_connectors/#how-do-connectionconfigs-differ-from-datasets","text":"A Dataset is an annotation of your database schema; it describes the PII category (or Data Categories) for each field that the database contains. A ConnectionConfig holds the secrets to connect to the database. Each Dataset has a foreign key to a ConnectionConfig. After fidesops connects to your database, it generates valid queries by consulting the annotations in the Dataset. Here is an example of how a \"person\" table in your PostgreSQL database might map to a fidesops Dataset: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Person : id : str name : str email : str dataset : - fides_key : my_app name : App Dataset description : ... collections : - name : person fields : - name : name data_categories : [ user.contact.name ] - name : email data_categories : [ user.contact.email ] - name : id data_categories : [ system.operations ] See Configuring Datasets for more information.","title":"How do ConnectionConfigs differ from Datasets?"},{"location":"guides/datasets/","text":"What is a Dataset? A fidesops Dataset is the configuration you provide for a database or other queryable datastore. We use the term Dataset and not database to emphasize that this will ultimately be applicable to a wide variety of datastores beyond traditional databases. With Datasets, a collection is the term used for a SQL table, mongo database collection, or any other single coherent set values. Configure a Dataset Beyond collection and field names, fidesops needs some additional information to fully configure a Dataset. Let's look at a simple example database, and how it would be translated into a configuration in fidesops. An example database Here we have a database of customers and addresses (the example is a bit simplified from an actual SQL schema). We have a customer table that has a foreign key of address_id to an address table: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE TABLE CUSTOMER ( id INT PRIMARY KEY , name VARCHAR , email VARCHAR , address_id int REFERENCES ADDRESS ( id ) ); CREATE TABLE ADDRESS ( id INT PRIMARY KEY , street VARCHAR , city VARCHAR , state VARCHAR , zip VARCHAR ); A fidesops Dataset consists of a declaration of fields, with metadata describing how those fields are related. We use the information about their relationship to navigate between different collections. The Dataset declaration for the above schema looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : address fields : - name : id data_categories : [ system.operations ] fidesops_meta : primary_key : True - name : street data_categories : [ user.contact.address.street ] fidesops_meta : data_type : string - name : city data_categories : [ user.contact.address.city ] fidesops_meta : data_type : string - name : state data_categories : [ user.contact.address.state ] fidesops_meta : data_type : string - name : zip data_categories : [ user.contact.address.postal_code ] fidesops_meta : data_type : string - name : customer after : mydatabase.address fields : - name : address_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mydatabase field : address.id direction : to - name : created data_categories : [ system.operations ] - name : email data_categories : [ user.contact.email ] fidesops_meta : identity : email data_type : string - name : id data_categories : [ user.unique_id ] fidesops_meta : primary_key : True - name : name data_categories : [ user.name ] fidesops_meta : data_type : string Dataset members fides_key : A unique identifier name for the Dataset collections : A list of addressable collections. after : An optional list of Datasets that must be fully traversed before this Dataset is queried. Collection members name : The name of the collection in your configuration must correspond to the name used for it in your datastore, since it will be used to generate query and update statements. fields : A list of addressable fields in the collection. Specifying the fields in the collection tells fidesops what data to address in the collection. after : An optional list of collections (in the form [dataset name].[collection name] ) that must be fully traversed before this collection is queried. Field members name : The name of the field will be used to generate query and update statements. Please note that fidesops does not do automated schema discovery. It is only aware of the fields you declare. This means that the only fields that will be addressed and retrieved by fidesops queries are the fields you declare. data_categories : Annotating data_categories connects fields to policy rules, and determines which actions apply to each field. For more information see Policies fidesops_meta : The fidesops_meta section specifies some additional fields that control how fidesops manages your data: references : A declaration of relationships between collections. Where the configuration declares a reference to mydatabase:address:id it means fidesops will use the values from mydatabase.address.id to search for related values in customer . Unlike the SQL declaration, this is not an enforceable relationship, but simply a statement of which values are connected. In the example above, the references from the customer field to mydatabase.address.id is analogous to a SQL statement customer id REFERENCES address.id , with the exception that any Dataset and collection can be referenced. The relationship requires you to specify the Dataset as well as the collection for relationships, because you may declare a configuration with multiple Datasets, where values in one collection in the first Dataset are searched using values found in the second Dataset. field : The specified linked field, using the syntax [dataset name].[collection name ].[field name] . identity : Signifies that this field is an identity value that can be used as the root for a traversal See graph traversal direction ( Optional ): Accepted values are from or to . This determines how fidesops uses the relationships to discover data. If the direction is to , fidesops will only use data in the source collection to discover data in the referenced collection. If the direction is from , fidesops will only use data in the referenced collection to discover data in the source collection. If the direction is omitted, fidesops will traverse the relation in whatever direction works to discover all related data. primary_key ( Optional ): A boolean value that means that fidesops will treat this field as a unique row identifier for generating update statements. If no primary key is specified for any field on a collection, no updates will be generated against that collection. If multiple fields are marked as primary keys the combination of their values will be treated as a combined key. In SQL terms, we'd issue a query that looked like SELECT ... FROM TABLE WHERE primary_key_name_1 = value1 AND primary_key_name_2 = value2 . data_type ( Optional ): An indication of the type of data held by this field. Data types are used to convert values to the appropriate type when those values are used in queries. This is especially necessary when using data of one type to help locate data of another type. Data types are also used to generate the appropriate masked value when running erasures, since fidesops needs to know the type of data expected by the field in order to generate an appropriate masked value. Available data types are string , integer , float , boolean , and object_id . object types are also supported for MongoDB. length ( Optional ): An indicator of field length. return_all_elements : ( Optional ): For array entrypoint fields, specify whether the query should return/mask all fields, or just matching fields. By default, we just return/mask matching fields. return_all_elements=true will return/mask the entire array. Configure a manual Dataset Not all data can be automatically retrieved. When services have no external API, or when user data is held in a physical location, you can define a Dataset to describe the types of manual fields you plan to upload, as well as any dependencies between these manual collections and other collections. When a manual Dataset is defined, an in-progress access request will pause until the data is added manually, and then resume execution. Describe a manual Dataset In the following example, the Manual Dataset contains one storage_unit collection. email is defined as the unit's identity , which will then be used to retrieve the box_id in the storage unit. To add a Manual Dataset, first create a Manual ConnectionConfig . The following Manual Dataset can then be added to the new ConnectionConfig: PATCH {{host}}/connection/ /dataset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dataset : - fides_key : manual_input name : Manual Dataset description : Example of a Dataset whose data must be manually retrieved collections : - name : storage_unit fields : - name : box_id data_categories : [ user ] fidesops_meta : primary_key : true - name : email data_categories : [ user.contact.email ] fidesops_meta : identity : email data_type : string Resume a paused access privacy request A privacy request will pause execution when it reaches a manual collection in an access request. An administrator should manually retrieve the data and send it in a POST request. The fields should match the fields on the paused collection. Erasure requests with manual collections will also need data manually added as well. POST {{host}}/privacy-request/{{privacy_request_id}}/manual_input 1 2 3 4 [{ \"box_id\" : 5 , \"email\" : \"customer-1@example.com\" }] If no manual data can be found, simply pass in an empty list to resume the privacy request: 1 [] Resume a paused erasure privacy request A privacy request will pause execution when it reaches a manual collection in an erasure request. An administrator should manually mask the records in question and send confirmation of the rows affected in a POST request. POST {{host}}/privacy-request/{{privacy_request_id}}/erasure_confirm 1 { \"row_count\" : 2 } If no manual data was destroyed, pass in a count of 0 to resume the privacy request: 1 { \"row_count\" : 0 }","title":"Define Datasets"},{"location":"guides/datasets/#what-is-a-dataset","text":"A fidesops Dataset is the configuration you provide for a database or other queryable datastore. We use the term Dataset and not database to emphasize that this will ultimately be applicable to a wide variety of datastores beyond traditional databases. With Datasets, a collection is the term used for a SQL table, mongo database collection, or any other single coherent set values.","title":"What is a Dataset?"},{"location":"guides/datasets/#configure-a-dataset","text":"Beyond collection and field names, fidesops needs some additional information to fully configure a Dataset. Let's look at a simple example database, and how it would be translated into a configuration in fidesops.","title":"Configure a Dataset"},{"location":"guides/datasets/#an-example-database","text":"Here we have a database of customers and addresses (the example is a bit simplified from an actual SQL schema). We have a customer table that has a foreign key of address_id to an address table: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE TABLE CUSTOMER ( id INT PRIMARY KEY , name VARCHAR , email VARCHAR , address_id int REFERENCES ADDRESS ( id ) ); CREATE TABLE ADDRESS ( id INT PRIMARY KEY , street VARCHAR , city VARCHAR , state VARCHAR , zip VARCHAR ); A fidesops Dataset consists of a declaration of fields, with metadata describing how those fields are related. We use the information about their relationship to navigate between different collections. The Dataset declaration for the above schema looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 dataset : - fides_key : mydatabase name : internal database description : our internal database of customer data collections : - name : address fields : - name : id data_categories : [ system.operations ] fidesops_meta : primary_key : True - name : street data_categories : [ user.contact.address.street ] fidesops_meta : data_type : string - name : city data_categories : [ user.contact.address.city ] fidesops_meta : data_type : string - name : state data_categories : [ user.contact.address.state ] fidesops_meta : data_type : string - name : zip data_categories : [ user.contact.address.postal_code ] fidesops_meta : data_type : string - name : customer after : mydatabase.address fields : - name : address_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mydatabase field : address.id direction : to - name : created data_categories : [ system.operations ] - name : email data_categories : [ user.contact.email ] fidesops_meta : identity : email data_type : string - name : id data_categories : [ user.unique_id ] fidesops_meta : primary_key : True - name : name data_categories : [ user.name ] fidesops_meta : data_type : string","title":"An example database"},{"location":"guides/datasets/#dataset-members","text":"fides_key : A unique identifier name for the Dataset collections : A list of addressable collections. after : An optional list of Datasets that must be fully traversed before this Dataset is queried.","title":"Dataset members"},{"location":"guides/datasets/#collection-members","text":"name : The name of the collection in your configuration must correspond to the name used for it in your datastore, since it will be used to generate query and update statements. fields : A list of addressable fields in the collection. Specifying the fields in the collection tells fidesops what data to address in the collection. after : An optional list of collections (in the form [dataset name].[collection name] ) that must be fully traversed before this collection is queried.","title":"Collection members"},{"location":"guides/datasets/#field-members","text":"name : The name of the field will be used to generate query and update statements. Please note that fidesops does not do automated schema discovery. It is only aware of the fields you declare. This means that the only fields that will be addressed and retrieved by fidesops queries are the fields you declare. data_categories : Annotating data_categories connects fields to policy rules, and determines which actions apply to each field. For more information see Policies fidesops_meta : The fidesops_meta section specifies some additional fields that control how fidesops manages your data: references : A declaration of relationships between collections. Where the configuration declares a reference to mydatabase:address:id it means fidesops will use the values from mydatabase.address.id to search for related values in customer . Unlike the SQL declaration, this is not an enforceable relationship, but simply a statement of which values are connected. In the example above, the references from the customer field to mydatabase.address.id is analogous to a SQL statement customer id REFERENCES address.id , with the exception that any Dataset and collection can be referenced. The relationship requires you to specify the Dataset as well as the collection for relationships, because you may declare a configuration with multiple Datasets, where values in one collection in the first Dataset are searched using values found in the second Dataset. field : The specified linked field, using the syntax [dataset name].[collection name ].[field name] . identity : Signifies that this field is an identity value that can be used as the root for a traversal See graph traversal direction ( Optional ): Accepted values are from or to . This determines how fidesops uses the relationships to discover data. If the direction is to , fidesops will only use data in the source collection to discover data in the referenced collection. If the direction is from , fidesops will only use data in the referenced collection to discover data in the source collection. If the direction is omitted, fidesops will traverse the relation in whatever direction works to discover all related data. primary_key ( Optional ): A boolean value that means that fidesops will treat this field as a unique row identifier for generating update statements. If no primary key is specified for any field on a collection, no updates will be generated against that collection. If multiple fields are marked as primary keys the combination of their values will be treated as a combined key. In SQL terms, we'd issue a query that looked like SELECT ... FROM TABLE WHERE primary_key_name_1 = value1 AND primary_key_name_2 = value2 . data_type ( Optional ): An indication of the type of data held by this field. Data types are used to convert values to the appropriate type when those values are used in queries. This is especially necessary when using data of one type to help locate data of another type. Data types are also used to generate the appropriate masked value when running erasures, since fidesops needs to know the type of data expected by the field in order to generate an appropriate masked value. Available data types are string , integer , float , boolean , and object_id . object types are also supported for MongoDB. length ( Optional ): An indicator of field length. return_all_elements : ( Optional ): For array entrypoint fields, specify whether the query should return/mask all fields, or just matching fields. By default, we just return/mask matching fields. return_all_elements=true will return/mask the entire array.","title":"Field members"},{"location":"guides/datasets/#configure-a-manual-dataset","text":"Not all data can be automatically retrieved. When services have no external API, or when user data is held in a physical location, you can define a Dataset to describe the types of manual fields you plan to upload, as well as any dependencies between these manual collections and other collections. When a manual Dataset is defined, an in-progress access request will pause until the data is added manually, and then resume execution.","title":"Configure a manual Dataset"},{"location":"guides/datasets/#describe-a-manual-dataset","text":"In the following example, the Manual Dataset contains one storage_unit collection. email is defined as the unit's identity , which will then be used to retrieve the box_id in the storage unit. To add a Manual Dataset, first create a Manual ConnectionConfig . The following Manual Dataset can then be added to the new ConnectionConfig: PATCH {{host}}/connection/ /dataset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dataset : - fides_key : manual_input name : Manual Dataset description : Example of a Dataset whose data must be manually retrieved collections : - name : storage_unit fields : - name : box_id data_categories : [ user ] fidesops_meta : primary_key : true - name : email data_categories : [ user.contact.email ] fidesops_meta : identity : email data_type : string","title":"Describe a manual Dataset"},{"location":"guides/datasets/#resume-a-paused-access-privacy-request","text":"A privacy request will pause execution when it reaches a manual collection in an access request. An administrator should manually retrieve the data and send it in a POST request. The fields should match the fields on the paused collection. Erasure requests with manual collections will also need data manually added as well. POST {{host}}/privacy-request/{{privacy_request_id}}/manual_input 1 2 3 4 [{ \"box_id\" : 5 , \"email\" : \"customer-1@example.com\" }] If no manual data can be found, simply pass in an empty list to resume the privacy request: 1 []","title":"Resume a paused access privacy request"},{"location":"guides/datasets/#resume-a-paused-erasure-privacy-request","text":"A privacy request will pause execution when it reaches a manual collection in an erasure request. An administrator should manually mask the records in question and send confirmation of the rows affected in a POST request. POST {{host}}/privacy-request/{{privacy_request_id}}/erasure_confirm 1 { \"row_count\" : 2 } If no manual data was destroyed, pass in a count of 0 to resume the privacy request: 1 { \"row_count\" : 0 }","title":"Resume a paused erasure privacy request"},{"location":"guides/email_communications/","text":"Configure Automatic Emails What is a fidesops Email Connection? Fidesops supports configuring third party email servers to handle outbound communications. Supported modes of use: Subject Identity Verification - sends a verification code to the user's email address prior to processing a subject request. For more information on identity verification, see the Privacy Requests guide. Erasure Request Email Fulfillment - sends an email to configured third parties to process erasures for a given data subject. See creating email Connectors for more information. Privacy Request Receipt Notification - sends an email to user's email address with privacy request receipt notification. Privacy Request Review Notification - sends an email to user's email address upon privacy request review, including rejection reason if applicable. Privacy Request Completion Notification - sends an email to user's email address with privacy request completion notification, including a download link to data package, for access requests. For more information on request completion notification, see the Privacy Requests guide. Prerequisites Fidesops currently supports Mailgun for email integrations. Ensure you register or use an existing Mailgun account in order to get up and running with email communications. Generate a Mailgun Domain Sending Key Follow the Mailgun documentation to create a new Domain Sending Key for fidesops. Note Mailgun automatically generates a primary account API key when you sign up for an account. This key allows you to perform all CRUD operations via Mailgun's API endpoints, and for any of your sending domains. For security purposes, using a new domain sending key is recommended over your primary API key. Configuration Create the email config POST api/v1/email/config 1 2 3 4 5 6 7 8 { \"key\" : \"{{email_config_key}}\" , \"name\" : \"mailgun\" , \"service_type\" : \"mailgun\" , \"details\" : { \"domain\" : \"your.mailgun.domain\" } } Field Description key Optional. A unique key used to manage your email config. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email config. service_type The email service to configure. Currently, fidesops supports mailgun . details A dict of key/val config vars specific to Mailgun. domain Your unique Mailgun domain. is_eu_domain Optional. A boolean that denotes whether your Mailgun domain was created in the EU region. Defaults to False . api_version Optional. A string that denotes the API version. Defaults to v3 . Add the email configuration secrets POST api/v1/email/config/{email_config_key}/secret 1 2 3 { \"mailgun_api_key\" : \"nc123849ycnpq98fnu\" } Field Description mailgun_api_key Your Mailgun Domain Sending Key. Email third party services to mask data Once your email server is configured, you can create an email connector to send automatic erasure requests to third-party services. Fidesops will gather details about each collection described in the connector, and send a single email to the service after all collections have been visited. Note Fidesops does not collect confirmation that the erasure was completed by the third party. Create the connector Ensure you have created your email configuration prior to creating a new email connector. PATCH api/v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"Email Connection Config\" , \"key\" : \"third_party_email_connector\" , \"connection_type\" : \"email\" , \"access\" : \"write\" } ] Field Description key A unique key used to manage your email connector. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email connector. connection_type Must be email to create a new email connector. access Email connectors must be given write access in order to send an email. Configure notifications Once your email connector is created, configure any outbound email addresses: PUT api/v1/connection/{email_connection_config_key}/secret 1 2 3 4 { \"test_email\" : \"my_email@example.com\" , \"to_email\" : \"third_party@example.com\" } Field Description {email_connection_config_key} The unique key that represents the email connection to use. to_email The user that will be notified via email to complete an erasure request. Only one to_email is supported at this time. test_email Optional. An email to which you have access for verifying your setup. If your email configuration is working, you will receive an email with mock data similar to the one sent to third-party services. Configure the dataset Lastly, configure the collections and fields you would like to request be erased or masked. Fidesops will use these fields to compose an email to the third-party service. PUT api/v1/connection/{email_connection_config_key}/dataset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [ { \"fides_key\" : \"email_dataset\" , \"name\" : \"Dataset not accessible automatically\" , \"description\" : \"Third party data - will email to request erasure\" , \"collections\" : [ { \"name\" : \"daycare_customer\" , \"fields\" : [ { \"name\" : \"id\" , \"data_categories\" : [ \"system.operations\" ], \"fidesops_meta\" : { \"primary_key\" : true } }, { \"name\" : \"child_health_concerns\" , \"data_categories\" : [ \"user.biometric_health\" ] }, { \"name\" : \"user_email\" , \"data_categories\" : [ \"user.contact.email\" ], \"fidesops_meta\" : { \"identity\" : \"email\" } } ] } ] } ] Field Description fides_key A unique key used to manage your email dataset. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email dataset. description Any additional information used to describe this email dataset. collections Any collections and associated fields belonging to the third party service, similar to a configured fidesops Dataset . If you do not know the exact data structure of a third party's database, you can configure a single collection with the fields you would like masked. Note: A primary key must be specified on each collection.","title":"Configure Automatic Emails"},{"location":"guides/email_communications/#configure-automatic-emails","text":"","title":"Configure Automatic Emails"},{"location":"guides/email_communications/#what-is-a-fidesops-email-connection","text":"Fidesops supports configuring third party email servers to handle outbound communications. Supported modes of use: Subject Identity Verification - sends a verification code to the user's email address prior to processing a subject request. For more information on identity verification, see the Privacy Requests guide. Erasure Request Email Fulfillment - sends an email to configured third parties to process erasures for a given data subject. See creating email Connectors for more information. Privacy Request Receipt Notification - sends an email to user's email address with privacy request receipt notification. Privacy Request Review Notification - sends an email to user's email address upon privacy request review, including rejection reason if applicable. Privacy Request Completion Notification - sends an email to user's email address with privacy request completion notification, including a download link to data package, for access requests. For more information on request completion notification, see the Privacy Requests guide.","title":"What is a fidesops Email Connection?"},{"location":"guides/email_communications/#prerequisites","text":"Fidesops currently supports Mailgun for email integrations. Ensure you register or use an existing Mailgun account in order to get up and running with email communications. Generate a Mailgun Domain Sending Key Follow the Mailgun documentation to create a new Domain Sending Key for fidesops. Note Mailgun automatically generates a primary account API key when you sign up for an account. This key allows you to perform all CRUD operations via Mailgun's API endpoints, and for any of your sending domains. For security purposes, using a new domain sending key is recommended over your primary API key.","title":"Prerequisites"},{"location":"guides/email_communications/#configuration","text":"","title":"Configuration"},{"location":"guides/email_communications/#create-the-email-config","text":"POST api/v1/email/config 1 2 3 4 5 6 7 8 { \"key\" : \"{{email_config_key}}\" , \"name\" : \"mailgun\" , \"service_type\" : \"mailgun\" , \"details\" : { \"domain\" : \"your.mailgun.domain\" } } Field Description key Optional. A unique key used to manage your email config. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email config. service_type The email service to configure. Currently, fidesops supports mailgun . details A dict of key/val config vars specific to Mailgun. domain Your unique Mailgun domain. is_eu_domain Optional. A boolean that denotes whether your Mailgun domain was created in the EU region. Defaults to False . api_version Optional. A string that denotes the API version. Defaults to v3 .","title":"Create the email config"},{"location":"guides/email_communications/#add-the-email-configuration-secrets","text":"POST api/v1/email/config/{email_config_key}/secret 1 2 3 { \"mailgun_api_key\" : \"nc123849ycnpq98fnu\" } Field Description mailgun_api_key Your Mailgun Domain Sending Key.","title":"Add the email configuration secrets"},{"location":"guides/email_communications/#email-third-party-services-to-mask-data","text":"Once your email server is configured, you can create an email connector to send automatic erasure requests to third-party services. Fidesops will gather details about each collection described in the connector, and send a single email to the service after all collections have been visited. Note Fidesops does not collect confirmation that the erasure was completed by the third party.","title":"Email third party services to mask data"},{"location":"guides/email_communications/#create-the-connector","text":"Ensure you have created your email configuration prior to creating a new email connector. PATCH api/v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"Email Connection Config\" , \"key\" : \"third_party_email_connector\" , \"connection_type\" : \"email\" , \"access\" : \"write\" } ] Field Description key A unique key used to manage your email connector. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email connector. connection_type Must be email to create a new email connector. access Email connectors must be given write access in order to send an email.","title":"Create the connector"},{"location":"guides/email_communications/#configure-notifications","text":"Once your email connector is created, configure any outbound email addresses: PUT api/v1/connection/{email_connection_config_key}/secret 1 2 3 4 { \"test_email\" : \"my_email@example.com\" , \"to_email\" : \"third_party@example.com\" } Field Description {email_connection_config_key} The unique key that represents the email connection to use. to_email The user that will be notified via email to complete an erasure request. Only one to_email is supported at this time. test_email Optional. An email to which you have access for verifying your setup. If your email configuration is working, you will receive an email with mock data similar to the one sent to third-party services.","title":"Configure notifications"},{"location":"guides/email_communications/#configure-the-dataset","text":"Lastly, configure the collections and fields you would like to request be erased or masked. Fidesops will use these fields to compose an email to the third-party service. PUT api/v1/connection/{email_connection_config_key}/dataset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [ { \"fides_key\" : \"email_dataset\" , \"name\" : \"Dataset not accessible automatically\" , \"description\" : \"Third party data - will email to request erasure\" , \"collections\" : [ { \"name\" : \"daycare_customer\" , \"fields\" : [ { \"name\" : \"id\" , \"data_categories\" : [ \"system.operations\" ], \"fidesops_meta\" : { \"primary_key\" : true } }, { \"name\" : \"child_health_concerns\" , \"data_categories\" : [ \"user.biometric_health\" ] }, { \"name\" : \"user_email\" , \"data_categories\" : [ \"user.contact.email\" ], \"fidesops_meta\" : { \"identity\" : \"email\" } } ] } ] } ] Field Description fides_key A unique key used to manage your email dataset. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your email dataset. description Any additional information used to describe this email dataset. collections Any collections and associated fields belonging to the third party service, similar to a configured fidesops Dataset . If you do not know the exact data structure of a third party's database, you can configure a single collection with the fields you would like masked. Note: A primary key must be specified on each collection.","title":"Configure the dataset"},{"location":"guides/fidesops_workflow/","text":"Fidesops Privacy Request Execution When a Privacy Request is submitted, fidesops performs several prerequisite checks, and then visits your collections in two passes: first, to retrieve relevant data for the subject across all your collections, and again to mask the subject's data, if necessary. The following guide outlines the steps fidesops takes to fulfill a privacy request from end to end, including optional configurations and manual data retrieval. Privacy request submission Prior to processing a privacy request, fidesops first creates records to store the relevant information, and can perform a number of other actions based on your configuration: Step Description Persist Fidesops creates a privacy request in long-term storage to capture high-level information (e.g. date created, current status). Fidesops saves the identity of the subject to both short- and long-term storage. Verify If configured, Fidesops sends an email to the user to verify their identity before proceeding. Notify If configured, the user will receive an email verifying that their request has been received. Approve If configured, Fidesops will require a system administrator to approve the request before proceeding. Privacy request execution Once the required submission steps have been completed, the request status is updated to in_processing status, and the privacy request is dispatched to a separate queue for processing. Request execution involves gathering data from multiple sources, and/or masking data in multiple locations. Fidesops will follow the steps below in order, skipping any that are not applicable for the given request: Respond to manual webhooks Run policy pre-execution webhooks Access request automation Upload results Erasure request automation Send erasure request emails Run policy post-execution webhooks Send email notifications Respond to manual webhooks Manual webhooks allow data pertaining a subject to be manually uploaded by a fidesops admin. If manual webhooks are enabled, request execution will exit with a status of requires_input until a submission has been received for each manual webhook configured. The privacy request can then be resumed, and request execution will continue from this step. See Manual Webhooks for more information on configuration options and resuming a requires_input request. Data uploaded for manual webhooks will be returned to the data subject directly at the end of request execution. Data gathered here is not used to locate data from other sources. Run pre-execution webhooks Policy pre-execution webhooks let your system take care of prerequisite tasks, or locate additional identities for the data subject. Examples include turning on a specific database in your infrastructure, or locating a phone number for a subject from a table for which you do not want to give Fidesops direct access. Configuration involves defining endpoint(s) for fidesops to call in order. See Policy Webhooks for more details. Fidesops sends a request to each pre-execution webhook with a policy webhooks request format , which your endpoints should be prepared to unpack. If you need more time to carry out an action, your webhook can instruct fidesops to halt , which will cause execution to exit with a status of paused . Request execution can be continued when ready using a token supplied in the original request. No data uploaded by policy webhooks is returned to the data subject, but identities discovered can be used to later locate data pertaining to the subject during access request automation. If a request to a pre-execution webhook fails, request execution will exit with a status of error . Retrying the privacy request will resume from this step and attempt to re-run all pre-execution webhooks. Access request automation Access request automation is performed regardless of whether there are access or erasure Rules defined, as both Rules require this data. See how to configure policies, rules, and rule targets for additional information. This step visits all Collections and retrieves all Fields that you've defined in your Datasets . Fidesops builds a graph in accordance with how you've designated your Collections are related, visits each Collection in turn, and gathers all the results together. Graph building Fidesops builds a Directed Acyclic Graph, or DAG, where each location or node corresponds to a Collection in one of your Datasets. The graph helps determine the order in which nodes will be visited. Fidesops begins with any Collections that can be queried using the supplied identity data, and then points those Collections toward dependent Collections, etc. If fidesops can't determine how to reach a Collection, it will exit early with a status of error . To remedy an errored access request, you update how your Collections are related to each other in your Datasets, and resubmit the privacy request. Graph Execution After the graph is built, Fidesops passes the result to Dask to execute sequentially. Fidesops visits one Collection at a time, following the graph created, and uses Dask to determine ordering for ties. For the first Collections in the graph connected to the root, Fidesops uses the customers' provided identity to locate subject data, by either making database queries or HTTP requests to a configured API endpoint. The details on how to access your data are determined by the Connection type. Fidesops retrieves all Fields that have been configured on the Collection, and caches the results in temporary storage for usage later. Fidesops then passes the results of that Collection to downstream Collections that similarly make queries, temporarily cache the results, and return their results to their own downstream Collections. A Collection isn't visited until Fidesops has searched for data across all of its upstream Collections. This continues until all Collections have been visited. See Query Execution for more information. If there is a failure trying to retrieve data on any Collections, the request is retried the number of times configured by task_retry_count until the request exits with status error . Both the access step and errored Collection are cached in temporary storage. Restarting the privacy request will restart from this step and failed Collection. Collections that have already been visited will not be visited again. Final result retrieval The final step of an automated access request gathers all the results for each Collection from temporary storage. Upload results If configured, Fidesops uploads the results retrieved from access automation for the data subject. For each configured access Rule, Fidesops filter the graph results to match targeted Data Categories. See Datasets for more details. Fidesops also supplements the results with any data manually uploaded from manual webhooks . Each data package is uploaded in JSON or CSV format to a specified storage location like Amazon S3. See Storage for more information. Erasure request automation If applicable, (erasure Rules are configured on your execution policy), Fidesops builds a simpler version of the access request graph, and visits each Collection in turn, performing masking requests as necessary. Graph building The \"graph\" for an erasure runs on the data from the access request, which is kept in temporary storage, and can be used to locate data for each Collection individually. Because the data has already been found, each Collection could be visited in any order or run in parallel. The graph is configured so each Collection has its previous access request results passed in as inputs, and each Collection returns a count of records masked when complete. Graph execution Fidesops visits each Collection sequentially, using a deterministic order set by Dask. For each row of data retrieved in the access request step, Fidesops attempts to mask the data targeting the fields specified on your execution policy, using the masking strategies you've defined. If no rows exist from the access request, or no Fields on that Collection match the targeted Data Categories, no masking occurs. Fidesops caches a count of the records that had fields masked in temporary storage. The masking request might involve an update database query or an update or delete HTTP request depending on the Connection Type . The Email Connector type doesn't mask any data itself, but instead persists how to locate and mask that Collection in temporary storage for use later. If masking fails on a given Collection, Fidesops retries the requests for a configured number of times, and then request execution will exit with a status of error . Fidesops will cache both the failed Collection and that the failure occurred on the erasure step. Retrying the privacy request will resume from the erasure step at the failed Collection. Previously masked Collections will not be masked again. Send erasure request emails After the access and erasure steps have both executed, Fidesops checks if there are any third parties that need to be additionally emailed to complete erasure requests on your behalf. See emailing third party services to mask data for more information. Fidesops retrieves any masking instructions cached by Email Connectors in the erasure request step, and combines them into a single email per Dataset. This step is only performed if you have Email Connectors configured. If the email send fails for any reason, the request will exit with status error . Fidesops will cache this step in temporary storage, so retrying the request will resume from this point. Run policy post-execution webhooks After automated access and erasures have completed, post-execution webhooks can be used to perform any cleanup steps in your system. Examples include setting up a webhook to shut down a database, or to delete user data from a source you don't want Fidesops to access directly. Post-execution webhooks are more limited than Pre-execution webhooks. They currently cannot pause the graph, and should be configured as a series of API endpoints you would like Fidesops to call. See policy webhooks for more details on configuration. If a request to a post-execution webhook fails, request execution will exit with a status of error . Retrying the privacy request will resume from this step and attempt to re-run all the post-execution webhooks. Send email notifications If configured, Fidesops will send a followup email to the data subject to let them know their request has finished processing. For access Rules, the emails will contain links to where the data subject can retrieve data. For erasure Rules, the emails will simplify notify them that their request is complete. Request execution will then exit with the status complete . Additional notes Fidesops uses Redis as temporary storage to support executing your request. Data automatically retrieved from each Collection, manually uploaded data, and details about where the Privacy Request may be paused or where it failed may all be temporarily stored. This information will expire in accordance with the FIDESOPS__REDIS__DEFAULT_TTL_SECONDS setting . The current fidesops execution strategy prioritizes being able to erase as many of the original Collections requested as possible. If Fidesops masks some Collections and then registers a failure, the current logic will mask the original remaining Collections using the temporarily saved data retrieved in the original access step instead of re-querying the Collections. Once data is masked in one Collection, it could potentially prevent us from being able to locate data in downstream Collections, and so will use temporarily stored data. Data added in the interim, or data related to newly added Collections, can be missed. If the automated access step fails part of the way through, a new Collection is added, and then the request is restarted from failure, Fidesops may miss data from already completed Collections downstream, and any Collections further downstream of that set. If the erasure step fails, a new Collection is added, and the request is restarted from failure, Fidesops may miss masking data from the new Collection and data downstream of the new Collection. Nodes on the graph correspond to individual Collections within Datasets, not Datasets. The graph built may result in Fidesops visiting a Collection in one Dataset to be able to find data on a Collection in a separate Dataset, which is used to find data on a Collection in the original Dataset. Automated access requests often select more Fields than may be returned specifically to the user because this data has multiple uses. Fidesops selects all Fields defined to be able to potentially query downstream Collections, filter data according to multiple access Rules, and mask data in accordance with multiple erasure Rules.","title":"Understanding Privacy Request Execution"},{"location":"guides/fidesops_workflow/#fidesops-privacy-request-execution","text":"When a Privacy Request is submitted, fidesops performs several prerequisite checks, and then visits your collections in two passes: first, to retrieve relevant data for the subject across all your collections, and again to mask the subject's data, if necessary. The following guide outlines the steps fidesops takes to fulfill a privacy request from end to end, including optional configurations and manual data retrieval.","title":"Fidesops Privacy Request Execution"},{"location":"guides/fidesops_workflow/#privacy-request-submission","text":"Prior to processing a privacy request, fidesops first creates records to store the relevant information, and can perform a number of other actions based on your configuration: Step Description Persist Fidesops creates a privacy request in long-term storage to capture high-level information (e.g. date created, current status). Fidesops saves the identity of the subject to both short- and long-term storage. Verify If configured, Fidesops sends an email to the user to verify their identity before proceeding. Notify If configured, the user will receive an email verifying that their request has been received. Approve If configured, Fidesops will require a system administrator to approve the request before proceeding.","title":"Privacy request submission"},{"location":"guides/fidesops_workflow/#privacy-request-execution","text":"Once the required submission steps have been completed, the request status is updated to in_processing status, and the privacy request is dispatched to a separate queue for processing. Request execution involves gathering data from multiple sources, and/or masking data in multiple locations. Fidesops will follow the steps below in order, skipping any that are not applicable for the given request: Respond to manual webhooks Run policy pre-execution webhooks Access request automation Upload results Erasure request automation Send erasure request emails Run policy post-execution webhooks Send email notifications","title":"Privacy request execution"},{"location":"guides/fidesops_workflow/#respond-to-manual-webhooks","text":"Manual webhooks allow data pertaining a subject to be manually uploaded by a fidesops admin. If manual webhooks are enabled, request execution will exit with a status of requires_input until a submission has been received for each manual webhook configured. The privacy request can then be resumed, and request execution will continue from this step. See Manual Webhooks for more information on configuration options and resuming a requires_input request. Data uploaded for manual webhooks will be returned to the data subject directly at the end of request execution. Data gathered here is not used to locate data from other sources.","title":"Respond to manual webhooks"},{"location":"guides/fidesops_workflow/#run-pre-execution-webhooks","text":"Policy pre-execution webhooks let your system take care of prerequisite tasks, or locate additional identities for the data subject. Examples include turning on a specific database in your infrastructure, or locating a phone number for a subject from a table for which you do not want to give Fidesops direct access. Configuration involves defining endpoint(s) for fidesops to call in order. See Policy Webhooks for more details. Fidesops sends a request to each pre-execution webhook with a policy webhooks request format , which your endpoints should be prepared to unpack. If you need more time to carry out an action, your webhook can instruct fidesops to halt , which will cause execution to exit with a status of paused . Request execution can be continued when ready using a token supplied in the original request. No data uploaded by policy webhooks is returned to the data subject, but identities discovered can be used to later locate data pertaining to the subject during access request automation. If a request to a pre-execution webhook fails, request execution will exit with a status of error . Retrying the privacy request will resume from this step and attempt to re-run all pre-execution webhooks.","title":"Run pre-execution webhooks"},{"location":"guides/fidesops_workflow/#access-request-automation","text":"Access request automation is performed regardless of whether there are access or erasure Rules defined, as both Rules require this data. See how to configure policies, rules, and rule targets for additional information. This step visits all Collections and retrieves all Fields that you've defined in your Datasets . Fidesops builds a graph in accordance with how you've designated your Collections are related, visits each Collection in turn, and gathers all the results together.","title":"Access request automation"},{"location":"guides/fidesops_workflow/#graph-building","text":"Fidesops builds a Directed Acyclic Graph, or DAG, where each location or node corresponds to a Collection in one of your Datasets. The graph helps determine the order in which nodes will be visited. Fidesops begins with any Collections that can be queried using the supplied identity data, and then points those Collections toward dependent Collections, etc. If fidesops can't determine how to reach a Collection, it will exit early with a status of error . To remedy an errored access request, you update how your Collections are related to each other in your Datasets, and resubmit the privacy request.","title":"Graph building"},{"location":"guides/fidesops_workflow/#graph-execution","text":"After the graph is built, Fidesops passes the result to Dask to execute sequentially. Fidesops visits one Collection at a time, following the graph created, and uses Dask to determine ordering for ties. For the first Collections in the graph connected to the root, Fidesops uses the customers' provided identity to locate subject data, by either making database queries or HTTP requests to a configured API endpoint. The details on how to access your data are determined by the Connection type. Fidesops retrieves all Fields that have been configured on the Collection, and caches the results in temporary storage for usage later. Fidesops then passes the results of that Collection to downstream Collections that similarly make queries, temporarily cache the results, and return their results to their own downstream Collections. A Collection isn't visited until Fidesops has searched for data across all of its upstream Collections. This continues until all Collections have been visited. See Query Execution for more information. If there is a failure trying to retrieve data on any Collections, the request is retried the number of times configured by task_retry_count until the request exits with status error . Both the access step and errored Collection are cached in temporary storage. Restarting the privacy request will restart from this step and failed Collection. Collections that have already been visited will not be visited again.","title":"Graph Execution"},{"location":"guides/fidesops_workflow/#final-result-retrieval","text":"The final step of an automated access request gathers all the results for each Collection from temporary storage.","title":"Final result retrieval"},{"location":"guides/fidesops_workflow/#upload-results","text":"If configured, Fidesops uploads the results retrieved from access automation for the data subject. For each configured access Rule, Fidesops filter the graph results to match targeted Data Categories. See Datasets for more details. Fidesops also supplements the results with any data manually uploaded from manual webhooks . Each data package is uploaded in JSON or CSV format to a specified storage location like Amazon S3. See Storage for more information.","title":"Upload results"},{"location":"guides/fidesops_workflow/#erasure-request-automation","text":"If applicable, (erasure Rules are configured on your execution policy), Fidesops builds a simpler version of the access request graph, and visits each Collection in turn, performing masking requests as necessary.","title":"Erasure request automation"},{"location":"guides/fidesops_workflow/#graph-building_1","text":"The \"graph\" for an erasure runs on the data from the access request, which is kept in temporary storage, and can be used to locate data for each Collection individually. Because the data has already been found, each Collection could be visited in any order or run in parallel. The graph is configured so each Collection has its previous access request results passed in as inputs, and each Collection returns a count of records masked when complete.","title":"Graph building"},{"location":"guides/fidesops_workflow/#graph-execution_1","text":"Fidesops visits each Collection sequentially, using a deterministic order set by Dask. For each row of data retrieved in the access request step, Fidesops attempts to mask the data targeting the fields specified on your execution policy, using the masking strategies you've defined. If no rows exist from the access request, or no Fields on that Collection match the targeted Data Categories, no masking occurs. Fidesops caches a count of the records that had fields masked in temporary storage. The masking request might involve an update database query or an update or delete HTTP request depending on the Connection Type . The Email Connector type doesn't mask any data itself, but instead persists how to locate and mask that Collection in temporary storage for use later. If masking fails on a given Collection, Fidesops retries the requests for a configured number of times, and then request execution will exit with a status of error . Fidesops will cache both the failed Collection and that the failure occurred on the erasure step. Retrying the privacy request will resume from the erasure step at the failed Collection. Previously masked Collections will not be masked again.","title":"Graph execution"},{"location":"guides/fidesops_workflow/#send-erasure-request-emails","text":"After the access and erasure steps have both executed, Fidesops checks if there are any third parties that need to be additionally emailed to complete erasure requests on your behalf. See emailing third party services to mask data for more information. Fidesops retrieves any masking instructions cached by Email Connectors in the erasure request step, and combines them into a single email per Dataset. This step is only performed if you have Email Connectors configured. If the email send fails for any reason, the request will exit with status error . Fidesops will cache this step in temporary storage, so retrying the request will resume from this point.","title":"Send erasure request emails"},{"location":"guides/fidesops_workflow/#run-policy-post-execution-webhooks","text":"After automated access and erasures have completed, post-execution webhooks can be used to perform any cleanup steps in your system. Examples include setting up a webhook to shut down a database, or to delete user data from a source you don't want Fidesops to access directly. Post-execution webhooks are more limited than Pre-execution webhooks. They currently cannot pause the graph, and should be configured as a series of API endpoints you would like Fidesops to call. See policy webhooks for more details on configuration. If a request to a post-execution webhook fails, request execution will exit with a status of error . Retrying the privacy request will resume from this step and attempt to re-run all the post-execution webhooks.","title":"Run policy post-execution webhooks"},{"location":"guides/fidesops_workflow/#send-email-notifications","text":"If configured, Fidesops will send a followup email to the data subject to let them know their request has finished processing. For access Rules, the emails will contain links to where the data subject can retrieve data. For erasure Rules, the emails will simplify notify them that their request is complete. Request execution will then exit with the status complete .","title":"Send email notifications"},{"location":"guides/fidesops_workflow/#additional-notes","text":"Fidesops uses Redis as temporary storage to support executing your request. Data automatically retrieved from each Collection, manually uploaded data, and details about where the Privacy Request may be paused or where it failed may all be temporarily stored. This information will expire in accordance with the FIDESOPS__REDIS__DEFAULT_TTL_SECONDS setting . The current fidesops execution strategy prioritizes being able to erase as many of the original Collections requested as possible. If Fidesops masks some Collections and then registers a failure, the current logic will mask the original remaining Collections using the temporarily saved data retrieved in the original access step instead of re-querying the Collections. Once data is masked in one Collection, it could potentially prevent us from being able to locate data in downstream Collections, and so will use temporarily stored data. Data added in the interim, or data related to newly added Collections, can be missed. If the automated access step fails part of the way through, a new Collection is added, and then the request is restarted from failure, Fidesops may miss data from already completed Collections downstream, and any Collections further downstream of that set. If the erasure step fails, a new Collection is added, and the request is restarted from failure, Fidesops may miss masking data from the new Collection and data downstream of the new Collection. Nodes on the graph correspond to individual Collections within Datasets, not Datasets. The graph built may result in Fidesops visiting a Collection in one Dataset to be able to find data on a Collection in a separate Dataset, which is used to find data on a Collection in the original Dataset. Automated access requests often select more Fields than may be returned specifically to the user because this data has multiple uses. Fidesops selects all Fields defined to be able to potentially query downstream Collections, filter data according to multiple access Rules, and mask data in accordance with multiple erasure Rules.","title":"Additional notes"},{"location":"guides/manual_webhooks/","text":"Manual Webhooks Manual webhooks are a simple way for data to be manually uploaded for an access request. Erasure requests are not supported at this time. They differ from the more complex manual connection configs that integrate directly with the graph. Manual webhooks gather data outside of the graph as a first step, and are more similar to policy_webhooks . If you have manual webhooks defined, privacy request execution will exit early and remain in a state of requires_input . Once data has been manually uploaded for all the manual webhooks, then the privacy request can be resumed. Data uploaded for manual webhooks is passed on directly to the data subject alongside the data package. It is not filtered on data category. Any manual data uploaded is passed on as-is. Configuration Create a connection config of type manual_webhook POST api/v1/connection 1 2 3 4 5 6 7 [ { \"name\" : \"Manual Webhook ConnectionConfig\" , \"key\" : \"manual_webhook_key\" , \"connection_type\" : \"manual_webhook\" , \"access\" : \"read\" } ] Field Description key Optional. A unique key used to manage your connection config. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your connection config. This key will also be used to identity the manual webhook connection_type Should be manual_webhook for the resource described here. access One of read or write Define the fields expected for your manual_webhook Submit a list of fields that will need to be manually uploaded. PATCH api/v1/connection/{{manual_webhook_key}}/access_manual_webhook 1 2 3 4 5 6 7 8 { \"fields\" : [ { \"pii_field\" : \"First Name\" , \"dsr_package_label\" : \"first_name\" }, { \"pii_field\" : \"Last Name\" , \"dsr_package_label\" : \"last_name\" }, { \"pii_field\" : \"Phone Number\" , \"dsr_package_label\" : null }, { \"pii_field\" : \"Height\" , \"dsr_package_label\" : \"height\" } ] } Field Description fields Required. A list of field mappings with pii_field and dsr_package_label keys. The pii_field is the label fidesops will display when it solicits manual input, and the dsr_package_label is the identifier fidesops will use when it uploads the data to the data subject. If no dsr_package_label is supplied, it will be created from the pii_field . Upload manual webhook data for a given privacy request Privacy request execution will exit early with a status of requires_input if we're missing data for manual_webhooks . A request will need to be made for each manual_webhook to upload the requested data before request execution can proceed. Note that the fields here are dynamic and should match the fields specified on the manual webhook. All fields are optional. If no data exists, an empty dictionary should be uploaded. Fidesops treats this upload as confirmation that the system was searched for data related to the data subject. PATCH /privacy-request/{{privacy_request_id}}/access_manual_webhook/{{manual_webhook_key}} 1 2 3 4 { \"first_name\" : \"Jane\" , \"last_name\" : \"Customer\" } Resume Privacy Request Execution Once a PrivacyRequest with requires_input has had all of its manual data uploaded, prompt the privacy request to resume. POST /privacy-request/{{privacy_request_id}}/resume_from_requires_input 1 Example Upload In this example, we visited one postgres collection automatically and retrieved Jane's name , email , and id . Her first_name and last_name were manually uploaded as part of the manual_webhook_key Manual Webhook and directly included here. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"postgres_example:customer\" : [ { \"name\" : \"Jane Customer\" , \"email\" : \"customer-3@example.com\" , \"id\" : 1 } ], \"manual_webhook_key\" : [ { \"first_name\" : \"Jane\" , \"last_name\" : \"Customer\" } ] }","title":"Configure Manual Webhooks"},{"location":"guides/manual_webhooks/#manual-webhooks","text":"Manual webhooks are a simple way for data to be manually uploaded for an access request. Erasure requests are not supported at this time. They differ from the more complex manual connection configs that integrate directly with the graph. Manual webhooks gather data outside of the graph as a first step, and are more similar to policy_webhooks . If you have manual webhooks defined, privacy request execution will exit early and remain in a state of requires_input . Once data has been manually uploaded for all the manual webhooks, then the privacy request can be resumed. Data uploaded for manual webhooks is passed on directly to the data subject alongside the data package. It is not filtered on data category. Any manual data uploaded is passed on as-is.","title":"Manual Webhooks"},{"location":"guides/manual_webhooks/#configuration","text":"","title":"Configuration"},{"location":"guides/manual_webhooks/#create-a-connection-config-of-type-manual_webhook","text":"POST api/v1/connection 1 2 3 4 5 6 7 [ { \"name\" : \"Manual Webhook ConnectionConfig\" , \"key\" : \"manual_webhook_key\" , \"connection_type\" : \"manual_webhook\" , \"access\" : \"read\" } ] Field Description key Optional. A unique key used to manage your connection config. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . name A unique user-friendly name for your connection config. This key will also be used to identity the manual webhook connection_type Should be manual_webhook for the resource described here. access One of read or write","title":"Create a connection config of type manual_webhook"},{"location":"guides/manual_webhooks/#define-the-fields-expected-for-your-manual_webhook","text":"Submit a list of fields that will need to be manually uploaded. PATCH api/v1/connection/{{manual_webhook_key}}/access_manual_webhook 1 2 3 4 5 6 7 8 { \"fields\" : [ { \"pii_field\" : \"First Name\" , \"dsr_package_label\" : \"first_name\" }, { \"pii_field\" : \"Last Name\" , \"dsr_package_label\" : \"last_name\" }, { \"pii_field\" : \"Phone Number\" , \"dsr_package_label\" : null }, { \"pii_field\" : \"Height\" , \"dsr_package_label\" : \"height\" } ] } Field Description fields Required. A list of field mappings with pii_field and dsr_package_label keys. The pii_field is the label fidesops will display when it solicits manual input, and the dsr_package_label is the identifier fidesops will use when it uploads the data to the data subject. If no dsr_package_label is supplied, it will be created from the pii_field .","title":"Define the fields expected for your manual_webhook"},{"location":"guides/manual_webhooks/#upload-manual-webhook-data-for-a-given-privacy-request","text":"Privacy request execution will exit early with a status of requires_input if we're missing data for manual_webhooks . A request will need to be made for each manual_webhook to upload the requested data before request execution can proceed. Note that the fields here are dynamic and should match the fields specified on the manual webhook. All fields are optional. If no data exists, an empty dictionary should be uploaded. Fidesops treats this upload as confirmation that the system was searched for data related to the data subject. PATCH /privacy-request/{{privacy_request_id}}/access_manual_webhook/{{manual_webhook_key}} 1 2 3 4 { \"first_name\" : \"Jane\" , \"last_name\" : \"Customer\" }","title":"Upload manual webhook data for a given privacy request"},{"location":"guides/manual_webhooks/#resume-privacy-request-execution","text":"Once a PrivacyRequest with requires_input has had all of its manual data uploaded, prompt the privacy request to resume. POST /privacy-request/{{privacy_request_id}}/resume_from_requires_input 1","title":"Resume Privacy Request Execution"},{"location":"guides/manual_webhooks/#example-upload","text":"In this example, we visited one postgres collection automatically and retrieved Jane's name , email , and id . Her first_name and last_name were manually uploaded as part of the manual_webhook_key Manual Webhook and directly included here. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"postgres_example:customer\" : [ { \"name\" : \"Jane Customer\" , \"email\" : \"customer-3@example.com\" , \"id\" : 1 } ], \"manual_webhook_key\" : [ { \"first_name\" : \"Jane\" , \"last_name\" : \"Customer\" } ] }","title":"Example Upload"},{"location":"guides/masking_strategies/","text":"Configure Data Masking What is data masking? Data masking is the process of obfuscating data in client systems, so it is no longer recognizable as PII (personally identifiable information.) For example, if a customer requests that your remove all information associated with their email, test@example.com , you might choose to \"mask\" that email with a random string, xgoi4301nkyi79fjfdopvyjc5lnbr9 , and their associated address with another random string 2ab6jghdg37uhkaz3hpyavpss1dvg2 . It's important to remember that masking does not equal anonymization. Since records are not deleted, a masked dataset is (at best) pseudonymized in most cases, and (at worst) may still be identifiable if the masking is reversible or easy to predict. In fidesops, your options to pseudonymize data are captured in \"masking strategies\". Fidesops supports a wide variety of masking strategies for different purposes when used directly as an API including HMAC, Hash, AES encryption, string rewrite, random string rewrite, and null rewrite. Why mask instead of delete? Deleting customer data may involve entirely deleting a whole record (all attributes of the entity) or permanent and irreversible anonymization of the record by updating specific fields within a record with masked values. Using a masking strategy instead of straight deletion to obscure PII helps ensure referential integrity in your database. For example, you might have an orders table with a foreign key to user without cascade delete. Say you first deleted a user with email test@example.com without addressing their orders, you could potentially have lingering orphans in the orders table. Using masking as a \"soft delete\" might be a safer strategy depending on how your tables are defined. In order to ensure referential integrity is retained, any values that represent foreign keys must be consistently updated with the same masked values across all sources. Other reasons to mask instead of delete include legal requirements that have you retain certain data for a certain length of time. Using fidesops as a masking service If you just want to use fidesops as a masking service, you can send a PUT request to the masking endpoint with the value(s) you'd like pseudonymized. This endpoint is also useful for getting a feel of how the different masking strategies work. Masking example PUT /masking/mask 1 2 3 4 5 6 7 8 9 10 11 12 { \"values\" : [ \"test@example.com\" ], \"masking_strategy\" : { \"strategy\" : \"random_string_rewrite\" , \"configuration\" : { \"length\" : 20 , \"format_preservation\" : { \"suffix\" : \"@masked.com\" } } } } Response 200 OK 1 2 3 4 { \"plain\" : [ \"test@example.com\" ], \"masked_value\" : [ \"idkeaotbrub346ycbmpo@masked.com\" ] } The email has been replaced with a random string of 20 characters, while still preserving that the value is an email. See the masking values API on how to use fidesops to as a masking service. Specifying Multiple Strategies If you would like multiple strategies to be applied in sequence when using fides as a masking service, supply a list of strategies under \"strategy\". Each strategy will be applied across all values in order. In this example, the random_string_rewrite strategy will be run on both values first, and then the hash masking strategy will be run on both values output from random_string_rewrite . PUT /masking/mask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"values\" :[ \"111-111-1111\" , \"customer-1@example.com\" ], \"masking_strategy\" :[ { \"strategy\" : \"random_string_rewrite\" , \"configuration\" :{ \"length\" : 20 , \"format_preservation\" :{ \"suffix\" : \"@masked.com\" } } }, { \"strategy\" : \"hash\" , \"configuration\" :{ } } ] } Configuration Erasure requests will mask data with the chosen masking strategy. To configure a specific masking strategy to be used for a Policy, you will create an erasure rule that captures that strategy for the Policy. PATCH /policy/policy_key/rule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [{ \"name\" : \"Global erasure rule\" , \"action_type\" : \"erasure\" , \"key\" : \"string_rewrite_rule\" , \"masking_strategy\" : { \"strategy\" : \"random_string_rewrite\" , \"configuration\" : { \"length\" : 20 , \"format_preservation\" : { \"suffix\" : \"@masked.com\" } } } }] Supported masking strategies Null rewrite Masks the input value with a null value. strategy : null_rewrite No config needed. String rewrite Masks the input value with a default string value. strategy : string_rewrite configuration : rewrite_value : str that will replace input values format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value Hash Masks the data by hashing the input before returning it. The hash is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : hash configuration : algorithm (optional): str that specifies Hash masking algorithm. Options include SHA-512 or SHA_256 . Default = SHA_256 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value Random string rewrite Masks the input value with a random string of a specified length. strategy : random_string_rewrite configuration : length (optional): int that specifies length of randomly generated string. Default = 30 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value AES encrypt Masks the data using AES encryption before returning it. The AES encryption strategy is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : aes_encrypt configuration : mode (optional): str that specifies AES encryption mode. Only supported option is GCM . Default = GCM format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value HMAC Masks the data using HMAC before returning it. The HMAC encryption strategy is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : hmac configuration : algorithm (optional): str that specifies HMAC masking algorithm. Options include SHA-512 or SHA_256 . Default = SHA_256 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value See the Policy guide for more detailed instructions on creating Policies and Rules. Getting masking options Issue a GET request to /api/v1/masking/strategy to preview the different masking strategies available, along with their configuration options. Extensibility In fidesops, masking strategies are all built on top of an abstract base class - MaskingStrategy . MaskingStrategy has four methods - mask , secrets_required , get_description , and data_type_supported . For more detail on these methods, visit the class in the fidesops repository. For now, we will focus on the implementation of RandomStringRewriteMaskingStrategy below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import string from secrets import choice from typing import List , Optional , Type from fidesops.ops.schemas.masking.masking_configuration import ( RandomStringMaskingConfiguration , ) from fidesops.ops.schemas.masking.masking_strategy_description import ( MaskingStrategyConfigurationDescription , MaskingStrategyDescription , ) from fidesops.ops.service.masking.strategy.format_preservation import FormatPreservation from fidesops.ops.service.masking.strategy.masking_strategy import MaskingStrategy class RandomStringRewriteMaskingStrategy ( MaskingStrategy ): \"\"\"Masks each provied value with a random string of the length specified in the configuration.\"\"\" name = \"random_string_rewrite\" configuration_model = RandomStringMaskingConfiguration def __init__ ( self , configuration : RandomStringMaskingConfiguration , ): self . length = configuration . length self . format_preservation = configuration . format_preservation def mask ( self , values : Optional [ List [ str ]], request_id : Optional [ str ] ) -> Optional [ List [ str ]]: \"\"\"Replaces the value with a random lowercase string of the configured length\"\"\" if values is None : return None masked_values : List [ str ] = [] for _ in range ( len ( values )): masked : str = \"\" . join ( [ choice ( string . ascii_lowercase + string . digits ) for _ in range ( self . length ) ] ) if self . format_preservation is not None : formatter = FormatPreservation ( self . format_preservation ) masked = formatter . format ( masked ) masked_values . append ( masked ) return masked_values def secrets_required ( self ) -> bool : \"\"\"Not covered in this example\"\"\" @classmethod def get_description ( cls : Type [ MaskingStrategy ]) -> MaskingStrategyDescription : \"\"\"Not covered in this example\"\"\" @staticmethod def data_type_supported ( data_type : Optional [ str ]) -> bool : \"\"\"Not covered in this example\"\"\" The mask method will be called with the list of values to be masked and the masked values will be the output. In this case, we want to replace the supplied values with a random mixture of ascii lowercase letters and digits of the specified length. If format preservation is specified, for example, we still want to know that an email was an email, we might tack on an email-like suffix. Note the arguments to the init method - there is a field configuration of type RandomStringMaskingConfiguration . This is the configuration for the masking strategy. It is used to house the options specified by the client as well as any defaults that should be applied in their absence. All configuration classes extend from the MaskingConfiguration class. Integrate the masking strategy factory In order to leverage an implemented masking strategy, the MaskingStrategy subclass must be imported into the application runtime. Also, the MaskingStrategy class must define two class variables: name , which is the unique, registered name that callers will use in their \"masking_strategy\".\"strategy\" field to invoke the strategy; and configuration_model , which references the configuration class used to parameterize the strategy.","title":"Configure Data Masking"},{"location":"guides/masking_strategies/#configure-data-masking","text":"","title":"Configure Data Masking"},{"location":"guides/masking_strategies/#what-is-data-masking","text":"Data masking is the process of obfuscating data in client systems, so it is no longer recognizable as PII (personally identifiable information.) For example, if a customer requests that your remove all information associated with their email, test@example.com , you might choose to \"mask\" that email with a random string, xgoi4301nkyi79fjfdopvyjc5lnbr9 , and their associated address with another random string 2ab6jghdg37uhkaz3hpyavpss1dvg2 . It's important to remember that masking does not equal anonymization. Since records are not deleted, a masked dataset is (at best) pseudonymized in most cases, and (at worst) may still be identifiable if the masking is reversible or easy to predict. In fidesops, your options to pseudonymize data are captured in \"masking strategies\". Fidesops supports a wide variety of masking strategies for different purposes when used directly as an API including HMAC, Hash, AES encryption, string rewrite, random string rewrite, and null rewrite.","title":"What is data masking?"},{"location":"guides/masking_strategies/#why-mask-instead-of-delete","text":"Deleting customer data may involve entirely deleting a whole record (all attributes of the entity) or permanent and irreversible anonymization of the record by updating specific fields within a record with masked values. Using a masking strategy instead of straight deletion to obscure PII helps ensure referential integrity in your database. For example, you might have an orders table with a foreign key to user without cascade delete. Say you first deleted a user with email test@example.com without addressing their orders, you could potentially have lingering orphans in the orders table. Using masking as a \"soft delete\" might be a safer strategy depending on how your tables are defined. In order to ensure referential integrity is retained, any values that represent foreign keys must be consistently updated with the same masked values across all sources. Other reasons to mask instead of delete include legal requirements that have you retain certain data for a certain length of time.","title":"Why mask instead of delete?"},{"location":"guides/masking_strategies/#using-fidesops-as-a-masking-service","text":"If you just want to use fidesops as a masking service, you can send a PUT request to the masking endpoint with the value(s) you'd like pseudonymized. This endpoint is also useful for getting a feel of how the different masking strategies work.","title":"Using fidesops as a masking service"},{"location":"guides/masking_strategies/#masking-example","text":"PUT /masking/mask 1 2 3 4 5 6 7 8 9 10 11 12 { \"values\" : [ \"test@example.com\" ], \"masking_strategy\" : { \"strategy\" : \"random_string_rewrite\" , \"configuration\" : { \"length\" : 20 , \"format_preservation\" : { \"suffix\" : \"@masked.com\" } } } } Response 200 OK 1 2 3 4 { \"plain\" : [ \"test@example.com\" ], \"masked_value\" : [ \"idkeaotbrub346ycbmpo@masked.com\" ] } The email has been replaced with a random string of 20 characters, while still preserving that the value is an email. See the masking values API on how to use fidesops to as a masking service.","title":"Masking example"},{"location":"guides/masking_strategies/#specifying-multiple-strategies","text":"If you would like multiple strategies to be applied in sequence when using fides as a masking service, supply a list of strategies under \"strategy\". Each strategy will be applied across all values in order. In this example, the random_string_rewrite strategy will be run on both values first, and then the hash masking strategy will be run on both values output from random_string_rewrite . PUT /masking/mask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"values\" :[ \"111-111-1111\" , \"customer-1@example.com\" ], \"masking_strategy\" :[ { \"strategy\" : \"random_string_rewrite\" , \"configuration\" :{ \"length\" : 20 , \"format_preservation\" :{ \"suffix\" : \"@masked.com\" } } }, { \"strategy\" : \"hash\" , \"configuration\" :{ } } ] }","title":"Specifying Multiple Strategies"},{"location":"guides/masking_strategies/#configuration","text":"Erasure requests will mask data with the chosen masking strategy. To configure a specific masking strategy to be used for a Policy, you will create an erasure rule that captures that strategy for the Policy. PATCH /policy/policy_key/rule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [{ \"name\" : \"Global erasure rule\" , \"action_type\" : \"erasure\" , \"key\" : \"string_rewrite_rule\" , \"masking_strategy\" : { \"strategy\" : \"random_string_rewrite\" , \"configuration\" : { \"length\" : 20 , \"format_preservation\" : { \"suffix\" : \"@masked.com\" } } } }]","title":"Configuration"},{"location":"guides/masking_strategies/#supported-masking-strategies","text":"","title":"Supported masking strategies"},{"location":"guides/masking_strategies/#null-rewrite","text":"Masks the input value with a null value. strategy : null_rewrite No config needed.","title":"Null rewrite"},{"location":"guides/masking_strategies/#string-rewrite","text":"Masks the input value with a default string value. strategy : string_rewrite configuration : rewrite_value : str that will replace input values format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value","title":"String rewrite"},{"location":"guides/masking_strategies/#hash","text":"Masks the data by hashing the input before returning it. The hash is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : hash configuration : algorithm (optional): str that specifies Hash masking algorithm. Options include SHA-512 or SHA_256 . Default = SHA_256 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value","title":"Hash"},{"location":"guides/masking_strategies/#random-string-rewrite","text":"Masks the input value with a random string of a specified length. strategy : random_string_rewrite configuration : length (optional): int that specifies length of randomly generated string. Default = 30 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value","title":"Random string rewrite"},{"location":"guides/masking_strategies/#aes-encrypt","text":"Masks the data using AES encryption before returning it. The AES encryption strategy is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : aes_encrypt configuration : mode (optional): str that specifies AES encryption mode. Only supported option is GCM . Default = GCM format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value","title":"AES encrypt"},{"location":"guides/masking_strategies/#hmac","text":"Masks the data using HMAC before returning it. The HMAC encryption strategy is deterministic such that the same input will return the same output within the context of the same privacy request. This is not the case when the masking service is called as a standalone service, outside the context of a privacy request. strategy : hmac configuration : algorithm (optional): str that specifies HMAC masking algorithm. Options include SHA-512 or SHA_256 . Default = SHA_256 format_preservation (optional): Dict with the following key/vals: suffix : str that specifies suffix to append to masked value See the Policy guide for more detailed instructions on creating Policies and Rules.","title":"HMAC"},{"location":"guides/masking_strategies/#getting-masking-options","text":"Issue a GET request to /api/v1/masking/strategy to preview the different masking strategies available, along with their configuration options.","title":"Getting masking options"},{"location":"guides/masking_strategies/#extensibility","text":"In fidesops, masking strategies are all built on top of an abstract base class - MaskingStrategy . MaskingStrategy has four methods - mask , secrets_required , get_description , and data_type_supported . For more detail on these methods, visit the class in the fidesops repository. For now, we will focus on the implementation of RandomStringRewriteMaskingStrategy below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import string from secrets import choice from typing import List , Optional , Type from fidesops.ops.schemas.masking.masking_configuration import ( RandomStringMaskingConfiguration , ) from fidesops.ops.schemas.masking.masking_strategy_description import ( MaskingStrategyConfigurationDescription , MaskingStrategyDescription , ) from fidesops.ops.service.masking.strategy.format_preservation import FormatPreservation from fidesops.ops.service.masking.strategy.masking_strategy import MaskingStrategy class RandomStringRewriteMaskingStrategy ( MaskingStrategy ): \"\"\"Masks each provied value with a random string of the length specified in the configuration.\"\"\" name = \"random_string_rewrite\" configuration_model = RandomStringMaskingConfiguration def __init__ ( self , configuration : RandomStringMaskingConfiguration , ): self . length = configuration . length self . format_preservation = configuration . format_preservation def mask ( self , values : Optional [ List [ str ]], request_id : Optional [ str ] ) -> Optional [ List [ str ]]: \"\"\"Replaces the value with a random lowercase string of the configured length\"\"\" if values is None : return None masked_values : List [ str ] = [] for _ in range ( len ( values )): masked : str = \"\" . join ( [ choice ( string . ascii_lowercase + string . digits ) for _ in range ( self . length ) ] ) if self . format_preservation is not None : formatter = FormatPreservation ( self . format_preservation ) masked = formatter . format ( masked ) masked_values . append ( masked ) return masked_values def secrets_required ( self ) -> bool : \"\"\"Not covered in this example\"\"\" @classmethod def get_description ( cls : Type [ MaskingStrategy ]) -> MaskingStrategyDescription : \"\"\"Not covered in this example\"\"\" @staticmethod def data_type_supported ( data_type : Optional [ str ]) -> bool : \"\"\"Not covered in this example\"\"\" The mask method will be called with the list of values to be masked and the masked values will be the output. In this case, we want to replace the supplied values with a random mixture of ascii lowercase letters and digits of the specified length. If format preservation is specified, for example, we still want to know that an email was an email, we might tack on an email-like suffix. Note the arguments to the init method - there is a field configuration of type RandomStringMaskingConfiguration . This is the configuration for the masking strategy. It is used to house the options specified by the client as well as any defaults that should be applied in their absence. All configuration classes extend from the MaskingConfiguration class.","title":"Extensibility"},{"location":"guides/masking_strategies/#integrate-the-masking-strategy-factory","text":"In order to leverage an implemented masking strategy, the MaskingStrategy subclass must be imported into the application runtime. Also, the MaskingStrategy class must define two class variables: name , which is the unique, registered name that callers will use in their \"masking_strategy\".\"strategy\" field to invoke the strategy; and configuration_model , which references the configuration class used to parameterize the strategy.","title":"Integrate the masking strategy factory"},{"location":"guides/oauth/","text":"Authenticate with OAuth When you invoke a fidesops API, you must pass an access token as the value of the Authorization header. Furthermore, the token must include a scope that gives you permission to take an action on the API. For example, let's say you want to create a new Policy by calling PATCH /api/v1/policy . The token that you pass to the Authorization header must include the policy:create_or_update scope. This document explains how to craft a properly-scoped access token. Create the root client Note The fidesops Postman collection includes several example requests to assist in set up and configuration. First, create an access token for the \"root\" client, included in the deployment by default. The root client's token is all-powerful: It contains all scopes, so it can call any of the fidesops APIs. To create the root token, you pass the OAUTH_ROOT_CLIENT_ID and OAUTH_ROOT_CLIENT_SECRET environment variables (which are automatically defined in your system) to the POST /api/v1/oauth/token endpoint. You also set the grant_type parameter to client_credentials : 1 2 3 4 5 curl \\ -X POST 'http://<HOST>:8080/api/v1/oauth/token' \\ -d client_id=$OAUTH_ROOT_CLIENT_ID \\ -d client_secret=$OAUTH_ROOT_CLIENT_SECRET \\ -d grant_type=client_credentials You'll notice that there's no Authorization header. This is the only fidesops API that doesn't require an access token. If the token call is successful, the response will return the root client's access token in the access_token property: 1 2 3 4 5 6 7 HTTP/1.1 200 OK Content-Type: application/json { \"access_token\" : \"MTI4Q0JDJSrgyplbmMiOiJBjU2I..._X0hTMyXAyPx\", /* ignore any other properties */ } Create additional clients Because the root client's token is all-powerful, it can create new clients and new client ID/client secret pairs which can be used to create additional access tokens. Note For general best practices, we recommend creating a client with scope CLIENT_CREATE to create any new clients. This will help to reduce the utilization of the all-scopes root client. To create the client ID/secret pair, call POST /api/v1/oauth/client : 1 2 3 4 5 curl \\ -X POST 'http://<HOST>:8080/api/v1/oauth/client' \\ -H 'Authorization: Bearer <root_access_token>' -H 'Content-Type: application/json' -d '{ \"scopes\": [\"policy:read\", \"rule:read\"]}' For this call, we have to populate the Authorization header. Notice that the header's value is formed as Bearer <token> . We also have to declare the request's Content-Type to be application/json . Authorize a client with scopes To add scopes to the client, the body of your request must contain an array of scope tokens. You can retrieve the available scopes by calling GET /api/v1/oauth/scopes , or you can look in the scope registry file . If the call is successful, Fidesapi responds with a new client ID/client secret pair: 1 2 3 4 5 6 7 HTTP/1.1 200 OK Content-Type: application/json { \"client_id\" : \"<new_client_id>\" \"client_secret\" : \"<new_client_secret>\", } Create an access token You then create a new access token by calling POST /api/v1/oauth/token with the new credentials. In the above example, your new access token only lets the client read policies and rules -- the client cannot create other clients, write policies, or perform other operations using fidesops APIs. Access token expiration By default, access tokens expire after 11520 minutes (8 days). To specify a different expiration time (in minutes) set the OAUTH_ACCESS_TOKEN_EXPIRE_MINUTES environment variable. If you call a fidesops API with an expired token, the call returns 401 . Other OAuth Calls Fidesops defines OAuth operations that let you delete a client, and read and write a client's scopes. See the OAuth section of the API documentation for details.","title":"Authenticate with OAuth"},{"location":"guides/oauth/#authenticate-with-oauth","text":"When you invoke a fidesops API, you must pass an access token as the value of the Authorization header. Furthermore, the token must include a scope that gives you permission to take an action on the API. For example, let's say you want to create a new Policy by calling PATCH /api/v1/policy . The token that you pass to the Authorization header must include the policy:create_or_update scope. This document explains how to craft a properly-scoped access token.","title":"Authenticate with OAuth"},{"location":"guides/oauth/#create-the-root-client","text":"Note The fidesops Postman collection includes several example requests to assist in set up and configuration. First, create an access token for the \"root\" client, included in the deployment by default. The root client's token is all-powerful: It contains all scopes, so it can call any of the fidesops APIs. To create the root token, you pass the OAUTH_ROOT_CLIENT_ID and OAUTH_ROOT_CLIENT_SECRET environment variables (which are automatically defined in your system) to the POST /api/v1/oauth/token endpoint. You also set the grant_type parameter to client_credentials : 1 2 3 4 5 curl \\ -X POST 'http://<HOST>:8080/api/v1/oauth/token' \\ -d client_id=$OAUTH_ROOT_CLIENT_ID \\ -d client_secret=$OAUTH_ROOT_CLIENT_SECRET \\ -d grant_type=client_credentials You'll notice that there's no Authorization header. This is the only fidesops API that doesn't require an access token. If the token call is successful, the response will return the root client's access token in the access_token property: 1 2 3 4 5 6 7 HTTP/1.1 200 OK Content-Type: application/json { \"access_token\" : \"MTI4Q0JDJSrgyplbmMiOiJBjU2I..._X0hTMyXAyPx\", /* ignore any other properties */ }","title":"Create the root client"},{"location":"guides/oauth/#create-additional-clients","text":"Because the root client's token is all-powerful, it can create new clients and new client ID/client secret pairs which can be used to create additional access tokens. Note For general best practices, we recommend creating a client with scope CLIENT_CREATE to create any new clients. This will help to reduce the utilization of the all-scopes root client. To create the client ID/secret pair, call POST /api/v1/oauth/client : 1 2 3 4 5 curl \\ -X POST 'http://<HOST>:8080/api/v1/oauth/client' \\ -H 'Authorization: Bearer <root_access_token>' -H 'Content-Type: application/json' -d '{ \"scopes\": [\"policy:read\", \"rule:read\"]}' For this call, we have to populate the Authorization header. Notice that the header's value is formed as Bearer <token> . We also have to declare the request's Content-Type to be application/json .","title":"Create additional clients"},{"location":"guides/oauth/#authorize-a-client-with-scopes","text":"To add scopes to the client, the body of your request must contain an array of scope tokens. You can retrieve the available scopes by calling GET /api/v1/oauth/scopes , or you can look in the scope registry file . If the call is successful, Fidesapi responds with a new client ID/client secret pair: 1 2 3 4 5 6 7 HTTP/1.1 200 OK Content-Type: application/json { \"client_id\" : \"<new_client_id>\" \"client_secret\" : \"<new_client_secret>\", }","title":"Authorize a client with scopes"},{"location":"guides/oauth/#create-an-access-token","text":"You then create a new access token by calling POST /api/v1/oauth/token with the new credentials. In the above example, your new access token only lets the client read policies and rules -- the client cannot create other clients, write policies, or perform other operations using fidesops APIs.","title":"Create an access token"},{"location":"guides/oauth/#access-token-expiration","text":"By default, access tokens expire after 11520 minutes (8 days). To specify a different expiration time (in minutes) set the OAUTH_ACCESS_TOKEN_EXPIRE_MINUTES environment variable. If you call a fidesops API with an expired token, the call returns 401 .","title":"Access token expiration"},{"location":"guides/oauth/#other-oauth-calls","text":"Fidesops defines OAuth operations that let you delete a client, and read and write a client's scopes. See the OAuth section of the API documentation for details.","title":"Other OAuth Calls"},{"location":"guides/onetrust/","text":"Configure a OneTrust Integration API docs for OneTrust are part of the storage module. Overview OneTrust is a DSAR automation provider that provides an interface to manage privacy requests. Fidesops handles the integration to OneTrust to fulfill Data Subject Requests and returns the data package back to OneTrust. How it works Here's how our OneTrust integration works: You set up a new storage destination of type onetrust A new scheduled task kicks off that pings OneTrust for subtasks labeled for fidesops Fidesops processes those DSARs normally Upon completion of DSAR processing, we do 2 things: Ping OneTrust to set the subtask status appropriately If applicable, upload a data package back to OneTrust Configuration Fidesops OneTrust request intake is configured as part of the StorageConfig in the storage module. To configure fidesops to connect to OneTrust: Add Destination: Add a StorageConfig that includes a onetrust destination type. Authenticate: Use appropriate credentials to authenticate with OneTrust. Determine polling interval: Decide what day of the week and hour of the day you wish to retrieve requests from OneTrust. More information on storage destinations can be found here . OneTrust When the fidesops scheduled task runs, it looks for subtasks with an exact string name of \"fides task\". So, you'll need to be sure tasks you wish to pass through the Fides ecosystem are correctly labeled in the OneTrust interface. Testing To test the OneTrust integration works correctly, you'll need to do the following: Ensure that you have subtasks with a name of \"fides task\" in OneTrust Set your OneTrust destination config in Fides such that day of week and hour of request intake is appropriate for testing Confirm that the subtask status has been updated at that time, and any DSAR data packages have been uploaded at the request level in OneTrust","title":"Configure OneTrust Integration"},{"location":"guides/onetrust/#configure-a-onetrust-integration","text":"API docs for OneTrust are part of the storage module.","title":"Configure a OneTrust Integration"},{"location":"guides/onetrust/#overview","text":"OneTrust is a DSAR automation provider that provides an interface to manage privacy requests. Fidesops handles the integration to OneTrust to fulfill Data Subject Requests and returns the data package back to OneTrust.","title":"Overview"},{"location":"guides/onetrust/#how-it-works","text":"Here's how our OneTrust integration works: You set up a new storage destination of type onetrust A new scheduled task kicks off that pings OneTrust for subtasks labeled for fidesops Fidesops processes those DSARs normally Upon completion of DSAR processing, we do 2 things: Ping OneTrust to set the subtask status appropriately If applicable, upload a data package back to OneTrust","title":"How it works"},{"location":"guides/onetrust/#configuration","text":"","title":"Configuration"},{"location":"guides/onetrust/#fidesops","text":"OneTrust request intake is configured as part of the StorageConfig in the storage module. To configure fidesops to connect to OneTrust: Add Destination: Add a StorageConfig that includes a onetrust destination type. Authenticate: Use appropriate credentials to authenticate with OneTrust. Determine polling interval: Decide what day of the week and hour of the day you wish to retrieve requests from OneTrust. More information on storage destinations can be found here .","title":"Fidesops"},{"location":"guides/onetrust/#onetrust","text":"When the fidesops scheduled task runs, it looks for subtasks with an exact string name of \"fides task\". So, you'll need to be sure tasks you wish to pass through the Fides ecosystem are correctly labeled in the OneTrust interface.","title":"OneTrust"},{"location":"guides/onetrust/#testing","text":"To test the OneTrust integration works correctly, you'll need to do the following: Ensure that you have subtasks with a name of \"fides task\" in OneTrust Set your OneTrust destination config in Fides such that day of week and hour of request intake is appropriate for testing Confirm that the subtask status has been updated at that time, and any DSAR data packages have been uploaded at the request level in OneTrust","title":"Testing"},{"location":"guides/policies/","text":"Configure Policies What is a Policy? A Policy is a set of instructions (or \"Rules\") that are executed when a user submits a request to retrieve or delete their data (the user makes a \"Privacy Request\"). Each Rule contains an \"execution strategy\": action_type : The action this Rule performs, either access (retrieve data) or erasure (delete data). storage_destination : If the action_type is access , this is the key of a StorageConfig object that defines where the data is uploaded. Currently, Amazon S3 buckets and local filesystem storage are supported. See Configuring Storage for more information. masking_strategy : If the action_type is erasure , this is the key of a Masking object that defines how the erasure is implemented. See Configuring Masking Strategies for a list of available strategies. In addition to specifying an execution strategy, a Rule contains one or more Data Categories, or \"Targets\", to which the rule applies. Putting it all together, we have: 1 2 3 Policy |-> Rules |-> Targets This is reflected in the API paths that create these elements: PATCH /policy PATCH /policy/{policy_key}/rule PATCH /policy/{policy_key}/rule/{rule_key}/target Each operation takes an array of objects, so you can create more than one at a time. A note about PATCH endpoints The PATCH requests perform the equivalent of a create_or_update operation. This means that any existing objects sent to this endpoint will: be updated, any non-existing objects will be created, AND any objects existing that are not specified in the request will not be deleted Create a Policy Let's say you want to make a Policy that contains rules about a user's email address. You would start by first creating a Policy object: PATCH /api/v1/policy 1 2 3 4 5 6 7 [ { \"name\" : \"User Email Address\" , \"key\" : \"user_email_address_policy\" , \"drp_action\" : \"access\" // optional } ] This policy is subtly different from the concept of a Policy in Fidesctl . A Fidesctl policy dictates which data categories can be stored where. A fidesops policy, on the other hand, dictates how to access, mask or erase data that matches specific data categories for privacy requests. Policy attributes Attribute Description Policy.name User-friendly name for your Policy. Policy.key Unique key by which to reference the Policy. Policy.drp_action Optional. A Data Rights Protocol action to associate to this policy. access A data subject access request. Should be used with an access Rule. deletion A data subject erasure request. Should be used with an erasure Rule. Add an Access Rule to a Policy The policy creation operation returns a Policy key, which we'll use to add a Rule: PATCH /api/v1/policy/{policy_key}/rule 1 2 3 4 5 6 7 8 [ { \"name\" : \"Access User Email Address\" , \"key\" : \"access_user_email_address_rule\" , \"action_type\" : \"access\" , \"storage_destination_key\" : \"storage_key\" } ] Note that storage_key must identify an existing StorageConfig object. Finally, we use the Rule key to add a Target: PATCH /api/v1/policy/{policy_key}/rule/{rule_key}/target 1 2 3 4 5 6 7 [ { \"name\" : \"Access User Email Address Target\" , \"key\" : \"access_user_email_address_target\" , \"data_category\" : \"user.contact.email\" , } ] Rule attributes Rule.action_type : Which action is this Rule handling? access : A data subject access request. A user would like to access their own data from within the fidesops identity graph. Fidesops must look these fields up and return it to them. Fidesops will return these to a storage_destination . erasure : A data subject erasure request (also known in some legislation as the Right to be Forgotten). A user would like to erase their own data currently stored in the fidesops identity graph. Fidesops must look these fields up and either erase them entirely, or apply a masking_strategy . Rule.storage_destination : Where fidesops will upload the returned data for an access action. Currently, Amazon S3 buckets and local filesystem storage are supported. Rule.masking_strategy : How to erase data in the Identity Graph that applies to this Rule . See Configuring Masking Strategies for a full list of supported strategies and their respective configurations. Add an Erasure Rule to a Policy The simple access policy we've created above, will simply pull all data of category user.contact.email , but in the event of an erasure request, we might also want to mask this information. PATCH /api/v1/policy/{policy_key}/rule 1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \"name\" : \"Mask Provided Emails\" , \"key\" : \"mask_provided_emails\" , \"action_type\" : \"erasure\" , \"masking_strategy\" : { \"strategy\" : \"hash\" , \"configuration\" : { \"algorithm\" : \"SHA-512\" }, }, }, ] This will create a rule to hash a not-yet-specified value with a SHA-512 hash. We need to specify a target to hash, so we need to create a target for this rule: PATCH api/v1/policy/{policy_key}/rule/{rule_key} 1 2 3 4 5 [ { \"data_category\" : \"user.contact.email\" , }, ] This policy, user_email_address_polcy , will now do the following: - Return all data inside the Identity Graph with a data category that matches (or is nested under) user.contact . - Mask all data inside the Identity Graph with a data category that matches user.contact.email with a the SHA-512 hashing function. Erasing data When a Policy Rule erases data, it erases the entire branch given by the Target. For example, if we created an erasure rule with a Target of user.contact , all of the information within the contact node -- including user.contact.email -- would be erased. It's illegal to erase the same data twice within a Policy, so you should take care when you add Targets to a Rule. For example, you can't add user.contact and user.contact.email \"data_category\". And lastly, access rules will always run before erasure rules. Default Policies Fidesops ships with two default Policies: download (for access requests) and delete (for erasure requests). The download Policy is configured to retrieve user data and upload to a local storage location. The delete Policy is set up to mask user data with the string: MASKED . These auto-generated Policies are intended for use in a test environment. In production deployments, you should configure separate Policies with proper storage destinations that target and process the appropriate fields.","title":"Configure Policies"},{"location":"guides/policies/#configure-policies","text":"","title":"Configure Policies"},{"location":"guides/policies/#what-is-a-policy","text":"A Policy is a set of instructions (or \"Rules\") that are executed when a user submits a request to retrieve or delete their data (the user makes a \"Privacy Request\"). Each Rule contains an \"execution strategy\": action_type : The action this Rule performs, either access (retrieve data) or erasure (delete data). storage_destination : If the action_type is access , this is the key of a StorageConfig object that defines where the data is uploaded. Currently, Amazon S3 buckets and local filesystem storage are supported. See Configuring Storage for more information. masking_strategy : If the action_type is erasure , this is the key of a Masking object that defines how the erasure is implemented. See Configuring Masking Strategies for a list of available strategies. In addition to specifying an execution strategy, a Rule contains one or more Data Categories, or \"Targets\", to which the rule applies. Putting it all together, we have: 1 2 3 Policy |-> Rules |-> Targets This is reflected in the API paths that create these elements: PATCH /policy PATCH /policy/{policy_key}/rule PATCH /policy/{policy_key}/rule/{rule_key}/target Each operation takes an array of objects, so you can create more than one at a time. A note about PATCH endpoints The PATCH requests perform the equivalent of a create_or_update operation. This means that any existing objects sent to this endpoint will: be updated, any non-existing objects will be created, AND any objects existing that are not specified in the request will not be deleted","title":"What is a Policy?"},{"location":"guides/policies/#create-a-policy","text":"Let's say you want to make a Policy that contains rules about a user's email address. You would start by first creating a Policy object: PATCH /api/v1/policy 1 2 3 4 5 6 7 [ { \"name\" : \"User Email Address\" , \"key\" : \"user_email_address_policy\" , \"drp_action\" : \"access\" // optional } ] This policy is subtly different from the concept of a Policy in Fidesctl . A Fidesctl policy dictates which data categories can be stored where. A fidesops policy, on the other hand, dictates how to access, mask or erase data that matches specific data categories for privacy requests.","title":"Create a Policy"},{"location":"guides/policies/#policy-attributes","text":"Attribute Description Policy.name User-friendly name for your Policy. Policy.key Unique key by which to reference the Policy. Policy.drp_action Optional. A Data Rights Protocol action to associate to this policy. access A data subject access request. Should be used with an access Rule. deletion A data subject erasure request. Should be used with an erasure Rule.","title":"Policy attributes"},{"location":"guides/policies/#add-an-access-rule-to-a-policy","text":"The policy creation operation returns a Policy key, which we'll use to add a Rule: PATCH /api/v1/policy/{policy_key}/rule 1 2 3 4 5 6 7 8 [ { \"name\" : \"Access User Email Address\" , \"key\" : \"access_user_email_address_rule\" , \"action_type\" : \"access\" , \"storage_destination_key\" : \"storage_key\" } ] Note that storage_key must identify an existing StorageConfig object. Finally, we use the Rule key to add a Target: PATCH /api/v1/policy/{policy_key}/rule/{rule_key}/target 1 2 3 4 5 6 7 [ { \"name\" : \"Access User Email Address Target\" , \"key\" : \"access_user_email_address_target\" , \"data_category\" : \"user.contact.email\" , } ]","title":"Add an Access Rule to a Policy"},{"location":"guides/policies/#rule-attributes","text":"Rule.action_type : Which action is this Rule handling? access : A data subject access request. A user would like to access their own data from within the fidesops identity graph. Fidesops must look these fields up and return it to them. Fidesops will return these to a storage_destination . erasure : A data subject erasure request (also known in some legislation as the Right to be Forgotten). A user would like to erase their own data currently stored in the fidesops identity graph. Fidesops must look these fields up and either erase them entirely, or apply a masking_strategy . Rule.storage_destination : Where fidesops will upload the returned data for an access action. Currently, Amazon S3 buckets and local filesystem storage are supported. Rule.masking_strategy : How to erase data in the Identity Graph that applies to this Rule . See Configuring Masking Strategies for a full list of supported strategies and their respective configurations.","title":"Rule attributes"},{"location":"guides/policies/#add-an-erasure-rule-to-a-policy","text":"The simple access policy we've created above, will simply pull all data of category user.contact.email , but in the event of an erasure request, we might also want to mask this information. PATCH /api/v1/policy/{policy_key}/rule 1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \"name\" : \"Mask Provided Emails\" , \"key\" : \"mask_provided_emails\" , \"action_type\" : \"erasure\" , \"masking_strategy\" : { \"strategy\" : \"hash\" , \"configuration\" : { \"algorithm\" : \"SHA-512\" }, }, }, ] This will create a rule to hash a not-yet-specified value with a SHA-512 hash. We need to specify a target to hash, so we need to create a target for this rule: PATCH api/v1/policy/{policy_key}/rule/{rule_key} 1 2 3 4 5 [ { \"data_category\" : \"user.contact.email\" , }, ] This policy, user_email_address_polcy , will now do the following: - Return all data inside the Identity Graph with a data category that matches (or is nested under) user.contact . - Mask all data inside the Identity Graph with a data category that matches user.contact.email with a the SHA-512 hashing function.","title":"Add an Erasure Rule to a Policy"},{"location":"guides/policies/#erasing-data","text":"When a Policy Rule erases data, it erases the entire branch given by the Target. For example, if we created an erasure rule with a Target of user.contact , all of the information within the contact node -- including user.contact.email -- would be erased. It's illegal to erase the same data twice within a Policy, so you should take care when you add Targets to a Rule. For example, you can't add user.contact and user.contact.email \"data_category\". And lastly, access rules will always run before erasure rules.","title":"Erasing data"},{"location":"guides/policies/#default-policies","text":"Fidesops ships with two default Policies: download (for access requests) and delete (for erasure requests). The download Policy is configured to retrieve user data and upload to a local storage location. The delete Policy is set up to mask user data with the string: MASKED . These auto-generated Policies are intended for use in a test environment. In production deployments, you should configure separate Policies with proper storage destinations that target and process the appropriate fields.","title":"Default Policies"},{"location":"guides/policy_webhooks/","text":"Configure Policy Webhooks What is a Policy webhook? A Policy webhook is an HTTPS Callback that you've defined on a Policy to call an external REST API endpoint before or after a Privacy Request executes. You can define as many webhooks as you'd like. Webhooks can be one_way , where we will just ping your API and move on, or two_way , where we will wait for a response. Any derived_identities returned from a two_way webhook will be saved and can be used to locate other user information. For example, a webhook might take a known email identity and use that to find a phone_number derived_identity . Another use case for a Policy Webhook might be to log a user out of your mobile app after you've cleared their data from your system. In this case, you'd create a Policy and a ConnectionConfig to describe the URL to hit to clear the cache. You'd then create a one-way PolicyPostWebhook to run after your PrivacyRequest executes. Configuration Big picture, you will define an https ConnectionConfig that contains the details to make a request to your API endpoint. You will then define a PolicyPreWebhook or a PolicyPostWebhook for a specific Policy using that ConnectionConfig . Create an HTTPS ConnectionConfig The information that describes how to connect to your API endpoint lives on a ConnectionConfig . We also use ConnectionConfigs to connect to databases like PostgreSQL and MongoDB . This same construct can help us store how to connect to an external API endpoint. For more information on ConnectionConfigs, see how to Create a ConnectionConfig. PATCH /v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"My Webhook Connection Configuration\" , \"key\" : \"test_webhook_connection_config\" , \"connection_type\" : \"https\" , \"access\" : \"read\" } ] Adding ConnectionConfig secrets The secret details needed to talk to your API endpoint are defined by making a PUT to the ConnectionConfig Secrets endpoint: These credentials are stored encrypted in the fidesops app database. See API docs on how to Set a ConnectionConfig's Secrets . PUT /v1/connection/test_webhook_connection_config 1 2 3 4 { \"url\" : \"https://www.example.com\" , \"authorization\" : \"Bearer test_38234823482348\" } Note that the authorization secret specified here will be added directly to an authorization header when fidesops later makes a call to the configured webhook: 1 { \"Authorization\" : \"Bearer test_38234823482348\" } Define pre-execution or post-execution webhooks After you've defined a ConnectionConfig , you can create lists of webhooks to run before ( PolicyPreWebhooks ) or after ( PolicyPostWebhooks ) a PrivacyRequest is executed. If you are defining PolicyPreWebhooks, all desired PolicyPreWebhooks should be included in the request body in the desired order. Any PolicyPreWebhooks on the Policy not included in the request, will be removed from the Policy. The same applies for PolicyPostWebhooks. To update your list of PolicyPreWebhooks: PUT /policy/{policy_key}/webhook/pre_execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ { \"connection_config_key\" : \"test_webhook_connection_config\" , \"direction\" : \"one_way\" , \"key\" : \"wake_up_snowflake_db\" , \"name\" : \"Wake up Snowflake DB Webhook\" }, { \"connection_config_key\" : \"test_webhook_connection_config\" , \"direction\" : \"two_way\" , \"key\" : \"prep_systems_webhook\" , \"name\" : \"Prep Systems Webhook\" } ] This creates two webhooks that are run sequentially for the Policy before a PrivacyRequest runs. Similarly, to update your list of Post-Execution webhooks on a Policy: 1 PUT /policy/{policy_key}/webhook/post_execution See API docs for more information on how to Update PolicyPreWebhooks and how to Update PolicyPostWebhooks . Update a single webhook To update a single PolicyPreWebhook or PolicyPostWebhook, send a PATCH request to update selected attributes. Note that updates to order can likewise update the order of related webhooks. The following example will update the PolicyPreWebhook with key webhook_hook to be two_way instead of one_way and will update its order from 0 to 1. Because we've defined two PolicyPreWebhooks, this causes the webhook at position 1 to move to position 0. PATCH /policy/{policy_key}/webhook/pre-execution/wake_up_snowflake_db 1 2 3 4 { \"direction\" : \"two_way\" , \"order\" : 1 } Because this PATCH request updated the order of other webhooks, a reordered summary is included under the new_order attribute: Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"resource\" : { \"direction\" : \"two_way\" , \"key\" : \"wake_up_snowflake_db\" , \"name\" : \"Wake up Snowflake DB Webhook\" , \"connection_config\" : \"<TRUNCATED>\" , \"order\" : 1 }, \"new_order\" : [ { \"key\" : \"prep_systems_webhook\" , \"order\" : 0 }, { \"key\" : \"wake_up_snowflake_db\" , \"order\" : 1 } ] } Similarly, to update your a Post-Execution webhook on a Policy: 1 PATCH /policy/{policy_key}/webhook/post_execution/{post_execution_key} See API docs for more information on how to PATCH a PolicyPreWebhook and how to PATCH a PolicyPostWebhook . Policy Webhook request format Before and after running access or erasure requests, fidesops will send requests to any configured webhooks in sequential order with the following request body: POST {user-defined URL} 1 2 3 4 5 6 7 8 9 { \"privacy_request_id\" : \"pri_029832ba-3b84-40f7-8946-82aec6f95448\" , \"direction\" : \"one_way | two_way\" , \"callback_type\" : \"pre | post\" , \"identity\" : { \"email\" : \"customer-1@example.com\" , \"phone_number\" : \"555-5555\" } } Most of these attributes were configured by you: the direction , the callback_type (\"pre\" for PolicyPreWebhook s that will run before PrivacyRequest execution or \"post\" for PolicyPostWebhook s that will run after PrivacyRequestExecution). Known identities are also embedded in the request. For two-way PolicyPreWebhooks , we include specific headers in case you need to pause PrivacyRequest execution while you take care of additional processing on your end. 1 2 3 4 { \"reply-to\" : \"/privacy-request/{privacy_request_id}/resume\" , \"reply-to-token\" : \"<jwe_token>\" } To resume, you should send a request back to the reply-to URL with the reply-to-token . The reply-to-token will expire when your redis cache expires: config.redis.default_ttl_seconds (Fidesops uses the redis cache to temporarily store identity data). At this point, your PrivacyRequest will be given an error status, and you would have to resubmit the PrivacyRequest. Webhook response format Your webhook should respond immediately. If more processing time is needed, either make sure it is configured as a one-way webhook, or reply with halt=True if you want to pause execution and wait for your processing to finish. Note that only PolicyPreWebhooks can pause execution. We don't expect a response from one-way webhooks, but two-way webhooks should respond with the following: 1 2 3 4 5 6 7 { \"derived_identity\" : { \"email\" : \"customer-1@gmail.com\" , \"phone_number\" : \"555-5555\" }, \"halt\" : \"true | false\" } Derived identity is optional: a returned email or phone number will replace currently known emails or phone numbers. Resuming request execution If your webhook needed more processing time, once completed, send a request to the reply-to URL given to you in the original request header with the reply-to-token auth token. POST privacy_request/{privacy-request-id}/resume 1 2 3 4 5 6 { \"derived_identity\" : { \"email\" : \"customer-1@gmail.com\" , \"phone_number\" : \"555-5555\" } } If there are no derived identities, an empty {} request body will suffice. The reply-to-token is a JWE containing the current webhook id, scopes to access the callback endpoint, and the datetime the token is issued. We unpack this and resume the privacy request execution after the specified webhook. The reply-to-token expires after a set amount of time, specified by the config.execution.privacy_request_delay_timeout config variable. Once the redis cache expires, fidesops no longer has the original identity data and the privacy request should be resubmitted.","title":"Configure Policy Webhooks"},{"location":"guides/policy_webhooks/#configure-policy-webhooks","text":"","title":"Configure Policy Webhooks"},{"location":"guides/policy_webhooks/#what-is-a-policy-webhook","text":"A Policy webhook is an HTTPS Callback that you've defined on a Policy to call an external REST API endpoint before or after a Privacy Request executes. You can define as many webhooks as you'd like. Webhooks can be one_way , where we will just ping your API and move on, or two_way , where we will wait for a response. Any derived_identities returned from a two_way webhook will be saved and can be used to locate other user information. For example, a webhook might take a known email identity and use that to find a phone_number derived_identity . Another use case for a Policy Webhook might be to log a user out of your mobile app after you've cleared their data from your system. In this case, you'd create a Policy and a ConnectionConfig to describe the URL to hit to clear the cache. You'd then create a one-way PolicyPostWebhook to run after your PrivacyRequest executes.","title":"What is a Policy webhook?"},{"location":"guides/policy_webhooks/#configuration","text":"Big picture, you will define an https ConnectionConfig that contains the details to make a request to your API endpoint. You will then define a PolicyPreWebhook or a PolicyPostWebhook for a specific Policy using that ConnectionConfig .","title":"Configuration"},{"location":"guides/policy_webhooks/#create-an-https-connectionconfig","text":"The information that describes how to connect to your API endpoint lives on a ConnectionConfig . We also use ConnectionConfigs to connect to databases like PostgreSQL and MongoDB . This same construct can help us store how to connect to an external API endpoint. For more information on ConnectionConfigs, see how to Create a ConnectionConfig. PATCH /v1/connection 1 2 3 4 5 6 7 8 [ { \"name\" : \"My Webhook Connection Configuration\" , \"key\" : \"test_webhook_connection_config\" , \"connection_type\" : \"https\" , \"access\" : \"read\" } ]","title":"Create an HTTPS ConnectionConfig"},{"location":"guides/policy_webhooks/#adding-connectionconfig-secrets","text":"The secret details needed to talk to your API endpoint are defined by making a PUT to the ConnectionConfig Secrets endpoint: These credentials are stored encrypted in the fidesops app database. See API docs on how to Set a ConnectionConfig's Secrets . PUT /v1/connection/test_webhook_connection_config 1 2 3 4 { \"url\" : \"https://www.example.com\" , \"authorization\" : \"Bearer test_38234823482348\" } Note that the authorization secret specified here will be added directly to an authorization header when fidesops later makes a call to the configured webhook: 1 { \"Authorization\" : \"Bearer test_38234823482348\" }","title":"Adding ConnectionConfig secrets"},{"location":"guides/policy_webhooks/#define-pre-execution-or-post-execution-webhooks","text":"After you've defined a ConnectionConfig , you can create lists of webhooks to run before ( PolicyPreWebhooks ) or after ( PolicyPostWebhooks ) a PrivacyRequest is executed. If you are defining PolicyPreWebhooks, all desired PolicyPreWebhooks should be included in the request body in the desired order. Any PolicyPreWebhooks on the Policy not included in the request, will be removed from the Policy. The same applies for PolicyPostWebhooks. To update your list of PolicyPreWebhooks: PUT /policy/{policy_key}/webhook/pre_execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ { \"connection_config_key\" : \"test_webhook_connection_config\" , \"direction\" : \"one_way\" , \"key\" : \"wake_up_snowflake_db\" , \"name\" : \"Wake up Snowflake DB Webhook\" }, { \"connection_config_key\" : \"test_webhook_connection_config\" , \"direction\" : \"two_way\" , \"key\" : \"prep_systems_webhook\" , \"name\" : \"Prep Systems Webhook\" } ] This creates two webhooks that are run sequentially for the Policy before a PrivacyRequest runs. Similarly, to update your list of Post-Execution webhooks on a Policy: 1 PUT /policy/{policy_key}/webhook/post_execution See API docs for more information on how to Update PolicyPreWebhooks and how to Update PolicyPostWebhooks .","title":"Define pre-execution or post-execution webhooks"},{"location":"guides/policy_webhooks/#update-a-single-webhook","text":"To update a single PolicyPreWebhook or PolicyPostWebhook, send a PATCH request to update selected attributes. Note that updates to order can likewise update the order of related webhooks. The following example will update the PolicyPreWebhook with key webhook_hook to be two_way instead of one_way and will update its order from 0 to 1. Because we've defined two PolicyPreWebhooks, this causes the webhook at position 1 to move to position 0. PATCH /policy/{policy_key}/webhook/pre-execution/wake_up_snowflake_db 1 2 3 4 { \"direction\" : \"two_way\" , \"order\" : 1 } Because this PATCH request updated the order of other webhooks, a reordered summary is included under the new_order attribute: Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"resource\" : { \"direction\" : \"two_way\" , \"key\" : \"wake_up_snowflake_db\" , \"name\" : \"Wake up Snowflake DB Webhook\" , \"connection_config\" : \"<TRUNCATED>\" , \"order\" : 1 }, \"new_order\" : [ { \"key\" : \"prep_systems_webhook\" , \"order\" : 0 }, { \"key\" : \"wake_up_snowflake_db\" , \"order\" : 1 } ] } Similarly, to update your a Post-Execution webhook on a Policy: 1 PATCH /policy/{policy_key}/webhook/post_execution/{post_execution_key} See API docs for more information on how to PATCH a PolicyPreWebhook and how to PATCH a PolicyPostWebhook .","title":"Update a single webhook"},{"location":"guides/policy_webhooks/#policy-webhook-request-format","text":"Before and after running access or erasure requests, fidesops will send requests to any configured webhooks in sequential order with the following request body: POST {user-defined URL} 1 2 3 4 5 6 7 8 9 { \"privacy_request_id\" : \"pri_029832ba-3b84-40f7-8946-82aec6f95448\" , \"direction\" : \"one_way | two_way\" , \"callback_type\" : \"pre | post\" , \"identity\" : { \"email\" : \"customer-1@example.com\" , \"phone_number\" : \"555-5555\" } } Most of these attributes were configured by you: the direction , the callback_type (\"pre\" for PolicyPreWebhook s that will run before PrivacyRequest execution or \"post\" for PolicyPostWebhook s that will run after PrivacyRequestExecution). Known identities are also embedded in the request. For two-way PolicyPreWebhooks , we include specific headers in case you need to pause PrivacyRequest execution while you take care of additional processing on your end. 1 2 3 4 { \"reply-to\" : \"/privacy-request/{privacy_request_id}/resume\" , \"reply-to-token\" : \"<jwe_token>\" } To resume, you should send a request back to the reply-to URL with the reply-to-token . The reply-to-token will expire when your redis cache expires: config.redis.default_ttl_seconds (Fidesops uses the redis cache to temporarily store identity data). At this point, your PrivacyRequest will be given an error status, and you would have to resubmit the PrivacyRequest.","title":"Policy Webhook request format"},{"location":"guides/policy_webhooks/#webhook-response-format","text":"Your webhook should respond immediately. If more processing time is needed, either make sure it is configured as a one-way webhook, or reply with halt=True if you want to pause execution and wait for your processing to finish. Note that only PolicyPreWebhooks can pause execution. We don't expect a response from one-way webhooks, but two-way webhooks should respond with the following: 1 2 3 4 5 6 7 { \"derived_identity\" : { \"email\" : \"customer-1@gmail.com\" , \"phone_number\" : \"555-5555\" }, \"halt\" : \"true | false\" } Derived identity is optional: a returned email or phone number will replace currently known emails or phone numbers.","title":"Webhook response format"},{"location":"guides/policy_webhooks/#resuming-request-execution","text":"If your webhook needed more processing time, once completed, send a request to the reply-to URL given to you in the original request header with the reply-to-token auth token. POST privacy_request/{privacy-request-id}/resume 1 2 3 4 5 6 { \"derived_identity\" : { \"email\" : \"customer-1@gmail.com\" , \"phone_number\" : \"555-5555\" } } If there are no derived identities, an empty {} request body will suffice. The reply-to-token is a JWE containing the current webhook id, scopes to access the callback endpoint, and the datetime the token is issued. We unpack this and resume the privacy request execution after the specified webhook. The reply-to-token expires after a set amount of time, specified by the config.execution.privacy_request_delay_timeout config variable. Once the redis cache expires, fidesops no longer has the original identity data and the privacy request should be resubmitted.","title":"Resuming request execution"},{"location":"guides/privacy_requests/","text":"Execute Privacy Requests What is a Privacy Request? A Privacy Request represents a request to perform an action on a user's identity data. The Request object itself identifies the user by email address, phone number, social security number, or other identifiable information. The data that will be affected and how it's affected is described in a Policy object that's associated with the Request. For more information on policies, see the Configuring Policies guide. Submit a Privacy Request You submit a Privacy Request by calling the Submit a Privacy Request operation. Here, we submit a request to apply the a-demo-policy Policy to all target data in the Identity Graph that can be generated from the email address identity@example.com and the phone number +1 (123) 456 7891 . Privacy Requests are executed immediately by default. This setting may be changed in the fidesops.toml configuration file. POST /api/v1/privacy-request 1 2 3 4 5 6 7 8 9 10 11 [ { \"external_id\" : \"a-user-defined-id\" , \"requested_at\" : \"2021-10-31T16:00:00.000Z\" , \"policy_key\" : \"a-demo-policy\" , \"identity\" : { \"email\" : \"identity@example.com\" , \"phone_number\" : \"+1 (123) 456 7891\" } } ] external_id is an optional identifier of your own invention that lets you track the Privacy Request. See How-To: Report on Privacy Requests for more information. requested_at (Optional) is an ISO8601 timestamp that specifies the moment that the request was submitted. Defaults to the created_at time if not specified. policy_key identifies the Policy object to which this request will be applied. See How-To: Configure Request Policies for more information. identities is an array of objects that contain data that identify the users whose data will be affected by the Policy. Each object identifies a single user by AND'ing the object's properties. This request will submit a Privacy Request for execution that applies the a-demo-policy Policy to all target data in the Identity Graph that can be generated from the email address identity@example.com or the phone number +1 (123) 456 7891 . Specifying a external_id enables us to track this Privacy Request with that external_id later on. See How-To: Report on Privacy Requests for more information. policy_key should correspond to a previously configured Policy object. See How-To: Configure Request Policies for more information. A full list of attributes available to set on the Privacy Request can be found in the API docs . Subject Identity Verification To have users verify their identity before their Privacy Request is executed, set the subject_identity_verification_required variable in your fidesops.toml to TRUE . You must also set up an EmailConfig that lets fidesops send automated emails to your users. When a user submits a PrivacyRequest, they will be emailed a six-digit code. They must supply that verification code to fidesops to continue privacy request execution. Until the Privacy Request identity is verified, it will have a status of: identity_unverified . POST api/v1/privacy-request/{privacy_request_id}/verify 1 { \"code\" : \"<verification code here>\" } Request Notifications By default, emails will be sent to users at various points in the request lifecycle. To change this default behavior for any email type, set the variables under the notifications category in your fidesops.toml . You must also set up an EmailConfig that lets fidesops send automated emails to your users. If using a custom privacy center, ensure that you intake an email identity, which is required for email notifications throughout fidesops. Request Receipt An email will be sent to users to notify them that their privacy request has been received. Request Completion Upon access request completion, an email will be sent to users to notify them of request completion, along with a link to download their data, if applicable. Note For security purposes, the data package download link is a one-time link and expires in 24 hrs by default. To change TTL, update the subject_request_download_link_ttl_seconds variable in your fidesops.toml . Request Review An email will be sent to users to notify them when their privacy request has been reviewed. If the privacy request was rejected, the email will include rejection reason. Approve and deny Privacy Requests To review Privacy Requests before they are executed, set the require_manual_request_approval variable in your fidesops.toml to TRUE . To process Privacy Requests, send a list of Privacy Request IDs to the approve or deny endpoints. Both endpoints support processing requests in bulk. PATCH api/v1/privacy-request/administrate/approve 1 2 3 4 5 6 { \"request_ids\" :[ \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" , \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" ] } An optional denial reason can be provided when denying a Privacy Request: PATCH api/v1/privacy-request/administrate/deny 1 2 3 4 5 6 7 { \"request_ids\" :[ \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" , \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" ], \"reason\" : \"Requests denied because they're duplicates\" } Monitor Privacy Requests Privacy Requests can be monitored at any time throughout their execution by submitting any of the following requests: GET api/v1/privacy-request?request_id=<privacy_request_id> GET api/v1/privacy-request?external_id=<external_id> For more detailed examples and further Privacy Request filtering in fidesops, see Reporting on Privacy Requests . Restart failed Privacy Requests To restart a failed Privacy Request from the failed collection, submit a request to: POST /api/v1/privacy-request/<privacy_request_id>/retry with an empty request body. Integrate the Privacy Request flow into existing support tools Alongside generic API interoperability, fidesops provides a direct integration with the OneTrust's DSAR automation flow. Generic API interoperability : Third party services can be authorized by creating additional OAuth clients. Tokens obtained from OAuth clients can be managed and revoked at any time. See authenticating with OAuth for more information. OneTrust : fidesops can be configured to act as (or as part of) the fulfillment layer in OneTrust's Data Subject Request automation flow. See the OneTrust integration guide for more information. Encryption You can optionally encrypt your access request results by supplying an encryption_key string in the request body: We will use the supplied encryption_key to encrypt the contents of your JSON and CSV results using an AES-256 algorithm in GCM mode. When converted to bytes, your encryption_key must be 16 bytes long. The data we return will have the nonce concatenated to the encrypted data. POST /privacy-request 1 2 3 4 5 6 7 8 [ { \"requested_at\" : \"2021-08-30T16:09:37.359Z\" , \"identity\" : { \"email\" : \"customer-1@example.com\" }, \"policy_key\" : \"my_access_policy\" , \"encryption_key\" : \"test--encryption\" } ] Decrypt access request results If you specified an encryption key, we encrypted the access result data using your key and an internally-generated nonce with an AES 256 algorithm in GCM mode. The return value is a 12-byte nonce plus the encrypted data that is all b64encoded together. 1 2 3 +------------------+-------------------+ | nonce (12 bytes) | message (N bytes) | +------------------+-------------------+ For example, pretend you specified an encryption key of test--encryption , and the resulting data was uploaded to S3 in a JSON file: GPUiK9tq5k/HfBnSN+J+OvLXZ+GCisapdI2KGP7A1WK+dz1XHef+hWb/SjszdqdNVGvziyY6GF5KIrvrXgxjZuaAvgU=' . You will need to implement something similar to the snippet below on your end to decrypt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import json import base64 from cryptography.hazmat.primitives.ciphers.aead import AESGCM encrypted : str = \"GPUiK9tq5k/HfBnSN+J+OvLXZ+GCisapdI2KGP7A1WK+dz1XHef+hWb/SjszdqdNVGvziyY6GF5KIrvrXgxjZuaAvgU=\" encryption_key : str = \"test--encryption\" . encode ( \"utf-8\" ) # Only you know this encrypted_combined : bytes = base64 . b64decode ( encrypted ) nonce : bytes = encrypted_combined [ 0 : 12 ] encrypted_message : bytes = encrypted_combined [ 12 :] gcm = AESGCM ( encryption_key ) decrypted_bytes : bytes = gcm . decrypt ( nonce , encrypted_message , nonce ) decrypted_str : str = decrypted_bytes . decode ( \"utf-8\" ) json . loads ( decrypted_str ) 1 >>> { \"street\" : \"test street\" , \"state\" : \"NY\" } If CSV data was uploaded, each CSV in the zipfile was encrypted using a different nonce, so you'll need to follow a similar process for each csv file.","title":"Execute Privacy Requests"},{"location":"guides/privacy_requests/#execute-privacy-requests","text":"","title":"Execute Privacy Requests"},{"location":"guides/privacy_requests/#what-is-a-privacy-request","text":"A Privacy Request represents a request to perform an action on a user's identity data. The Request object itself identifies the user by email address, phone number, social security number, or other identifiable information. The data that will be affected and how it's affected is described in a Policy object that's associated with the Request. For more information on policies, see the Configuring Policies guide.","title":"What is a Privacy Request?"},{"location":"guides/privacy_requests/#submit-a-privacy-request","text":"You submit a Privacy Request by calling the Submit a Privacy Request operation. Here, we submit a request to apply the a-demo-policy Policy to all target data in the Identity Graph that can be generated from the email address identity@example.com and the phone number +1 (123) 456 7891 . Privacy Requests are executed immediately by default. This setting may be changed in the fidesops.toml configuration file. POST /api/v1/privacy-request 1 2 3 4 5 6 7 8 9 10 11 [ { \"external_id\" : \"a-user-defined-id\" , \"requested_at\" : \"2021-10-31T16:00:00.000Z\" , \"policy_key\" : \"a-demo-policy\" , \"identity\" : { \"email\" : \"identity@example.com\" , \"phone_number\" : \"+1 (123) 456 7891\" } } ] external_id is an optional identifier of your own invention that lets you track the Privacy Request. See How-To: Report on Privacy Requests for more information. requested_at (Optional) is an ISO8601 timestamp that specifies the moment that the request was submitted. Defaults to the created_at time if not specified. policy_key identifies the Policy object to which this request will be applied. See How-To: Configure Request Policies for more information. identities is an array of objects that contain data that identify the users whose data will be affected by the Policy. Each object identifies a single user by AND'ing the object's properties. This request will submit a Privacy Request for execution that applies the a-demo-policy Policy to all target data in the Identity Graph that can be generated from the email address identity@example.com or the phone number +1 (123) 456 7891 . Specifying a external_id enables us to track this Privacy Request with that external_id later on. See How-To: Report on Privacy Requests for more information. policy_key should correspond to a previously configured Policy object. See How-To: Configure Request Policies for more information. A full list of attributes available to set on the Privacy Request can be found in the API docs .","title":"Submit a Privacy Request"},{"location":"guides/privacy_requests/#subject-identity-verification","text":"To have users verify their identity before their Privacy Request is executed, set the subject_identity_verification_required variable in your fidesops.toml to TRUE . You must also set up an EmailConfig that lets fidesops send automated emails to your users. When a user submits a PrivacyRequest, they will be emailed a six-digit code. They must supply that verification code to fidesops to continue privacy request execution. Until the Privacy Request identity is verified, it will have a status of: identity_unverified . POST api/v1/privacy-request/{privacy_request_id}/verify 1 { \"code\" : \"<verification code here>\" }","title":"Subject Identity Verification"},{"location":"guides/privacy_requests/#request-notifications","text":"By default, emails will be sent to users at various points in the request lifecycle. To change this default behavior for any email type, set the variables under the notifications category in your fidesops.toml . You must also set up an EmailConfig that lets fidesops send automated emails to your users. If using a custom privacy center, ensure that you intake an email identity, which is required for email notifications throughout fidesops.","title":"Request Notifications"},{"location":"guides/privacy_requests/#request-receipt","text":"An email will be sent to users to notify them that their privacy request has been received.","title":"Request Receipt"},{"location":"guides/privacy_requests/#request-completion","text":"Upon access request completion, an email will be sent to users to notify them of request completion, along with a link to download their data, if applicable. Note For security purposes, the data package download link is a one-time link and expires in 24 hrs by default. To change TTL, update the subject_request_download_link_ttl_seconds variable in your fidesops.toml .","title":"Request Completion"},{"location":"guides/privacy_requests/#request-review","text":"An email will be sent to users to notify them when their privacy request has been reviewed. If the privacy request was rejected, the email will include rejection reason.","title":"Request Review"},{"location":"guides/privacy_requests/#approve-and-deny-privacy-requests","text":"To review Privacy Requests before they are executed, set the require_manual_request_approval variable in your fidesops.toml to TRUE . To process Privacy Requests, send a list of Privacy Request IDs to the approve or deny endpoints. Both endpoints support processing requests in bulk. PATCH api/v1/privacy-request/administrate/approve 1 2 3 4 5 6 { \"request_ids\" :[ \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" , \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" ] } An optional denial reason can be provided when denying a Privacy Request: PATCH api/v1/privacy-request/administrate/deny 1 2 3 4 5 6 7 { \"request_ids\" :[ \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" , \"pri_2d181f15-486d-4bcf-a871-f50ed9f95673\" ], \"reason\" : \"Requests denied because they're duplicates\" }","title":"Approve and deny Privacy Requests"},{"location":"guides/privacy_requests/#monitor-privacy-requests","text":"Privacy Requests can be monitored at any time throughout their execution by submitting any of the following requests: GET api/v1/privacy-request?request_id=<privacy_request_id> GET api/v1/privacy-request?external_id=<external_id> For more detailed examples and further Privacy Request filtering in fidesops, see Reporting on Privacy Requests .","title":"Monitor Privacy Requests"},{"location":"guides/privacy_requests/#restart-failed-privacy-requests","text":"To restart a failed Privacy Request from the failed collection, submit a request to: POST /api/v1/privacy-request/<privacy_request_id>/retry with an empty request body.","title":"Restart failed Privacy Requests"},{"location":"guides/privacy_requests/#integrate-the-privacy-request-flow-into-existing-support-tools","text":"Alongside generic API interoperability, fidesops provides a direct integration with the OneTrust's DSAR automation flow. Generic API interoperability : Third party services can be authorized by creating additional OAuth clients. Tokens obtained from OAuth clients can be managed and revoked at any time. See authenticating with OAuth for more information. OneTrust : fidesops can be configured to act as (or as part of) the fulfillment layer in OneTrust's Data Subject Request automation flow. See the OneTrust integration guide for more information.","title":"Integrate the Privacy Request flow into existing support tools"},{"location":"guides/privacy_requests/#encryption","text":"You can optionally encrypt your access request results by supplying an encryption_key string in the request body: We will use the supplied encryption_key to encrypt the contents of your JSON and CSV results using an AES-256 algorithm in GCM mode. When converted to bytes, your encryption_key must be 16 bytes long. The data we return will have the nonce concatenated to the encrypted data. POST /privacy-request 1 2 3 4 5 6 7 8 [ { \"requested_at\" : \"2021-08-30T16:09:37.359Z\" , \"identity\" : { \"email\" : \"customer-1@example.com\" }, \"policy_key\" : \"my_access_policy\" , \"encryption_key\" : \"test--encryption\" } ]","title":"Encryption"},{"location":"guides/privacy_requests/#decrypt-access-request-results","text":"If you specified an encryption key, we encrypted the access result data using your key and an internally-generated nonce with an AES 256 algorithm in GCM mode. The return value is a 12-byte nonce plus the encrypted data that is all b64encoded together. 1 2 3 +------------------+-------------------+ | nonce (12 bytes) | message (N bytes) | +------------------+-------------------+ For example, pretend you specified an encryption key of test--encryption , and the resulting data was uploaded to S3 in a JSON file: GPUiK9tq5k/HfBnSN+J+OvLXZ+GCisapdI2KGP7A1WK+dz1XHef+hWb/SjszdqdNVGvziyY6GF5KIrvrXgxjZuaAvgU=' . You will need to implement something similar to the snippet below on your end to decrypt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import json import base64 from cryptography.hazmat.primitives.ciphers.aead import AESGCM encrypted : str = \"GPUiK9tq5k/HfBnSN+J+OvLXZ+GCisapdI2KGP7A1WK+dz1XHef+hWb/SjszdqdNVGvziyY6GF5KIrvrXgxjZuaAvgU=\" encryption_key : str = \"test--encryption\" . encode ( \"utf-8\" ) # Only you know this encrypted_combined : bytes = base64 . b64decode ( encrypted ) nonce : bytes = encrypted_combined [ 0 : 12 ] encrypted_message : bytes = encrypted_combined [ 12 :] gcm = AESGCM ( encryption_key ) decrypted_bytes : bytes = gcm . decrypt ( nonce , encrypted_message , nonce ) decrypted_str : str = decrypted_bytes . decode ( \"utf-8\" ) json . loads ( decrypted_str ) 1 >>> { \"street\" : \"test street\" , \"state\" : \"NY\" } If CSV data was uploaded, each CSV in the zipfile was encrypted using a different nonce, so you'll need to follow a similar process for each csv file.","title":"Decrypt access request results"},{"location":"guides/query_execution/","text":"Query Execution Graphs and Traversals Fidesops uses your Datasets to generate a graph of the resources. Based on the identity data you provide, fidesops then generates a specific traversal , which is the order of steps that will be taken to fulfill a specific request. The graph supports both directed and non-directed edges using the optional direction parameter on the relation (non-directional edges may be traversed in either direction). You can preview the queries that will be generated or manually control the order of operations by making relations explicitly directional and with the after Collection parameters. If you specify a Collection that can't be reached, fidesops generates an error. An example graph In this example there are three databases: a mysql database that stores users and their comments, a postgres DB that stores purchase information, and a mongoDB that stores user accounts. Each of them may have related data that we'd like to retrieve. The Dataset specification looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 dataset : - fides_key : mongo_1 collections : - name : users fields : - name : _id fidesops_meta : primary_key : True - name : user_name fidesops_meta : identity : username - name : full_name - name : accounts fields : - name : _id fidesops_meta : primary_key : True - name : name fidesops_meta : references : - dataset : mongo_1 name : users.full_name direction : from - name : comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dataset : - fides_key : mysql_1 collections : - name : users fields : - name : id fidesops_meta : primary_key : True references : - dataset : postgres_1 field : users.id direction : from - name : internal_id - name : comment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 dataset : - fides_key : postgres_1 collections : - name : purchase_items fields : - name : id fidesops_meta : primary_key : True - name : purchase_id fidesops_meta : references : - dataset : postgres_1 field : purchases.id direction : from - name : amount - name : rating - name : purchases fields : - name : id fidesops_meta : primary_key : True - name : user_id fidesops_meta : references : - dataset : postgres_1 field : users.id - name : amount - name : users fields : - name : id fidesops_meta : primary_key : True - name : email fidesops_meta : identity : email - name : address_id We trigger a retrieval with identity data, such as an email address or user ID, that's provided by the user. What we do is... Identify the collections that contain the identity data that belong to the user. Find all related records. Use the data to find all connected data. Continue until we've found all related data. For the first step, we use the concept of an identity . In the fidesops Dataset specification, any field may be marked with an identity notation: 1 2 3 4 5 6 collection : - name : foo fields : - name : bar fidesop_meta : identity : email What this means is that we will initiate the data retrieval process with provided data that looks like {\"email\": \"user@example.com\", \"username\": \"someone\"} by looking for values in the collection users where email == user@example.com . Note that the names of the provided starter data do not need to match the field names we're going to use this data to search. Also note that in this case, since we're providing two pieces of data, we can also choose to start a search using the username provided value. In the above diagram, this means we have enough data to search in both postgres_1.users.email and mongo_1.users.user_name . How does fidesops execute queries? The next step is to follow any links provided in field relationship information. In the abbreviated dataset declarations below, you can see that since we know that mongo_1.accounts data contains data related to mongo_1.users , we can retrieve data from mongo_1.accounts by generating this set of queries: 1 2 3 4 5 6 7 8 9 10 11 # mongo_1 1 . db . users . find ( { \"user_name\" : \"someone\" } , { \"_id\" : 1 , \"full_name\" : 1 } ) 2 . db . accounts . find ( { \"name\" : { \"$in\" :[ < full_name value from ( 1 ) > ] }} , { \"_id\" : 1 , \"comments\" : 1 } ) # postgres_1 3 . select id , address_id from users where email = 'user@example.com' ; 4 . select id , amount from purchases where user_id in [ < id values from ( 3 ) > ] 5 . select id , amount , rating from purchase_items where purchase_id in [ < id values from ( 4 ) > ] # mysql_1 6 . select internal_id , comment from users where id in [ < id values from ( 3 ) > ] Logically, we are creating a linked graph using the connections you've specified between your collections to retrieve your data. Notes about Dataset traversals You can define multiple links between collections, which will generate OR queries like SELECT a,b,c from TABLE_1 where name in (values from TABLE\\_2) OR email in (values from TABLE\\_3) . It's an error to specify a collection in your Dataset can't be reached through the relations you've specified. Fidesops uses your Datasets and your input data to \"solve\" the graph of your collections and how it is traversed. If your Dataset has multiple identity values, you can create a situation where the query behavior depends on the values you provide. In the example above, starting the graph traversal with {\"email\": \"value1\", \"username\":\" value2\"} is valid, but starting with {\"email\": \"value1\"} fails because mongo_1.users is no longer reachable. As shown in the example, you can create queries between Datasets.","title":"Preview Query Execution"},{"location":"guides/query_execution/#query-execution","text":"","title":"Query Execution"},{"location":"guides/query_execution/#graphs-and-traversals","text":"Fidesops uses your Datasets to generate a graph of the resources. Based on the identity data you provide, fidesops then generates a specific traversal , which is the order of steps that will be taken to fulfill a specific request. The graph supports both directed and non-directed edges using the optional direction parameter on the relation (non-directional edges may be traversed in either direction). You can preview the queries that will be generated or manually control the order of operations by making relations explicitly directional and with the after Collection parameters. If you specify a Collection that can't be reached, fidesops generates an error.","title":"Graphs and Traversals"},{"location":"guides/query_execution/#an-example-graph","text":"In this example there are three databases: a mysql database that stores users and their comments, a postgres DB that stores purchase information, and a mongoDB that stores user accounts. Each of them may have related data that we'd like to retrieve. The Dataset specification looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 dataset : - fides_key : mongo_1 collections : - name : users fields : - name : _id fidesops_meta : primary_key : True - name : user_name fidesops_meta : identity : username - name : full_name - name : accounts fields : - name : _id fidesops_meta : primary_key : True - name : name fidesops_meta : references : - dataset : mongo_1 name : users.full_name direction : from - name : comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dataset : - fides_key : mysql_1 collections : - name : users fields : - name : id fidesops_meta : primary_key : True references : - dataset : postgres_1 field : users.id direction : from - name : internal_id - name : comment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 dataset : - fides_key : postgres_1 collections : - name : purchase_items fields : - name : id fidesops_meta : primary_key : True - name : purchase_id fidesops_meta : references : - dataset : postgres_1 field : purchases.id direction : from - name : amount - name : rating - name : purchases fields : - name : id fidesops_meta : primary_key : True - name : user_id fidesops_meta : references : - dataset : postgres_1 field : users.id - name : amount - name : users fields : - name : id fidesops_meta : primary_key : True - name : email fidesops_meta : identity : email - name : address_id We trigger a retrieval with identity data, such as an email address or user ID, that's provided by the user. What we do is... Identify the collections that contain the identity data that belong to the user. Find all related records. Use the data to find all connected data. Continue until we've found all related data. For the first step, we use the concept of an identity . In the fidesops Dataset specification, any field may be marked with an identity notation: 1 2 3 4 5 6 collection : - name : foo fields : - name : bar fidesop_meta : identity : email What this means is that we will initiate the data retrieval process with provided data that looks like {\"email\": \"user@example.com\", \"username\": \"someone\"} by looking for values in the collection users where email == user@example.com . Note that the names of the provided starter data do not need to match the field names we're going to use this data to search. Also note that in this case, since we're providing two pieces of data, we can also choose to start a search using the username provided value. In the above diagram, this means we have enough data to search in both postgres_1.users.email and mongo_1.users.user_name .","title":"An example graph"},{"location":"guides/query_execution/#how-does-fidesops-execute-queries","text":"The next step is to follow any links provided in field relationship information. In the abbreviated dataset declarations below, you can see that since we know that mongo_1.accounts data contains data related to mongo_1.users , we can retrieve data from mongo_1.accounts by generating this set of queries: 1 2 3 4 5 6 7 8 9 10 11 # mongo_1 1 . db . users . find ( { \"user_name\" : \"someone\" } , { \"_id\" : 1 , \"full_name\" : 1 } ) 2 . db . accounts . find ( { \"name\" : { \"$in\" :[ < full_name value from ( 1 ) > ] }} , { \"_id\" : 1 , \"comments\" : 1 } ) # postgres_1 3 . select id , address_id from users where email = 'user@example.com' ; 4 . select id , amount from purchases where user_id in [ < id values from ( 3 ) > ] 5 . select id , amount , rating from purchase_items where purchase_id in [ < id values from ( 4 ) > ] # mysql_1 6 . select internal_id , comment from users where id in [ < id values from ( 3 ) > ] Logically, we are creating a linked graph using the connections you've specified between your collections to retrieve your data.","title":"How does fidesops execute queries?"},{"location":"guides/query_execution/#notes-about-dataset-traversals","text":"You can define multiple links between collections, which will generate OR queries like SELECT a,b,c from TABLE_1 where name in (values from TABLE\\_2) OR email in (values from TABLE\\_3) . It's an error to specify a collection in your Dataset can't be reached through the relations you've specified. Fidesops uses your Datasets and your input data to \"solve\" the graph of your collections and how it is traversed. If your Dataset has multiple identity values, you can create a situation where the query behavior depends on the values you provide. In the example above, starting the graph traversal with {\"email\": \"value1\", \"username\":\" value2\"} is valid, but starting with {\"email\": \"value1\"} fails because mongo_1.users is no longer reachable. As shown in the example, you can create queries between Datasets.","title":"Notes about Dataset traversals"},{"location":"guides/reporting/","text":"Report on Privacy Requests Overview The reporting feature allows you to fetch information about privacy requests. You can opt for high-level status information, or get more detailed information about the status of the requests on each of your collections. View high-level statuses This request displays concise, high-level information for all your privacy requests including their status and related timestamps. Check out the API docs here . GET api/v1/privacy-request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"items\" : [ { \"id\" : \"pri_5f4feff5-fb60-4286-82bd-7e0748ce90ac\" , \"created_at\" : \"2021-10-04T17:36:32.223287+00:00\" , \"started_processing_at\" : \"2021-10-04T17:36:37.248880+00:00\" , \"finished_processing_at\" : \"2021-10-04T17:36:37.263121+00:00\" , \"status\" : \"pending\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } View a single privacy request Use the id query param to view the high level status of a single privacy request. 1 GET api/v1/privacy-request?request_id=<privacy_request_id> If an external_id was provided at request creation, we can also track the privacy request using: 1 GET api/v1/privacy-request?external_id=<external_id> Please note: These parameters will return matching privacy requests based on startswith matches. Filtering options Use the following query params to further filter your privacy requests. Filters can be chained, for example, 1 GET api/v1/privacy-request?created_gt=2021-10-01&created_lt=2021-10-05&status=pending id status (one of in_processing , pending , paused , complete , or error ) created_lt created_gt started_lt started_gt completed_lt completed_gt errored_lt errored_gt You can filter for multiple statuses by repeating the status query param: 1 GET api/v1/privacy-request?status=paused&status=complete View privacy request logs To view all the execution logs for a privacy request, visit /api/v1/privacy-request/{privacy_request_id}/logs . Embedded logs in the previous endpoints are truncated at 50 logs. Check out the API docs here . View a request's identity data Use the optional include_identities query param to include all identity data that was submitted for the Privacy Request. Due to the nature of how fidesops stores identity data, this data will expire automatically according to the FIDESOPS__REDIS__DEFAULT_TTL_SECONDS variable. If the identity data fetched by include_identities has expired, an empty JSON dictionary will be returned. View individual request log details Use the verbose query param to see more details about individual collections visited as part of the Privacy Request along with individual statuses. Individual collection statuses include in_processing , retrying , complete or error . You may see multiple logs for each collection as they reach different steps in the lifecycle. verbose will embed a \u201cresults\u201d key in the response, with both audit logs containing information about the overall request, as well as execution logs grouped by dataset name. In the example below, we have two datasets: my-mongo-db and my-postgres-db . There are two execution logs for my-mongo-db (when the flights collection is starting execution and when the flights collection has finished) and two execution logs for my-postgres-db (when the order collection is starting and finishing execution). fields_affected are the fields that were potentially returned or masked based on the Rules you've specified on the Policy. The embedded execution logs are automatically truncated at 50 logs, so to view the entire list of logs, visit the execution logs endpoint separately. There are also \"Request approved\" and \"Request finished\" audit logs included in the response. GET api/v1/privacy-request?request_id={privacy_request_id}&verbose=True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 { \"items\" : [ { \"id\" : \"pri_2e0655c3-7a76-425e-8c4c-52fee32ce14b\" , \"created_at\" : \"2022-02-28T16:38:03.878898+00:00\" , \"started_processing_at\" : \"2022-02-28T16:38:04.021763+00:00\" , \"finished_processing_at\" : \"2022-02-28T16:38:06.211547+00:00\" , \"status\" : \"complete\" , \"external_id\" : null , \"results\" : { \"Request approved\" : [ { \"collection_name\" : null , \"fields_affected\" : null , \"message\" : \"\" , \"action_type\" : null , \"status\" : \"approved\" , \"updated_at\" : \"2022-08-11T14:03:37.679732+00:00\" , \"user_id\" : \"system\" } ], \"my-mongo-db\" : [ { \"collection_name\" : \"flights\" , \"fields_affected\" : [], \"message\" : \"starting\" , \"action_type\" : \"access\" , \"status\" : \"in_processing\" , \"updated_at\" : \"2022-02-28T16:38:04.668513+00:00\" }, { \"collection_name\" : \"flights\" , \"fields_affected\" : [ { \"path\" : \"mongo_test:flights:passenger_information.full_name\" , \"field_name\" : \"passenger_information.full_name\" , \"data_categories\" : [ \"user.name\" ] } ], \"message\" : \"success\" , \"action_type\" : \"access\" , \"status\" : \"complete\" , \"updated_at\" : \"2022-02-28T16:38:04.727094+00:00\" , \"user_id\" : null } ], \"my-postgres-db\" : [ { \"collection_name\" : \"order\" , \"fields_affected\" : [], \"message\" : \"starting\" , \"action_type\" : \"access\" , \"status\" : \"in_processing\" , \"updated_at\" : \"2022-02-28T16:38:04.668513+00:00\" }, { \"collection_name\" : \"order\" , \"fields_affected\" : [ { \"path\" : \"order.customer_name\" , \"field_name\" : \"name\" , \"data_categories\" : [ \"user.name\" ] } ], \"message\" : \"success\" , \"action_type\" : \"access\" , \"status\" : \"complete\" , \"updated_at\" : \"2022-02-28T16:39:04.668513+00:00\" , \"user_id\" : null } ] }, \"Request finished\" : [ { \"collection_name\" : null , \"fields_affected\" : null , \"message\" : \"\" , \"action_type\" : null , \"status\" : \"finished\" , \"updated_at\" : \"2022-08-11T14:04:29.611878+00:00\" , \"user_id\" : \"system\" } ] } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } Download all privacy requests as a CSV To get all privacy requests in CSV format, use the download_csv query param: GET api/v1/privacy-request/?download_csv=True 1 2 Time received,Subject identity,Policy key,Request status,Reviewer,Time approved/denied 2022-03-14 16:53:28.869258+00:00,{'email': 'customer-1@example.com'},my_primary_policy,complete,fid_16ffde2f-613b-4f79-bbae-41420b0f836b,2022-03-14 16:54:08.804283+00:00 Paused or failed request details A privacy request may pause when manual input is needed from the user, or it might fail for various reason on a specific collection. To retrieve information to resume or retry a privacy request, the following endpoint is available: 1 GET api/v1/privacy-request?request_id=<privacy_request_id> Paused access request example The request below is in a paused state because we're waiting on manual input from the user to proceed. If we look at the action_required_details key, we can see that the request paused execution during the access step of the manual_key:filing_cabinet collection. The action_needed.locators field shows the user they should fetch the record in the filing cabinet with a customer_id of 72909 , and pull the authorized_user , customer_id , id , and payment_card_id fields from that record. These values should be manually uploaded to the resume_endpoint . See the Manual Data guides for more information on resuming a paused access request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"items\" : [ { \"id\" : \"pri_ed4a6b7d-deab-489a-9a9f-9c2b19cd0713\" , \"created_at\" : \"2022-06-06T20:12:28.809815+00:00\" , \"started_processing_at\" : \"2022-06-06T20:12:28.986462+00:00\" , ... , \"action_required_details\" : { \"step\" : \"access\" , \"collection\" : \"manual_key:filing_cabinet\" , \"action_needed\" : [ { \"locators\" : { \"customer_id\" : [ 72909 ] }, \"get\" : [ \"authorized_user\" , \"customer_id\" , \"id\" , \"payment_card_id\" ], \"update\" : null } ] }, \"resume_endpoint\" : \"/privacy-request/pri_ed4a6b7d-deab-489a-9a9f-9c2b19cd0713/manual_input\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } Paused erasure request example The request below is in a paused state because we're waiting on the user to confirm they've masked the appropriate data before proceeding. The action_required_details shows us that the request paused execution during the erasure step of the manual_key:filing_cabinet collection. Looking at action_needed.locators field, we can see that the user should find the record in the filing cabinet with an id of 2, and replace its authorized_user with None . A confirmation of the masked records count should be uploaded to the resume_endpoint See the Manual Data guides for more information on resuming a paused erasure request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"items\" : [ { \"id\" : \"pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec\" , \"created_at\" : \"2022-06-06T20:22:05.436361+00:00\" , \"started_processing_at\" : \"2022-06-06T20:22:05.473280+00:00\" , \"finished_processing_at\" : null , \"status\" : \"paused\" , ... , \"action_required_details\" : { \"step\" : \"erasure\" , \"collection\" : \"manual_key:filing_cabinet\" , \"action_needed\" : [ { \"locators\" : { \"id\" : 2 }, \"get\" : null , \"update\" : { \"authorized_user\" : null } } ] }, \"resume_endpoint\" : \"/privacy-request/pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec/erasure_confirm\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 } Failed request example The below request is an error state because something failed in the erasure step of the postgres_dataset:payment_card collection. After troubleshooting the issues with your postgres connection, you would resume the request with a POST to the resume_endpoint . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"items\" : [ { \"id\" : \"pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec\" , \"created_at\" : \"2022-06-06T20:22:05.436361+00:00\" , \"started_processing_at\" : \"2022-06-06T20:22:05.473280+00:00\" , \"finished_processing_at\" : null , \"status\" : \"error\" , ... , \"action_required_details\" : { \"step\" : \"erasure\" , \"collection\" : \"postgres_dataset:payment_card\" , \"action_needed\" : null }, \"resume_endpoint\" : \"/privacy-request/pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec/retry\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Report on Privacy Requests"},{"location":"guides/reporting/#report-on-privacy-requests","text":"","title":"Report on Privacy Requests"},{"location":"guides/reporting/#overview","text":"The reporting feature allows you to fetch information about privacy requests. You can opt for high-level status information, or get more detailed information about the status of the requests on each of your collections.","title":"Overview"},{"location":"guides/reporting/#view-high-level-statuses","text":"This request displays concise, high-level information for all your privacy requests including their status and related timestamps. Check out the API docs here . GET api/v1/privacy-request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"items\" : [ { \"id\" : \"pri_5f4feff5-fb60-4286-82bd-7e0748ce90ac\" , \"created_at\" : \"2021-10-04T17:36:32.223287+00:00\" , \"started_processing_at\" : \"2021-10-04T17:36:37.248880+00:00\" , \"finished_processing_at\" : \"2021-10-04T17:36:37.263121+00:00\" , \"status\" : \"pending\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"View high-level statuses"},{"location":"guides/reporting/#view-a-single-privacy-request","text":"Use the id query param to view the high level status of a single privacy request. 1 GET api/v1/privacy-request?request_id=<privacy_request_id> If an external_id was provided at request creation, we can also track the privacy request using: 1 GET api/v1/privacy-request?external_id=<external_id> Please note: These parameters will return matching privacy requests based on startswith matches.","title":"View a single privacy request"},{"location":"guides/reporting/#filtering-options","text":"Use the following query params to further filter your privacy requests. Filters can be chained, for example, 1 GET api/v1/privacy-request?created_gt=2021-10-01&created_lt=2021-10-05&status=pending id status (one of in_processing , pending , paused , complete , or error ) created_lt created_gt started_lt started_gt completed_lt completed_gt errored_lt errored_gt You can filter for multiple statuses by repeating the status query param: 1 GET api/v1/privacy-request?status=paused&status=complete","title":"Filtering options"},{"location":"guides/reporting/#view-privacy-request-logs","text":"To view all the execution logs for a privacy request, visit /api/v1/privacy-request/{privacy_request_id}/logs . Embedded logs in the previous endpoints are truncated at 50 logs. Check out the API docs here .","title":"View privacy request logs"},{"location":"guides/reporting/#view-a-requests-identity-data","text":"Use the optional include_identities query param to include all identity data that was submitted for the Privacy Request. Due to the nature of how fidesops stores identity data, this data will expire automatically according to the FIDESOPS__REDIS__DEFAULT_TTL_SECONDS variable. If the identity data fetched by include_identities has expired, an empty JSON dictionary will be returned.","title":"View a request's identity data"},{"location":"guides/reporting/#view-individual-request-log-details","text":"Use the verbose query param to see more details about individual collections visited as part of the Privacy Request along with individual statuses. Individual collection statuses include in_processing , retrying , complete or error . You may see multiple logs for each collection as they reach different steps in the lifecycle. verbose will embed a \u201cresults\u201d key in the response, with both audit logs containing information about the overall request, as well as execution logs grouped by dataset name. In the example below, we have two datasets: my-mongo-db and my-postgres-db . There are two execution logs for my-mongo-db (when the flights collection is starting execution and when the flights collection has finished) and two execution logs for my-postgres-db (when the order collection is starting and finishing execution). fields_affected are the fields that were potentially returned or masked based on the Rules you've specified on the Policy. The embedded execution logs are automatically truncated at 50 logs, so to view the entire list of logs, visit the execution logs endpoint separately. There are also \"Request approved\" and \"Request finished\" audit logs included in the response. GET api/v1/privacy-request?request_id={privacy_request_id}&verbose=True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 { \"items\" : [ { \"id\" : \"pri_2e0655c3-7a76-425e-8c4c-52fee32ce14b\" , \"created_at\" : \"2022-02-28T16:38:03.878898+00:00\" , \"started_processing_at\" : \"2022-02-28T16:38:04.021763+00:00\" , \"finished_processing_at\" : \"2022-02-28T16:38:06.211547+00:00\" , \"status\" : \"complete\" , \"external_id\" : null , \"results\" : { \"Request approved\" : [ { \"collection_name\" : null , \"fields_affected\" : null , \"message\" : \"\" , \"action_type\" : null , \"status\" : \"approved\" , \"updated_at\" : \"2022-08-11T14:03:37.679732+00:00\" , \"user_id\" : \"system\" } ], \"my-mongo-db\" : [ { \"collection_name\" : \"flights\" , \"fields_affected\" : [], \"message\" : \"starting\" , \"action_type\" : \"access\" , \"status\" : \"in_processing\" , \"updated_at\" : \"2022-02-28T16:38:04.668513+00:00\" }, { \"collection_name\" : \"flights\" , \"fields_affected\" : [ { \"path\" : \"mongo_test:flights:passenger_information.full_name\" , \"field_name\" : \"passenger_information.full_name\" , \"data_categories\" : [ \"user.name\" ] } ], \"message\" : \"success\" , \"action_type\" : \"access\" , \"status\" : \"complete\" , \"updated_at\" : \"2022-02-28T16:38:04.727094+00:00\" , \"user_id\" : null } ], \"my-postgres-db\" : [ { \"collection_name\" : \"order\" , \"fields_affected\" : [], \"message\" : \"starting\" , \"action_type\" : \"access\" , \"status\" : \"in_processing\" , \"updated_at\" : \"2022-02-28T16:38:04.668513+00:00\" }, { \"collection_name\" : \"order\" , \"fields_affected\" : [ { \"path\" : \"order.customer_name\" , \"field_name\" : \"name\" , \"data_categories\" : [ \"user.name\" ] } ], \"message\" : \"success\" , \"action_type\" : \"access\" , \"status\" : \"complete\" , \"updated_at\" : \"2022-02-28T16:39:04.668513+00:00\" , \"user_id\" : null } ] }, \"Request finished\" : [ { \"collection_name\" : null , \"fields_affected\" : null , \"message\" : \"\" , \"action_type\" : null , \"status\" : \"finished\" , \"updated_at\" : \"2022-08-11T14:04:29.611878+00:00\" , \"user_id\" : \"system\" } ] } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"View individual request log details"},{"location":"guides/reporting/#download-all-privacy-requests-as-a-csv","text":"To get all privacy requests in CSV format, use the download_csv query param: GET api/v1/privacy-request/?download_csv=True 1 2 Time received,Subject identity,Policy key,Request status,Reviewer,Time approved/denied 2022-03-14 16:53:28.869258+00:00,{'email': 'customer-1@example.com'},my_primary_policy,complete,fid_16ffde2f-613b-4f79-bbae-41420b0f836b,2022-03-14 16:54:08.804283+00:00","title":"Download all privacy requests as a CSV"},{"location":"guides/reporting/#paused-or-failed-request-details","text":"A privacy request may pause when manual input is needed from the user, or it might fail for various reason on a specific collection. To retrieve information to resume or retry a privacy request, the following endpoint is available: 1 GET api/v1/privacy-request?request_id=<privacy_request_id>","title":"Paused or failed request details"},{"location":"guides/reporting/#paused-access-request-example","text":"The request below is in a paused state because we're waiting on manual input from the user to proceed. If we look at the action_required_details key, we can see that the request paused execution during the access step of the manual_key:filing_cabinet collection. The action_needed.locators field shows the user they should fetch the record in the filing cabinet with a customer_id of 72909 , and pull the authorized_user , customer_id , id , and payment_card_id fields from that record. These values should be manually uploaded to the resume_endpoint . See the Manual Data guides for more information on resuming a paused access request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"items\" : [ { \"id\" : \"pri_ed4a6b7d-deab-489a-9a9f-9c2b19cd0713\" , \"created_at\" : \"2022-06-06T20:12:28.809815+00:00\" , \"started_processing_at\" : \"2022-06-06T20:12:28.986462+00:00\" , ... , \"action_required_details\" : { \"step\" : \"access\" , \"collection\" : \"manual_key:filing_cabinet\" , \"action_needed\" : [ { \"locators\" : { \"customer_id\" : [ 72909 ] }, \"get\" : [ \"authorized_user\" , \"customer_id\" , \"id\" , \"payment_card_id\" ], \"update\" : null } ] }, \"resume_endpoint\" : \"/privacy-request/pri_ed4a6b7d-deab-489a-9a9f-9c2b19cd0713/manual_input\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Paused access request example"},{"location":"guides/reporting/#paused-erasure-request-example","text":"The request below is in a paused state because we're waiting on the user to confirm they've masked the appropriate data before proceeding. The action_required_details shows us that the request paused execution during the erasure step of the manual_key:filing_cabinet collection. Looking at action_needed.locators field, we can see that the user should find the record in the filing cabinet with an id of 2, and replace its authorized_user with None . A confirmation of the masked records count should be uploaded to the resume_endpoint See the Manual Data guides for more information on resuming a paused erasure request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"items\" : [ { \"id\" : \"pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec\" , \"created_at\" : \"2022-06-06T20:22:05.436361+00:00\" , \"started_processing_at\" : \"2022-06-06T20:22:05.473280+00:00\" , \"finished_processing_at\" : null , \"status\" : \"paused\" , ... , \"action_required_details\" : { \"step\" : \"erasure\" , \"collection\" : \"manual_key:filing_cabinet\" , \"action_needed\" : [ { \"locators\" : { \"id\" : 2 }, \"get\" : null , \"update\" : { \"authorized_user\" : null } } ] }, \"resume_endpoint\" : \"/privacy-request/pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec/erasure_confirm\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Paused erasure request example"},{"location":"guides/reporting/#failed-request-example","text":"The below request is an error state because something failed in the erasure step of the postgres_dataset:payment_card collection. After troubleshooting the issues with your postgres connection, you would resume the request with a POST to the resume_endpoint . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"items\" : [ { \"id\" : \"pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec\" , \"created_at\" : \"2022-06-06T20:22:05.436361+00:00\" , \"started_processing_at\" : \"2022-06-06T20:22:05.473280+00:00\" , \"finished_processing_at\" : null , \"status\" : \"error\" , ... , \"action_required_details\" : { \"step\" : \"erasure\" , \"collection\" : \"postgres_dataset:payment_card\" , \"action_needed\" : null }, \"resume_endpoint\" : \"/privacy-request/pri_59ea0129-fc6d-4a12-a5bd-2ee647bf5cec/retry\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 50 }","title":"Failed request example"},{"location":"guides/storage/","text":"Configure Storage Destinations Overview Access requests will produce a data package upon completion. This data will need to be uploaded to a storage destination (e.g. an S3 bucket). Fidesops never stores privacy request results locally, so you\u2019ll need to configure at least one storage destination if you wish to process Access requests. Storage destinations are configured on Rules. Multiple destinations can be configured, each of which might be used by different rules. Read more about configuring rules here Each unique destination is configured using a \"StorageConfig\", which you can create and manage via the API. To configure a StorageConfig, you'll first need to choose a storage destination type. fidesops currently supports the following types: local - This saves upload packages locally, generating a fides_uploads directory at the root of this project. This destination type should be used only for testing purposes, never to process real-world access requests. S3 - S3 upload is straightforward, in which files are uploaded in an S3 bucket of your choosing upon completion of access requests. Use S3 if you simply need a place to store those files. OneTrust - A OneTrust storage destination should be configured if you wish to use fidesops to process requests from an existing OneTrust integration. Read more about how our OneTrust integration works here Configuration Let's get started. To create a new StorageConfig, use the following endpoint ( API docs here ): PATCH {host}/api/v1/storage/config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"destinations\" : [ { \"name\" : s tr , \"key\" : FidesOpsKey (op t io nal ) , \"type\" : s tr , \"format\" : s tr \"details\" : { # s 3 \"auth_method\" : s tr , \"bucket\" : s tr , \"naming\" : s tr , # o netrust \"service_name\" : s tr , \"onetrust_polling_hr\" : i nt , \"onetrust_polling_day_of_week\" : i nt } } ] } Params: name : A unique user-friendly name for your storage destination. key : A unique key used to manage your storage destination. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . type : Type of storage destination. Supported types include s3 , onetrust , and local . You may configure multiple destinations of the same type. format : Format of uploaded data. Supported formats include json and csv . For OneTrust and local destination types, use json . Additional params needed for S3: auth_method : Authentication method for creating a session with S3, either automatic or secret_keys . bucket : Name of bucket in S3. naming : This defines how the uploaded files will be named. Currently, fidesops only supports upload file naming by request_id . Use this value for all your storage destinations. Additional params needed for OneTrust: service_name : Name of your service / company. This informs OneTrust from where the data obtained from a given access request originated. onetrust_polling_hr : Hour, in UTC timezone, at which to poll OneTrust for new requests. Accepts an int from 0-23, where 0 is midnight. E.g. 7 is 7am UTC. onetrust_polling_day_of_week : Day on which to poll OneTrust for new requests. Accepts an int from 0-6 where 0 is Sunday. E.g. 1 is Monday. Additional params needed for local: naming : This defines how the uploaded files will be named. Currently, fidesops only supports upload file naming by request_id . Use this value for all your storage destinations. On success, the response from the above endpoint will include a storage_key for each destination. Example response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"id\" : \"sto_fe4e4dc0-b5d3-4ac1-bfcd-86e60e9891b9\" , \"name\" : \"s3 storage 2\" , \"type\" : \"s3\" , \"details\" : { \"auth_method\" : \"secret_keys\" , \"bucket\" : \"my-bucket\" , \"naming\" : \"request_id\" , \"object_name\" : \"requests\" }, \"key\" : \"s3_storage_2\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 1 } Authentication Next, you'll need to authenticate secrets with the specific storage destination. Authentication is not needed for the local destination type. Use the storage_key obtained from above in the following endpoint ( API docs here ): PUT {host}/api/v1/storage/config/{storage_key}/secret 1 2 3 4 5 6 7 8 9 { # s 3 \"aws_access_key_id\" : s tr , \"aws_secret_access_key\" : s tr # o netrust \"onetrust_hostname\" : s tr \"onetrust_client_id\" : s tr \"onetrust_client_secret\" : s tr } Params needed for S3: - aws_access_key_id : AWS access key id, obtained from AWS console. - aws_secret_access_key : AWS secret access key, obtained from AWS console. Fidesops also supports automatically creating a session for S3. If your auth_method is set to automatic , no secrets need to be provided. Boto3 will look for credentials on the server. Params needed for OneTrust: - onetrust_hostname : Your unique OneTrust hostname, used to call OneTrust REST APIs, e.g. my-company.onetrust - onetrust_client_id : OneTrust client id, obtained from OneTrust portal. - onetrust_client_secret : OneTrust client id, obtained from OneTrust portal. Currently, we do not save the secrets if credentials fail authentication with the given storage destination. Testing To test that your storage destination works correctly, you may hit the upload endpoint directly, where request_id in the path is an arbitrary string. Keep in mind that OneTrust destinations will need to be tested end-to-end, using the OneTrust interface to approve a test privacy request. To upload data to a storage destination of choice ( api docs here ): PUT {host}/api/v1/storage/{request_id} 1 2 3 4 5 6 { \"storage_key\" : { s t orage_key }, \"data\" : { # da ta here } } Params: storage_key : key associated with the storage destination data : dict of arbitrary data you wish to upload to storage destination. Extensibility Need a different storage destination? Fidesops can be extended to support additional storage destinations by: Add destination-specific enums in src/fidesops/ops/schemas/storage/storage.py Implement an authenticator in src/fidesops/ops/service/storage/storage_authenticator_service.py Implement the uploader in src/fidesops/ops/service/storage/storage_uploader_service.py","title":"Configure Storage Destinations"},{"location":"guides/storage/#configure-storage-destinations","text":"","title":"Configure Storage Destinations"},{"location":"guides/storage/#overview","text":"Access requests will produce a data package upon completion. This data will need to be uploaded to a storage destination (e.g. an S3 bucket). Fidesops never stores privacy request results locally, so you\u2019ll need to configure at least one storage destination if you wish to process Access requests. Storage destinations are configured on Rules. Multiple destinations can be configured, each of which might be used by different rules. Read more about configuring rules here Each unique destination is configured using a \"StorageConfig\", which you can create and manage via the API. To configure a StorageConfig, you'll first need to choose a storage destination type. fidesops currently supports the following types: local - This saves upload packages locally, generating a fides_uploads directory at the root of this project. This destination type should be used only for testing purposes, never to process real-world access requests. S3 - S3 upload is straightforward, in which files are uploaded in an S3 bucket of your choosing upon completion of access requests. Use S3 if you simply need a place to store those files. OneTrust - A OneTrust storage destination should be configured if you wish to use fidesops to process requests from an existing OneTrust integration. Read more about how our OneTrust integration works here","title":"Overview"},{"location":"guides/storage/#configuration","text":"Let's get started. To create a new StorageConfig, use the following endpoint ( API docs here ): PATCH {host}/api/v1/storage/config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"destinations\" : [ { \"name\" : s tr , \"key\" : FidesOpsKey (op t io nal ) , \"type\" : s tr , \"format\" : s tr \"details\" : { # s 3 \"auth_method\" : s tr , \"bucket\" : s tr , \"naming\" : s tr , # o netrust \"service_name\" : s tr , \"onetrust_polling_hr\" : i nt , \"onetrust_polling_day_of_week\" : i nt } } ] } Params: name : A unique user-friendly name for your storage destination. key : A unique key used to manage your storage destination. This is auto-generated from name if left blank. Accepted values are alphanumeric, _ , and . . type : Type of storage destination. Supported types include s3 , onetrust , and local . You may configure multiple destinations of the same type. format : Format of uploaded data. Supported formats include json and csv . For OneTrust and local destination types, use json . Additional params needed for S3: auth_method : Authentication method for creating a session with S3, either automatic or secret_keys . bucket : Name of bucket in S3. naming : This defines how the uploaded files will be named. Currently, fidesops only supports upload file naming by request_id . Use this value for all your storage destinations. Additional params needed for OneTrust: service_name : Name of your service / company. This informs OneTrust from where the data obtained from a given access request originated. onetrust_polling_hr : Hour, in UTC timezone, at which to poll OneTrust for new requests. Accepts an int from 0-23, where 0 is midnight. E.g. 7 is 7am UTC. onetrust_polling_day_of_week : Day on which to poll OneTrust for new requests. Accepts an int from 0-6 where 0 is Sunday. E.g. 1 is Monday. Additional params needed for local: naming : This defines how the uploaded files will be named. Currently, fidesops only supports upload file naming by request_id . Use this value for all your storage destinations. On success, the response from the above endpoint will include a storage_key for each destination. Example response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"items\" : [ { \"id\" : \"sto_fe4e4dc0-b5d3-4ac1-bfcd-86e60e9891b9\" , \"name\" : \"s3 storage 2\" , \"type\" : \"s3\" , \"details\" : { \"auth_method\" : \"secret_keys\" , \"bucket\" : \"my-bucket\" , \"naming\" : \"request_id\" , \"object_name\" : \"requests\" }, \"key\" : \"s3_storage_2\" } ], \"total\" : 1 , \"page\" : 1 , \"size\" : 1 }","title":"Configuration"},{"location":"guides/storage/#authentication","text":"Next, you'll need to authenticate secrets with the specific storage destination. Authentication is not needed for the local destination type. Use the storage_key obtained from above in the following endpoint ( API docs here ): PUT {host}/api/v1/storage/config/{storage_key}/secret 1 2 3 4 5 6 7 8 9 { # s 3 \"aws_access_key_id\" : s tr , \"aws_secret_access_key\" : s tr # o netrust \"onetrust_hostname\" : s tr \"onetrust_client_id\" : s tr \"onetrust_client_secret\" : s tr } Params needed for S3: - aws_access_key_id : AWS access key id, obtained from AWS console. - aws_secret_access_key : AWS secret access key, obtained from AWS console. Fidesops also supports automatically creating a session for S3. If your auth_method is set to automatic , no secrets need to be provided. Boto3 will look for credentials on the server. Params needed for OneTrust: - onetrust_hostname : Your unique OneTrust hostname, used to call OneTrust REST APIs, e.g. my-company.onetrust - onetrust_client_id : OneTrust client id, obtained from OneTrust portal. - onetrust_client_secret : OneTrust client id, obtained from OneTrust portal. Currently, we do not save the secrets if credentials fail authentication with the given storage destination.","title":"Authentication"},{"location":"guides/storage/#testing","text":"To test that your storage destination works correctly, you may hit the upload endpoint directly, where request_id in the path is an arbitrary string. Keep in mind that OneTrust destinations will need to be tested end-to-end, using the OneTrust interface to approve a test privacy request. To upload data to a storage destination of choice ( api docs here ): PUT {host}/api/v1/storage/{request_id} 1 2 3 4 5 6 { \"storage_key\" : { s t orage_key }, \"data\" : { # da ta here } } Params: storage_key : key associated with the storage destination data : dict of arbitrary data you wish to upload to storage destination.","title":"Testing"},{"location":"guides/storage/#extensibility","text":"Need a different storage destination? Fidesops can be extended to support additional storage destinations by: Add destination-specific enums in src/fidesops/ops/schemas/storage/storage.py Implement an authenticator in src/fidesops/ops/service/storage/storage_authenticator_service.py Implement the uploader in src/fidesops/ops/service/storage/storage_uploader_service.py","title":"Extensibility"},{"location":"postman/using_postman/","text":"Using the fidesops postman collection A minimal Postman collection is included to assist in setting up your fidesops configurations, and in executing example access and erasure privacy requests against mock external databases. Loading the collection Get Postman Postman > File > Import Upload the fidesops collection found in docs/fidesops/docs/postman/Fidesops.postman_collection.json Click on the imported fidesops collection in the left pane and then find Variables to edit fidesops collection variables. Some variables are populated for you, and some will be added in this guide's next steps. Add your oauth_root_client_id and oauth_root_client_secret under CURRENT VALUE . fidesopsadmin and fidesopsadminsecret are default configurations for testing, found in your fidesops.toml . Add the appropriate values for your instance if they differ. Important: Click Save ! Bring up local servers and mock databases Run nox -s dev -- <datastore> in your terminal. This brings up the fidesops server and the list of datastores specified, i.e. nox -s dev -- postgres mongodb . These mock datastores are pre-populated with test data to represent your datastores. The following list of requests is kept in the Minimum API calls to create an Access Privacy Request folder. Some of the returned data will need to be saved as additional variables for use in other steps. Saving Authentication variables Click on the Get Root Client Token request, and click Send to send a POST request to fidesops to create a root token. Copy the access_token returned in the response body, and paste it as the Current Value of root_client_token in fidesops' variables. Important: Click Save ! Similarly, click on Create Client , and click Send to send a POST request to fidesops to create a new client. Copy the client_id and client_secret and paste into Current Value slots in fidesops variables and click \"Save\". Finally, click on the Get Client Token request, and click Send to send another POST request to fidesops. This will create a token for the client made in the previous step. If you click on Body , you can see that the client_id and client_secret have been added as form data for you. Save the returned token under client_token in the fidesops variables. The client_token will be automatically passed into the rest of your requests as the Bearer Token. Building out remaining privacy request configuration Run through the remaining requests in the Minimum API calls to create an Access Privacy Request folder. Because variables are automatically being populated for you, you should be able to click on each request, clicking Send for each one. Inspect the Body of each request to see what is sent to fidesops: Specify where your data is going: SEND Create/Update Storage - Local Storage Config - Sets up a local folder for uploading your privacy request results (local testing only) Configure what data you care about, and what to do with it: SEND Create/Update Policies - Creates a Policy to handle Privacy Requests SEND Create/Update Access Rule - Defines an access Rule on the previous Policy, which specifies results will be uploaded to the configured local storage SEND Create/Update Rule Targets - Specify a RuleTarget that says to will return data that has been marked as having a user data category Create ConnectionConfigs, and add connection secrets for the postgres_example and mongodb_example mock databases: SEND Create/Update Connection Configs: Postgres SEND Create/Update Connection Configs: Mongo SEND Update Connection Secrets: Postgres SEND Update Connection Secrets: Mongo Add annotations of the Postgres and Mongo datastores: SEND Create/Update Postgres Dataset SEND Create/Update Dataset Mongo API calls to additional supported datastores (MsSQL, MySQL) are in separate folders within the collection. Run a privacy request You have now completed the basic configuration required to create an Access Request. SEND Create Access Privacy Requests If \"succeeded\", note the \"id\" that is returned. Succeeded means the privacy request has been created and is pending, not that its execution is complete. Check your local fides_uploads folder, configured earlier, to see access request results. This is run asynchronously, so it may take a few moments to complete. This particular request should have retrieved data from both the postgres_example and mongodb_example databases with the user data_category Next steps Check out other requests in the collection! The Calls to create an Erasure Request folder walks you through configuring a separate erasure policy, and executing an erasure request. Note that these erasure requests will mask data in your connected datastores ( postgres_example and mongo_example here. If you connect your own live databases, data may be deleted. Happy experimenting!","title":"Postman Collection"},{"location":"postman/using_postman/#using-the-fidesops-postman-collection","text":"A minimal Postman collection is included to assist in setting up your fidesops configurations, and in executing example access and erasure privacy requests against mock external databases.","title":"Using the fidesops postman collection"},{"location":"postman/using_postman/#loading-the-collection","text":"Get Postman Postman > File > Import Upload the fidesops collection found in docs/fidesops/docs/postman/Fidesops.postman_collection.json Click on the imported fidesops collection in the left pane and then find Variables to edit fidesops collection variables. Some variables are populated for you, and some will be added in this guide's next steps. Add your oauth_root_client_id and oauth_root_client_secret under CURRENT VALUE . fidesopsadmin and fidesopsadminsecret are default configurations for testing, found in your fidesops.toml . Add the appropriate values for your instance if they differ. Important: Click Save !","title":"Loading the collection"},{"location":"postman/using_postman/#bring-up-local-servers-and-mock-databases","text":"Run nox -s dev -- <datastore> in your terminal. This brings up the fidesops server and the list of datastores specified, i.e. nox -s dev -- postgres mongodb . These mock datastores are pre-populated with test data to represent your datastores. The following list of requests is kept in the Minimum API calls to create an Access Privacy Request folder. Some of the returned data will need to be saved as additional variables for use in other steps.","title":"Bring up local servers and mock databases"},{"location":"postman/using_postman/#saving-authentication-variables","text":"Click on the Get Root Client Token request, and click Send to send a POST request to fidesops to create a root token. Copy the access_token returned in the response body, and paste it as the Current Value of root_client_token in fidesops' variables. Important: Click Save ! Similarly, click on Create Client , and click Send to send a POST request to fidesops to create a new client. Copy the client_id and client_secret and paste into Current Value slots in fidesops variables and click \"Save\". Finally, click on the Get Client Token request, and click Send to send another POST request to fidesops. This will create a token for the client made in the previous step. If you click on Body , you can see that the client_id and client_secret have been added as form data for you. Save the returned token under client_token in the fidesops variables. The client_token will be automatically passed into the rest of your requests as the Bearer Token.","title":"Saving Authentication variables"},{"location":"postman/using_postman/#building-out-remaining-privacy-request-configuration","text":"Run through the remaining requests in the Minimum API calls to create an Access Privacy Request folder. Because variables are automatically being populated for you, you should be able to click on each request, clicking Send for each one. Inspect the Body of each request to see what is sent to fidesops: Specify where your data is going: SEND Create/Update Storage - Local Storage Config - Sets up a local folder for uploading your privacy request results (local testing only) Configure what data you care about, and what to do with it: SEND Create/Update Policies - Creates a Policy to handle Privacy Requests SEND Create/Update Access Rule - Defines an access Rule on the previous Policy, which specifies results will be uploaded to the configured local storage SEND Create/Update Rule Targets - Specify a RuleTarget that says to will return data that has been marked as having a user data category Create ConnectionConfigs, and add connection secrets for the postgres_example and mongodb_example mock databases: SEND Create/Update Connection Configs: Postgres SEND Create/Update Connection Configs: Mongo SEND Update Connection Secrets: Postgres SEND Update Connection Secrets: Mongo Add annotations of the Postgres and Mongo datastores: SEND Create/Update Postgres Dataset SEND Create/Update Dataset Mongo API calls to additional supported datastores (MsSQL, MySQL) are in separate folders within the collection.","title":"Building out remaining privacy request configuration"},{"location":"postman/using_postman/#run-a-privacy-request","text":"You have now completed the basic configuration required to create an Access Request. SEND Create Access Privacy Requests If \"succeeded\", note the \"id\" that is returned. Succeeded means the privacy request has been created and is pending, not that its execution is complete. Check your local fides_uploads folder, configured earlier, to see access request results. This is run asynchronously, so it may take a few moments to complete. This particular request should have retrieved data from both the postgres_example and mongodb_example databases with the user data_category","title":"Run a privacy request"},{"location":"postman/using_postman/#next-steps","text":"Check out other requests in the collection! The Calls to create an Erasure Request folder walks you through configuring a separate erasure policy, and executing an erasure request. Note that these erasure requests will mask data in your connected datastores ( postgres_example and mongo_example here. If you connect your own live databases, data may be deleted. Happy experimenting!","title":"Next steps"},{"location":"saas_connectors/saas_config/","text":"What is a SaaS configuration schema? A SaaS connector is defined in two parts, the Dataset and the SaaS config. The Dataset describes the data that is available from the connector and the SaaS config describes how to connect and retrieve/update the data in the connector. If you contrast this to a database connector , the ways to retrieve/update data conform to a specification (such as SQL) and are consistent. When accessing data from APIs, each application or even different endpoints within the same application can follow different patterns. It was necessary to have a flexible configuration to be able to define the different access/update patterns. Keep in mind that SaaS configs are only applicable to SaaS connectors, not database connectors. In short, you can think of the Dataset as the \"what\" (what data is available from this API) and the SaaS config as the \"how\" (how to access and update the data). An example SaaS config For this guide, we will use the SaaS config to connect to Mailchimp, this config defines: The domain and authentication requirements for an HTTP client to Mailchimp A test request for verifying the connection was set up correctly Endpoints to the following resources within the Mailchimp API: GET and PUT for the members resource GET for the conversations resource GET for the messages resource The following is an example SaaS config for Mailchimp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 saas_config : fides_key : mailchimp_connector_example name : Mailchimp SaaS Config type : mailchimp description : A sample schema representing the Mailchimp connector for fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /3.0/lists endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from data_path : conversation_messages postprocessors : - strategy : filter configuration : field : from_email value : identity : email - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email data_path : conversations pagination : strategy : offset configuration : incremental_param : offset increment_by : 1000 limit : 10000 - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email data_path : exact_matches.members update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from A SaaS config schema contains the following metadata fields: fides_key Used to uniquely identify the connector, this field is used to link a SaaS config to a dataset. name A human-readable name for the connector. type Type of SaaS connector. Choose from hubspot , mailchimp , outreach , segment , sentry , stripe , zendesk or use custom for other types. description Used to add a useful description. version Used to track different versions of the SaaS config. And the following complex fields which we will cover in detail below: connector_params client_config test_request endpoints data_protection_request Connector params The connector_params field is used to describe a list of settings which a user must configure as part of the setup. A default_value can also be used to include values such as a standard base domain for an API or a recommended page size for pagination. Make sure to not include confidential values such as passwords or API keys, these values are added as part of the ConnectionConfig secrets . When configuring a connector's secrets for the first time, the default values will be used if a value is not provided. 1 2 3 4 5 6 7 connector_params : - name : domain default_value : api.stripe.com - name : username - name : password - name : page_size default_value : 100 Client config The client_config describes the necessary information to be able to create a base HTTP client. Notice that the values for host, username, and password are not defined here, only references in the form of a connector_param which fidesops uses to insert the actual value from the stored secrets. 1 2 3 4 5 6 7 8 client_config : protocol : https host : <host> authentication : strategy : basic configuration : username : <username> password : <password> The authentication strategies are swappable. In this example we used the basic authentication strategy which uses a username and password in the configuration. An alternative to this is to use bearer authentication which looks like this: 1 2 3 4 authentication : strategy : bearer configuration : token : <api_key> Fidesops also supports OAuth2 authentication, additional details can be found here . Test request Once the base client is defined we can use a test_request to verify our hostname and credentials. This is in the form of an idempotent request (usually a read). The testing approach is the same for any ConnectionConfig test . 1 2 3 test_request : method : GET path : /3.0/lists Data protection request If your third party integration supports something like a GDPR delete endpoint, that can be configured as a data_protection_request . It has similar attributes to the test request or endpoint requests, but it is generally one endpoint that removes all user PII in one go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 data_protection_request : method : POST path : /v1beta/workspaces/<workspace_name>/regulations param_values : - name : workspace_name connector_param : workspace - name : user_id identity : email body : '{\"regulation_type\": \"Suppress_With_Delete\", \"attributes\": {\"name\": \"userId\", \"values\": [\"<user_id>\",]}}' client_config : protocol : https host : <config_domain> authentication : strategy : bearer configuration : username : <access_token> Endpoints This is where we define how we are going to access and update each collection in the corresponding Dataset. The endpoint section contains the following members: name This name corresponds to a Collection in the corresponding Dataset. after To configure if this endpoint should run after other endpoints or collections. This should be a list of collection addresses, for example: after: [ mailchimp_connector_example.member ] would cause the current endpoint to run after the member endpoint. requests A map of read , update , and delete requests for this collection. Each collection can define a way to read and a way to update the data. Each request is made up of: method The HTTP method used for the endpoint. path A static or dynamic resource path. The dynamic portions of the path are enclosed within angle brackets <dynamic_value> and are replaced with values from param_values . headers and query_params The HTTP headers and query parameters to include in the request. name the value to use for the header or query param name. value can be a static value, one or more of <dynamic_value> , or a mix of static and dynamic values (prefix <value> ) which will be replaced with the value sourced from the param_value with a matching name. body (optional) static or dynamic request body, with dynamic portions enclosed in brackets, just like path . These dynamic values will be replaced with values from param_values . param_values name Used as the key to reference this value from dynamic values in the path, headers, query, or body params. references These are the same as references in the Dataset schema. It is used to define the source of the value for the given param_value. identity Used to access the identity values passed into the privacy request such as email or phone number. connector_param Used to access the user-configured secrets for the connection. ignore_errors A boolean. If true, we will ignore non-200 status codes. data_path : The expression used to access the collection information from the raw JSON response. postprocessors An optional list of response post-processing strategies. We will ignore this for the example scenarios below but an in depth-explanation can be found under SaaS Post-Processors pagination An optional strategy used to get the next set of results from APIs with resources spanning multiple pages. Details can be found under SaaS Pagination . grouped_inputs An optional list of reference fields whose inputs are dependent upon one another. For example, an endpoint may need both an organization_id and a project_id from another endpoint. These aren't independent values, as a project_id belongs to an organization_id . You would specify this as [\"organization_id\", \"project_id\"]. client_config Specify optional embedded Client Configs if an individual request needs a different protocol, host, or authentication strategy from the base Client Config Param values in more detail The param_values list is what provides the values to our various placeholders in the path, headers, query params and body. Values can be identities such as email or phone number, references to fields in other collections, or connector_params which are defined as part of configuring a SaaS connector. Whenever a placeholder is encountered, the placeholder name is looked up in the list of param_values and corresponding value is used instead. Here is an example of placeholders being used in various locations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 messages : requests : read : method : GET path : /<version>/messages headers : - name : Content-Type value : application/json - name : On-Behalf-Of value : <email> - name : Token value : Custom <api_key> query_params : - name : count value : 100 - name : organization : value : <org_id> - name : where : value : properties[\"$email\"]==\"<email>\" param_values : - name : email identity : email - name : api_key connector_param : api_key - name : org_id connector_param : org_id - name : version connector_param : version How are requests generated? The following HTTP request properties are generated for each request based on the endpoint configuration: method path headers query params body Method This is a required field since a read, update, or delete endpoint might use any of the HTTP methods to perform the given action. Path This can be a static value or use placeholders. If the placeholders to build the path are not found at request-time, the request will fail. Headers and query params These can also be static or use placeholders. If a placeholder is missing, the request will continue and omit the given header or query param in the request. If reference values are used for the placeholders, each value will be processed independently unless the grouped_inputs field is set. The following examples use query params but this applies to headers as well. With ungrouped inputs (default) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 read : method : GET path : /v1/disputes query_params : - name : charge value : <charge_id> - name : line_item value : <line_item_id> param_values : - name : charge_id references : - dataset : connector_example field : charge.id direction : from - name : line_item_id references : - dataset : connector_example field : charge.line_item.id direction : from 1 2 3 4 5 6 GET /v1/disputes?charge=1 GET /v1/disputes?charge=2 GET /v1/disputes?charge=3 GET /v1/disputes?line_item=a GET /v1/disputes?line_item=b GET /v1/disputes?line_item=c With grouped inputs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 read : method : GET path : /v1/disputes grouped_inputs : [ charge_id , payment_intent_id ] query_params : - name : charge value : <charge_id> - name : line_item value : <line_item_id> param_values : - name : charge_id references : - dataset : connector_example field : charge.id direction : from - name : line_item_id references : - dataset : connector_example field : charge.line_item.id direction : from 1 2 3 GET /v1/disputes?charge=1&line_item=a GET /v1/disputes?charge=2&line_item=b GET /v1/disputes?charge=3&line_item=c Body The body can be static or use placeholders. If the placeholders to build the body are not found at request-time, the request will fail. Placeholder options for updates The following placeholders can be included in the body of an update: <masked_object_fields> - any masked fields, along with their masked value <all_object_fields> - all object fields, including the masked fields and values Fidesops will automatically fill in the value of these placeholders with the appropriate contents. Example An access request returned the following row: 1 2 3 4 5 { \"id\" : 123 , \"name\" : \"Bobby Hill\" , \"address\" : \"Arlen TX\" } With the name field masked, the value of each placeholder would be: Placeholder Value <masked_object_fields> \"name\":\"MASKED\" <all_object_fields> \"id\":123,\"name\":\"MASKED\",\"address\":\"Arlen TX\" all_object_fields should be used if non-masked fields are required as part of the update payload. Read-Only fields A field can be flagged as read-only in the dataset to exclude it from the value of <all_object_fields> (for example, if including the id would cause an error). 1 2 3 4 - name : id data_categories : [ system.operations ] fidesops_meta : read_only : True This would result in the following change, with id removed from the result: Placeholder Value <all_object_fields> \"name\":\"MASKED\",\"address\":\"Arlen TX\" Example scenarios Dynamic path with dataset references 1 2 3 4 5 6 7 8 9 10 11 12 endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from In this example, we define /3.0/conversations/<conversation_id>/messages as the resource path for messages and define the path param of conversation_id as coming from the id field of the conversations collection. A separate GET HTTP request will be issued for each conversations.id value. 1 2 3 4 # For three conversations with IDs of 1,2,3 GET /3.0/conversations/1/messages GET /3.0/conversations/2/messages GET /3.0/conversations/2/messages Identity as a query param 1 2 3 4 5 6 7 8 9 10 11 12 endpoints : - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email In this example, the placeholder in the query query param would be replaced with the value of the param_value with a name of email , which is the email identity. The result would look like this: 1 GET /3.0/search-members?query=name@email.com Data update with a dynamic path 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 endpoints : - name : member requests : update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from This example uses two dynamic path variables, one from member.id and one from member.list_id . Since both of these are references to the member collection, we must first issue a data retrieval (which will happen automatically if the read request is defined). If a call to GET /3.0/search-members returned the following member object: 1 2 3 4 5 6 7 8 { \"list_id\" : \"123\" , \"id\" : \"456\" , \"merge_fields\" : { \"FNAME\" : \"First\" , \"LNAME\" : \"Last\" } } Then the update request would be: 1 2 3 4 5 6 7 8 9 10 PUT /3.0/lists/123/members/456 { \"list_id\" : \"123\" , \"id\" : \"456\" , \"merge_fields\" : { \"FNAME\" : \"MASKED\" , \"LNAME\" : \"MASKED\" } } and the contents of the body would be masked according to the configured policy . Data update with a dynamic HTTP body Sometimes, the update request needs a different body structure than what we obtain from the read request. In this example, we use a custom HTTP body that contains our masked object fields. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 update : method : PUT path : /crm/v3/objects/contacts body : '{ \"properties\": { <masked_object_fields>, \"user_ref_id\": <user_ref_id> } }' param_values : - name : user_ref_id references : - dataset : dataset_test field : contacts.user_ref_id direction : from Fidesops will replace the <masked_object_fields> placeholder with the result of the policy-driven masking service, for example 'company': None, 'email': None . Note that neither enclosing curly brackets ( { } ) nor a trailing comma ( , ) are included as part of the replacement string generated by fidesops. This results in the following update request: 1 2 3 4 5 6 7 8 9 PUT /crm/v3/objects/contacts { \"properties\" : { \"company\" : \"None\" , \"email\" : \"None\" \"user_ref_id\" : \"p983u4ncp3q8u4r\" } } How does this relate to graph traversal? Fidesops uses the available Datasets to generate a graph of all reachable data and the dependencies between Datasets. For SaaS connectors, all the references and identities are stored in the param_values , therefore we must merge both the SaaS config and Dataset to provide a complete picture for the graph traversal. Using Mailchimp as an example the Dataset collection and SaaS config endpoints for messages looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 collections : - name : messages fields : - name : id data_categories : [ system.operations ] - name : conversation_id data_categories : [ system.operations ] - name : from_label data_categories : [ system.operations ] - name : from_email data_categories : [ user.contact.email ] - name : subject data_categories : [ system.operations ] - name : message data_categories : [ system.operations ] - name : read data_categories : [ system.operations ] - name : timestamp data_categories : [ system.operations ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from postprocessors : - strategy : unwrap configuration : data_path : conversation_messages - strategy : filter configuration : field : from_email value : identity : email An example of the augmented Dataset with the SaaS Config references would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 collections : - name : messages fields : - name : id data_categories : [ system.operations ] - name : conversation_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mailchimp_connector_example field : conversations.id direction : from - name : from_label data_categories : [ system.operations ] - name : from_email data_categories : [ user.contact.email ] - name : subject data_categories : [ system.operations ] - name : message data_categories : [ system.operations ] - name : read data_categories : [ system.operations ] - name : timestamp data_categories : [ system.operations ] Notice how the conversation_id field is updated with a reference from mailchimp_connector_example.conversations.id . This means that the conversations collection must be retrieved first to forward the conversation IDs to the messages collection for further processing. What if a collection has no dependencies? In the Mailchimp example, you might have noticed the placeholder request param. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 endpoints : - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email Some endpoints might not have any external dependencies on identity or Dataset reference values. The way the fidesops graph traversal interprets this is as an unreachable collection. At this time, the way to mark this as reachable is to include a param_value with an identity or a reference. In the future we plan on having collections like these still be considered reachable even without this placeholder (the param_value name is not relevant, we just chose placeholder for this example).","title":"SaaS Configuration"},{"location":"saas_connectors/saas_config/#what-is-a-saas-configuration-schema","text":"A SaaS connector is defined in two parts, the Dataset and the SaaS config. The Dataset describes the data that is available from the connector and the SaaS config describes how to connect and retrieve/update the data in the connector. If you contrast this to a database connector , the ways to retrieve/update data conform to a specification (such as SQL) and are consistent. When accessing data from APIs, each application or even different endpoints within the same application can follow different patterns. It was necessary to have a flexible configuration to be able to define the different access/update patterns. Keep in mind that SaaS configs are only applicable to SaaS connectors, not database connectors. In short, you can think of the Dataset as the \"what\" (what data is available from this API) and the SaaS config as the \"how\" (how to access and update the data).","title":"What is a SaaS configuration schema?"},{"location":"saas_connectors/saas_config/#an-example-saas-config","text":"For this guide, we will use the SaaS config to connect to Mailchimp, this config defines: The domain and authentication requirements for an HTTP client to Mailchimp A test request for verifying the connection was set up correctly Endpoints to the following resources within the Mailchimp API: GET and PUT for the members resource GET for the conversations resource GET for the messages resource The following is an example SaaS config for Mailchimp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 saas_config : fides_key : mailchimp_connector_example name : Mailchimp SaaS Config type : mailchimp description : A sample schema representing the Mailchimp connector for fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /3.0/lists endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from data_path : conversation_messages postprocessors : - strategy : filter configuration : field : from_email value : identity : email - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email data_path : conversations pagination : strategy : offset configuration : incremental_param : offset increment_by : 1000 limit : 10000 - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email data_path : exact_matches.members update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from A SaaS config schema contains the following metadata fields: fides_key Used to uniquely identify the connector, this field is used to link a SaaS config to a dataset. name A human-readable name for the connector. type Type of SaaS connector. Choose from hubspot , mailchimp , outreach , segment , sentry , stripe , zendesk or use custom for other types. description Used to add a useful description. version Used to track different versions of the SaaS config. And the following complex fields which we will cover in detail below: connector_params client_config test_request endpoints data_protection_request","title":"An example SaaS config"},{"location":"saas_connectors/saas_config/#connector-params","text":"The connector_params field is used to describe a list of settings which a user must configure as part of the setup. A default_value can also be used to include values such as a standard base domain for an API or a recommended page size for pagination. Make sure to not include confidential values such as passwords or API keys, these values are added as part of the ConnectionConfig secrets . When configuring a connector's secrets for the first time, the default values will be used if a value is not provided. 1 2 3 4 5 6 7 connector_params : - name : domain default_value : api.stripe.com - name : username - name : password - name : page_size default_value : 100","title":"Connector params"},{"location":"saas_connectors/saas_config/#client-config","text":"The client_config describes the necessary information to be able to create a base HTTP client. Notice that the values for host, username, and password are not defined here, only references in the form of a connector_param which fidesops uses to insert the actual value from the stored secrets. 1 2 3 4 5 6 7 8 client_config : protocol : https host : <host> authentication : strategy : basic configuration : username : <username> password : <password> The authentication strategies are swappable. In this example we used the basic authentication strategy which uses a username and password in the configuration. An alternative to this is to use bearer authentication which looks like this: 1 2 3 4 authentication : strategy : bearer configuration : token : <api_key> Fidesops also supports OAuth2 authentication, additional details can be found here .","title":"Client config"},{"location":"saas_connectors/saas_config/#test-request","text":"Once the base client is defined we can use a test_request to verify our hostname and credentials. This is in the form of an idempotent request (usually a read). The testing approach is the same for any ConnectionConfig test . 1 2 3 test_request : method : GET path : /3.0/lists","title":"Test request"},{"location":"saas_connectors/saas_config/#data-protection-request","text":"If your third party integration supports something like a GDPR delete endpoint, that can be configured as a data_protection_request . It has similar attributes to the test request or endpoint requests, but it is generally one endpoint that removes all user PII in one go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 data_protection_request : method : POST path : /v1beta/workspaces/<workspace_name>/regulations param_values : - name : workspace_name connector_param : workspace - name : user_id identity : email body : '{\"regulation_type\": \"Suppress_With_Delete\", \"attributes\": {\"name\": \"userId\", \"values\": [\"<user_id>\",]}}' client_config : protocol : https host : <config_domain> authentication : strategy : bearer configuration : username : <access_token>","title":"Data protection request"},{"location":"saas_connectors/saas_config/#endpoints","text":"This is where we define how we are going to access and update each collection in the corresponding Dataset. The endpoint section contains the following members: name This name corresponds to a Collection in the corresponding Dataset. after To configure if this endpoint should run after other endpoints or collections. This should be a list of collection addresses, for example: after: [ mailchimp_connector_example.member ] would cause the current endpoint to run after the member endpoint. requests A map of read , update , and delete requests for this collection. Each collection can define a way to read and a way to update the data. Each request is made up of: method The HTTP method used for the endpoint. path A static or dynamic resource path. The dynamic portions of the path are enclosed within angle brackets <dynamic_value> and are replaced with values from param_values . headers and query_params The HTTP headers and query parameters to include in the request. name the value to use for the header or query param name. value can be a static value, one or more of <dynamic_value> , or a mix of static and dynamic values (prefix <value> ) which will be replaced with the value sourced from the param_value with a matching name. body (optional) static or dynamic request body, with dynamic portions enclosed in brackets, just like path . These dynamic values will be replaced with values from param_values . param_values name Used as the key to reference this value from dynamic values in the path, headers, query, or body params. references These are the same as references in the Dataset schema. It is used to define the source of the value for the given param_value. identity Used to access the identity values passed into the privacy request such as email or phone number. connector_param Used to access the user-configured secrets for the connection. ignore_errors A boolean. If true, we will ignore non-200 status codes. data_path : The expression used to access the collection information from the raw JSON response. postprocessors An optional list of response post-processing strategies. We will ignore this for the example scenarios below but an in depth-explanation can be found under SaaS Post-Processors pagination An optional strategy used to get the next set of results from APIs with resources spanning multiple pages. Details can be found under SaaS Pagination . grouped_inputs An optional list of reference fields whose inputs are dependent upon one another. For example, an endpoint may need both an organization_id and a project_id from another endpoint. These aren't independent values, as a project_id belongs to an organization_id . You would specify this as [\"organization_id\", \"project_id\"]. client_config Specify optional embedded Client Configs if an individual request needs a different protocol, host, or authentication strategy from the base Client Config","title":"Endpoints"},{"location":"saas_connectors/saas_config/#param-values-in-more-detail","text":"The param_values list is what provides the values to our various placeholders in the path, headers, query params and body. Values can be identities such as email or phone number, references to fields in other collections, or connector_params which are defined as part of configuring a SaaS connector. Whenever a placeholder is encountered, the placeholder name is looked up in the list of param_values and corresponding value is used instead. Here is an example of placeholders being used in various locations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 messages : requests : read : method : GET path : /<version>/messages headers : - name : Content-Type value : application/json - name : On-Behalf-Of value : <email> - name : Token value : Custom <api_key> query_params : - name : count value : 100 - name : organization : value : <org_id> - name : where : value : properties[\"$email\"]==\"<email>\" param_values : - name : email identity : email - name : api_key connector_param : api_key - name : org_id connector_param : org_id - name : version connector_param : version","title":"Param values in more detail"},{"location":"saas_connectors/saas_config/#how-are-requests-generated","text":"The following HTTP request properties are generated for each request based on the endpoint configuration: method path headers query params body","title":"How are requests generated?"},{"location":"saas_connectors/saas_config/#method","text":"This is a required field since a read, update, or delete endpoint might use any of the HTTP methods to perform the given action.","title":"Method"},{"location":"saas_connectors/saas_config/#path","text":"This can be a static value or use placeholders. If the placeholders to build the path are not found at request-time, the request will fail.","title":"Path"},{"location":"saas_connectors/saas_config/#headers-and-query-params","text":"These can also be static or use placeholders. If a placeholder is missing, the request will continue and omit the given header or query param in the request. If reference values are used for the placeholders, each value will be processed independently unless the grouped_inputs field is set. The following examples use query params but this applies to headers as well. With ungrouped inputs (default) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 read : method : GET path : /v1/disputes query_params : - name : charge value : <charge_id> - name : line_item value : <line_item_id> param_values : - name : charge_id references : - dataset : connector_example field : charge.id direction : from - name : line_item_id references : - dataset : connector_example field : charge.line_item.id direction : from 1 2 3 4 5 6 GET /v1/disputes?charge=1 GET /v1/disputes?charge=2 GET /v1/disputes?charge=3 GET /v1/disputes?line_item=a GET /v1/disputes?line_item=b GET /v1/disputes?line_item=c With grouped inputs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 read : method : GET path : /v1/disputes grouped_inputs : [ charge_id , payment_intent_id ] query_params : - name : charge value : <charge_id> - name : line_item value : <line_item_id> param_values : - name : charge_id references : - dataset : connector_example field : charge.id direction : from - name : line_item_id references : - dataset : connector_example field : charge.line_item.id direction : from 1 2 3 GET /v1/disputes?charge=1&line_item=a GET /v1/disputes?charge=2&line_item=b GET /v1/disputes?charge=3&line_item=c","title":"Headers and query params"},{"location":"saas_connectors/saas_config/#body","text":"The body can be static or use placeholders. If the placeholders to build the body are not found at request-time, the request will fail. Placeholder options for updates The following placeholders can be included in the body of an update: <masked_object_fields> - any masked fields, along with their masked value <all_object_fields> - all object fields, including the masked fields and values Fidesops will automatically fill in the value of these placeholders with the appropriate contents. Example An access request returned the following row: 1 2 3 4 5 { \"id\" : 123 , \"name\" : \"Bobby Hill\" , \"address\" : \"Arlen TX\" } With the name field masked, the value of each placeholder would be: Placeholder Value <masked_object_fields> \"name\":\"MASKED\" <all_object_fields> \"id\":123,\"name\":\"MASKED\",\"address\":\"Arlen TX\" all_object_fields should be used if non-masked fields are required as part of the update payload. Read-Only fields A field can be flagged as read-only in the dataset to exclude it from the value of <all_object_fields> (for example, if including the id would cause an error). 1 2 3 4 - name : id data_categories : [ system.operations ] fidesops_meta : read_only : True This would result in the following change, with id removed from the result: Placeholder Value <all_object_fields> \"name\":\"MASKED\",\"address\":\"Arlen TX\"","title":"Body"},{"location":"saas_connectors/saas_config/#example-scenarios","text":"","title":"Example scenarios"},{"location":"saas_connectors/saas_config/#dynamic-path-with-dataset-references","text":"1 2 3 4 5 6 7 8 9 10 11 12 endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from In this example, we define /3.0/conversations/<conversation_id>/messages as the resource path for messages and define the path param of conversation_id as coming from the id field of the conversations collection. A separate GET HTTP request will be issued for each conversations.id value. 1 2 3 4 # For three conversations with IDs of 1,2,3 GET /3.0/conversations/1/messages GET /3.0/conversations/2/messages GET /3.0/conversations/2/messages","title":"Dynamic path with dataset references"},{"location":"saas_connectors/saas_config/#identity-as-a-query-param","text":"1 2 3 4 5 6 7 8 9 10 11 12 endpoints : - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email In this example, the placeholder in the query query param would be replaced with the value of the param_value with a name of email , which is the email identity. The result would look like this: 1 GET /3.0/search-members?query=name@email.com","title":"Identity as a query param"},{"location":"saas_connectors/saas_config/#data-update-with-a-dynamic-path","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 endpoints : - name : member requests : update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from This example uses two dynamic path variables, one from member.id and one from member.list_id . Since both of these are references to the member collection, we must first issue a data retrieval (which will happen automatically if the read request is defined). If a call to GET /3.0/search-members returned the following member object: 1 2 3 4 5 6 7 8 { \"list_id\" : \"123\" , \"id\" : \"456\" , \"merge_fields\" : { \"FNAME\" : \"First\" , \"LNAME\" : \"Last\" } } Then the update request would be: 1 2 3 4 5 6 7 8 9 10 PUT /3.0/lists/123/members/456 { \"list_id\" : \"123\" , \"id\" : \"456\" , \"merge_fields\" : { \"FNAME\" : \"MASKED\" , \"LNAME\" : \"MASKED\" } } and the contents of the body would be masked according to the configured policy .","title":"Data update with a dynamic path"},{"location":"saas_connectors/saas_config/#data-update-with-a-dynamic-http-body","text":"Sometimes, the update request needs a different body structure than what we obtain from the read request. In this example, we use a custom HTTP body that contains our masked object fields. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 update : method : PUT path : /crm/v3/objects/contacts body : '{ \"properties\": { <masked_object_fields>, \"user_ref_id\": <user_ref_id> } }' param_values : - name : user_ref_id references : - dataset : dataset_test field : contacts.user_ref_id direction : from Fidesops will replace the <masked_object_fields> placeholder with the result of the policy-driven masking service, for example 'company': None, 'email': None . Note that neither enclosing curly brackets ( { } ) nor a trailing comma ( , ) are included as part of the replacement string generated by fidesops. This results in the following update request: 1 2 3 4 5 6 7 8 9 PUT /crm/v3/objects/contacts { \"properties\" : { \"company\" : \"None\" , \"email\" : \"None\" \"user_ref_id\" : \"p983u4ncp3q8u4r\" } }","title":"Data update with a dynamic HTTP body"},{"location":"saas_connectors/saas_config/#how-does-this-relate-to-graph-traversal","text":"Fidesops uses the available Datasets to generate a graph of all reachable data and the dependencies between Datasets. For SaaS connectors, all the references and identities are stored in the param_values , therefore we must merge both the SaaS config and Dataset to provide a complete picture for the graph traversal. Using Mailchimp as an example the Dataset collection and SaaS config endpoints for messages looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 collections : - name : messages fields : - name : id data_categories : [ system.operations ] - name : conversation_id data_categories : [ system.operations ] - name : from_label data_categories : [ system.operations ] - name : from_email data_categories : [ user.contact.email ] - name : subject data_categories : [ system.operations ] - name : message data_categories : [ system.operations ] - name : read data_categories : [ system.operations ] - name : timestamp data_categories : [ system.operations ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from postprocessors : - strategy : unwrap configuration : data_path : conversation_messages - strategy : filter configuration : field : from_email value : identity : email An example of the augmented Dataset with the SaaS Config references would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 collections : - name : messages fields : - name : id data_categories : [ system.operations ] - name : conversation_id data_categories : [ system.operations ] fidesops_meta : references : - dataset : mailchimp_connector_example field : conversations.id direction : from - name : from_label data_categories : [ system.operations ] - name : from_email data_categories : [ user.contact.email ] - name : subject data_categories : [ system.operations ] - name : message data_categories : [ system.operations ] - name : read data_categories : [ system.operations ] - name : timestamp data_categories : [ system.operations ] Notice how the conversation_id field is updated with a reference from mailchimp_connector_example.conversations.id . This means that the conversations collection must be retrieved first to forward the conversation IDs to the messages collection for further processing.","title":"How does this relate to graph traversal?"},{"location":"saas_connectors/saas_config/#what-if-a-collection-has-no-dependencies","text":"In the Mailchimp example, you might have noticed the placeholder request param. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 endpoints : - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email Some endpoints might not have any external dependencies on identity or Dataset reference values. The way the fidesops graph traversal interprets this is as an unreachable collection. At this time, the way to mark this as reachable is to include a param_value with an identity or a reference. In the future we plan on having collections like these still be considered reachable even without this placeholder (the param_value name is not relevant, we just chose placeholder for this example).","title":"What if a collection has no dependencies?"},{"location":"saas_connectors/saas_connectors/","text":"Connect to SaaS Applications What is a SaaS connection? A SaaS (Software as a Service) connection is a connection type within fidesops that allows a user to connect to a SaaS application (e.g., Mailchimp, Stripe, Slack, etc.) and execute data access and erasure requests against that application. These connections use functionality introduced in earlier sections ( ConnectionConfigs and Datasets ) but also use a new SaaS configuration specification to define how to connect to specific SaaS applications. Supported SaaS applications The current implementation of the SaaS framework can support any SaaS application that uses these features: Basic auth, bearer auth, OAuth2 (Authorization Code Flow) Data access via HTTP requests Erasure via HTTP requests Pagination based on headers and response contents The following features are planned for future releases and will allow for the configuration of broader types of connections: Custom Python functions for access and erasure requests Retry logic based on status codes and response contents Full examples of a valid SaaS config and Dataset are currently available for Mailchimp. How to configure a SaaS connector For convenience we've included a SaaS Connector Postman collection to execute the necessary steps to configure a SaaS connector. Create a ConnectionConfig of type saas 1 2 3 4 5 6 7 8 9 10 PATCH api/v1/connection [ { \"name\": \"SaaS Application\", \"key\": {saas_key}, \"connection_type\": \"saas\", \"access\": \"read\" } ] Add a SaaS Config (in JSON format) 1 2 3 4 5 6 7 8 PATCH api/v1/connection/{saas_key}/saas_config { \"fides_key\": \"mailchimp_connector_example\", \"name\": \"Mailchimp SaaS Config\", \"type\": \"mailchimp\", \"description\": \"A sample schema representing the Mailchimp connector for fidesops\" ... Configure the secrets. The SaaS config must already defined to provide validation for the secrets. 1 2 3 4 5 6 7 PUT api/v1/connection/{saas_key}/secret { \"domain\": \"{mailchimp_domain}\", \"username\": \"{mailchimp_username}\", \"api_key\": \"{mailchimp_api_key}\" } Add a Dataset (in JSON format) 1 2 3 4 5 6 7 8 9 10 PUT api/v1/connection/{saas_key}/dataset [ { \"fides_key\":\"mailchimp_connector_example\", \"name\":\"Mailchimp Dataset\", \"description\":\"A sample dataset representing the Mailchimp connector for fidesops\", \"collections\":[ { \"name\":\"messages\" ... Additional considerations These are constraints enforced by the API validation but it is important to keep these in mind. A SaaS connector dataset cannot have any identities or references in the fidesops_meta . These relationships must be defined in the SaaS config. SaaS config references can only have a direction of from . The fides_key between the SaaS config and the Dataset must match. This is how we associate the two pieces together.","title":"Connect to SaaS Applications"},{"location":"saas_connectors/saas_connectors/#connect-to-saas-applications","text":"","title":"Connect to SaaS Applications"},{"location":"saas_connectors/saas_connectors/#what-is-a-saas-connection","text":"A SaaS (Software as a Service) connection is a connection type within fidesops that allows a user to connect to a SaaS application (e.g., Mailchimp, Stripe, Slack, etc.) and execute data access and erasure requests against that application. These connections use functionality introduced in earlier sections ( ConnectionConfigs and Datasets ) but also use a new SaaS configuration specification to define how to connect to specific SaaS applications.","title":"What is a SaaS connection?"},{"location":"saas_connectors/saas_connectors/#supported-saas-applications","text":"The current implementation of the SaaS framework can support any SaaS application that uses these features: Basic auth, bearer auth, OAuth2 (Authorization Code Flow) Data access via HTTP requests Erasure via HTTP requests Pagination based on headers and response contents The following features are planned for future releases and will allow for the configuration of broader types of connections: Custom Python functions for access and erasure requests Retry logic based on status codes and response contents Full examples of a valid SaaS config and Dataset are currently available for Mailchimp.","title":"Supported SaaS applications"},{"location":"saas_connectors/saas_connectors/#how-to-configure-a-saas-connector","text":"For convenience we've included a SaaS Connector Postman collection to execute the necessary steps to configure a SaaS connector. Create a ConnectionConfig of type saas 1 2 3 4 5 6 7 8 9 10 PATCH api/v1/connection [ { \"name\": \"SaaS Application\", \"key\": {saas_key}, \"connection_type\": \"saas\", \"access\": \"read\" } ] Add a SaaS Config (in JSON format) 1 2 3 4 5 6 7 8 PATCH api/v1/connection/{saas_key}/saas_config { \"fides_key\": \"mailchimp_connector_example\", \"name\": \"Mailchimp SaaS Config\", \"type\": \"mailchimp\", \"description\": \"A sample schema representing the Mailchimp connector for fidesops\" ... Configure the secrets. The SaaS config must already defined to provide validation for the secrets. 1 2 3 4 5 6 7 PUT api/v1/connection/{saas_key}/secret { \"domain\": \"{mailchimp_domain}\", \"username\": \"{mailchimp_username}\", \"api_key\": \"{mailchimp_api_key}\" } Add a Dataset (in JSON format) 1 2 3 4 5 6 7 8 9 10 PUT api/v1/connection/{saas_key}/dataset [ { \"fides_key\":\"mailchimp_connector_example\", \"name\":\"Mailchimp Dataset\", \"description\":\"A sample dataset representing the Mailchimp connector for fidesops\", \"collections\":[ { \"name\":\"messages\" ...","title":"How to configure a SaaS connector"},{"location":"saas_connectors/saas_connectors/#additional-considerations","text":"These are constraints enforced by the API validation but it is important to keep these in mind. A SaaS connector dataset cannot have any identities or references in the fidesops_meta . These relationships must be defined in the SaaS config. SaaS config references can only have a direction of from . The fides_key between the SaaS config and the Dataset must match. This is how we associate the two pieces together.","title":"Additional considerations"},{"location":"saas_connectors/saas_oauth2/","text":"SaaS connectors support two OAuth2 flows: Authorization Code : oauth2_authorization_code Client Credentials : oauth2_client_credentials This Authentication Code flow has the following configuration values: authorization_request : The request to build the URL that is presented to the user to authenticate this connection. token_request : The request made to retrieve the access token after the authorization code is returned via the /oauth/callback endpoint. refresh_request ( optional ): The request to refresh an access token. expires_in ( optional ): The lifetime of an access token (in seconds). This is used if the OAuth2 workflow in use does not provide expiration information ( RFC 6749 Section 5.1 ). The Client Credential flow has all these values except for authorization_request since it is not required for this flow. Sample Configuration Each OAuth2 request is fully configurable to account for the different ways the parameters can be mapped to a request. The following examples demonstrate the requests generated from sample configuration files. OAuth2 Authorization Code example 1 2 3 4 5 6 7 8 9 authentication : strategy : oauth2_authorization_code configuration : authorization_request : ... token_request : ... refresh_request : ... Authorization Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 authorization_request : method : GET path : /auth/authorize query_params : - name : client_id value : <client_id> - name : redirect_uri value : <redirect_uri> - name : response_type value : code - name : scope value : <scope> - name : state value : <state> The above authentication_request will generate the following: GET request 1 https://<domain>/auth/authorize?client_id=<client_id>&redirect_uri=<redirect_uri>&response_type=code&scope=<scope>&state=<state> The placeholders are sourced from the values defined in the connector_params of your SaaS config. The <state> placeholder is generated automatically with each authorization request. This authorization URL can be retrieved by calling: GET request 1 https://{{domain}}/api/v1/connection/{{connection_key}}/authorize Token Request 1 2 3 4 5 6 7 8 9 10 11 12 token_request : method : POST path : /oauth/token query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : authorization_code - name : code value : <code> The <code> placeholder is defined automatically by Fidesops. The above token_request configuration generates the following: GET Request 1 https://<domain>/oauth_token?client_id=<client_id>&client_secret=<client_secret>&grant_type=authorization_code&code=<code> This request is called automatically after Fidesops receives a callback response to the https://{{domain}}/api/v1/oauth/callback endpoint. Refresh Request 1 2 3 4 5 6 7 8 9 10 11 12 refresh_request : method : POST path : /oauth/token query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : refresh_token - name : refresh_token value : <refresh_token> The <refresh_token> placeholder is defined automatically by Fidesops. The above refresh_request configuration generates the following: 1 GET https://<domain>/oauth_token?client_id=<client_id>&client_secret=<client_secret>&grant_type=refresh_token&refresh_token=<refresh_token> This is called automatically when the access_token is about to expire. The expiration is usually defined in the response to the token request. If the expiration is not returned by the API, it can be specified manually by setting the expires_in field (which is defined in seconds): 1 2 3 4 5 6 7 8 9 10 authentication : strategy : oauth2_authorization_code configuration : expires_in : 3600 authorization_request : ... token_request : ... refresh_request : ... Usage Checklist To use OAuth2 as a connection strategy, the following must be configured first: For All OAuth2 Flows Per-connector Configuration Fidesops must be able to connect to the SaaS provider (Outreach, Salesforce, etc.). A Client ID and Client Secret must be generated within the SaaS provider\u2019s admin console. This is dependent on the individual SaaS provider. Refer to the provider's documentation. The connector using OAuth2 is configured using the steps for how to configure a SaaS connector . Additional Steps for Authentication Code Flow One-time Configuration A callback server or network rules are required to forward the callback response from the SaaS providers to an instance of Fidesops. This is dependent on the user environment where Fidesops is deployed, and is out of scope for this documentation. These incoming requests must be routed to https://{{host}}/api/v1/oauth/callback . Per-connector Configuration The Redirect URI must be registered within the SaaS provider's admin console. The OAuth2 workflow is initialized by following the URL returned from https://{{domain}}/api/v1/connection/{{connection_key}}/authorize . OAuth2 Authentication Code Flow Diagram","title":"SaaS OAuth2 Configuration"},{"location":"saas_connectors/saas_oauth2/#sample-configuration","text":"Each OAuth2 request is fully configurable to account for the different ways the parameters can be mapped to a request. The following examples demonstrate the requests generated from sample configuration files. OAuth2 Authorization Code example 1 2 3 4 5 6 7 8 9 authentication : strategy : oauth2_authorization_code configuration : authorization_request : ... token_request : ... refresh_request : ...","title":"Sample Configuration"},{"location":"saas_connectors/saas_oauth2/#authorization-request","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 authorization_request : method : GET path : /auth/authorize query_params : - name : client_id value : <client_id> - name : redirect_uri value : <redirect_uri> - name : response_type value : code - name : scope value : <scope> - name : state value : <state> The above authentication_request will generate the following: GET request 1 https://<domain>/auth/authorize?client_id=<client_id>&redirect_uri=<redirect_uri>&response_type=code&scope=<scope>&state=<state> The placeholders are sourced from the values defined in the connector_params of your SaaS config. The <state> placeholder is generated automatically with each authorization request. This authorization URL can be retrieved by calling: GET request 1 https://{{domain}}/api/v1/connection/{{connection_key}}/authorize","title":"Authorization Request"},{"location":"saas_connectors/saas_oauth2/#token-request","text":"1 2 3 4 5 6 7 8 9 10 11 12 token_request : method : POST path : /oauth/token query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : authorization_code - name : code value : <code> The <code> placeholder is defined automatically by Fidesops. The above token_request configuration generates the following: GET Request 1 https://<domain>/oauth_token?client_id=<client_id>&client_secret=<client_secret>&grant_type=authorization_code&code=<code> This request is called automatically after Fidesops receives a callback response to the https://{{domain}}/api/v1/oauth/callback endpoint.","title":"Token Request"},{"location":"saas_connectors/saas_oauth2/#refresh-request","text":"1 2 3 4 5 6 7 8 9 10 11 12 refresh_request : method : POST path : /oauth/token query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : refresh_token - name : refresh_token value : <refresh_token> The <refresh_token> placeholder is defined automatically by Fidesops. The above refresh_request configuration generates the following: 1 GET https://<domain>/oauth_token?client_id=<client_id>&client_secret=<client_secret>&grant_type=refresh_token&refresh_token=<refresh_token> This is called automatically when the access_token is about to expire. The expiration is usually defined in the response to the token request. If the expiration is not returned by the API, it can be specified manually by setting the expires_in field (which is defined in seconds): 1 2 3 4 5 6 7 8 9 10 authentication : strategy : oauth2_authorization_code configuration : expires_in : 3600 authorization_request : ... token_request : ... refresh_request : ...","title":"Refresh Request"},{"location":"saas_connectors/saas_oauth2/#usage-checklist","text":"To use OAuth2 as a connection strategy, the following must be configured first:","title":"Usage Checklist"},{"location":"saas_connectors/saas_oauth2/#for-all-oauth2-flows","text":"","title":"For All OAuth2 Flows"},{"location":"saas_connectors/saas_oauth2/#per-connector-configuration","text":"Fidesops must be able to connect to the SaaS provider (Outreach, Salesforce, etc.). A Client ID and Client Secret must be generated within the SaaS provider\u2019s admin console. This is dependent on the individual SaaS provider. Refer to the provider's documentation. The connector using OAuth2 is configured using the steps for how to configure a SaaS connector .","title":"Per-connector Configuration"},{"location":"saas_connectors/saas_oauth2/#additional-steps-for-authentication-code-flow","text":"","title":"Additional Steps for Authentication Code Flow"},{"location":"saas_connectors/saas_oauth2/#one-time-configuration","text":"A callback server or network rules are required to forward the callback response from the SaaS providers to an instance of Fidesops. This is dependent on the user environment where Fidesops is deployed, and is out of scope for this documentation. These incoming requests must be routed to https://{{host}}/api/v1/oauth/callback .","title":"One-time Configuration"},{"location":"saas_connectors/saas_oauth2/#per-connector-configuration_1","text":"The Redirect URI must be registered within the SaaS provider's admin console. The OAuth2 workflow is initialized by following the URL returned from https://{{domain}}/api/v1/connection/{{connection_key}}/authorize .","title":"Per-connector Configuration"},{"location":"saas_connectors/saas_oauth2/#oauth2-authentication-code-flow-diagram","text":"","title":"OAuth2 Authentication Code Flow Diagram"},{"location":"saas_connectors/saas_pagination/","text":"SaaS Pagination These pagination strategies allow fidesops to incrementally retrieve content from SaaS APIs. APIs can vary in the way subsequent pages are accessed so these configurable options aim to cover a majority of common use cases. Supported strategies offset : Iterates through the available pages by incrementing the value of a query param. link : Uses links returned in the headers or the body to get to the next page. cursor : Uses a value from the last-retrieved object to use as a query param pointing to the next set of results. Offset This strategy can be used to iterate through pages, or to define the offset for a batch of results. In either case, this strategy increments the specified query param by the increment_by value until no more results are returned or the limit is reached. Configuration details incremental_param ( str ): The query param to increment the value for. increment_by ( int ): The value to increment the incremental_param after each set of results. limit ( str ): The max value the incremental_param can reach. Example This example would take the page query param and increment it by 1 until the limit of 10 is reached or no more results are returned (whichever comes first). 1 2 3 4 5 6 pagination : strategy : offset configuration : incremental_param : page increment_by : 1 limit : 10 Link This strategy is used when the link to the next page is provided as part of the API response. The link is read from the headers or the body and used to get the next page of results. Configuration details source ( str ): The location to get the link from, can be either headers or body . path ( str ): The expression used to refer to the location of the link within the headers or the body. Examples The source value of headers is meant to be used with responses following RFC 5988 . 1 2 Link: <https://api.host.com/conversations?page_ref=ad6f38r3>; rel=\"next\", <https://api.host.com/conversations?page_ref=gss8ap4g>; rel=\"prev\" Given this Link header, we can specify a rel of next (case-insensitive). This indicates that we are looking in the Link header with a rel of next. 1 2 3 4 5 pagination : strategy : link configuration : source : headers rel : next We can also access links returned in the body. If we receive this value in the body: 1 2 3 4 5 6 7 { ... \"next_page\" : { \"url\" : \"https://api.host.com/conversations?page_ref=ad6f38r3\" } ... } We can use the path value of next_page.url as the expression to access the url. 1 2 3 4 5 pagination : strategy : link configuration : source : body path : next_page.url Cursor This strategy is used when a specific value from a response object is used as a cursor to determine the starting point for the next set of results. Configuration Details cursor_param ( str ): The name of the query param to assign the cursor value to. field ( str ): The field to read from the most recently retrieved object to use as the cursor value. Examples If an API request returns the following: 1 2 3 4 5 6 7 { \"messages\" : [ { \"id\" : 1 , \"msg\" : \"this is\" }, { \"id\" : 2 , \"msg\" : \"a\" } { \"id\" : 3 , \"msg\" : \"test\" } ] } This strategy will take the field id from the last item returned and generate a new request with a query param of after=3 1 2 3 4 5 pagination : strategy : cursor configuration : cursor_param : after field : id","title":"SaaS Pagination"},{"location":"saas_connectors/saas_pagination/#saas-pagination","text":"These pagination strategies allow fidesops to incrementally retrieve content from SaaS APIs. APIs can vary in the way subsequent pages are accessed so these configurable options aim to cover a majority of common use cases.","title":"SaaS Pagination"},{"location":"saas_connectors/saas_pagination/#supported-strategies","text":"offset : Iterates through the available pages by incrementing the value of a query param. link : Uses links returned in the headers or the body to get to the next page. cursor : Uses a value from the last-retrieved object to use as a query param pointing to the next set of results.","title":"Supported strategies"},{"location":"saas_connectors/saas_pagination/#offset","text":"This strategy can be used to iterate through pages, or to define the offset for a batch of results. In either case, this strategy increments the specified query param by the increment_by value until no more results are returned or the limit is reached.","title":"Offset"},{"location":"saas_connectors/saas_pagination/#configuration-details","text":"incremental_param ( str ): The query param to increment the value for. increment_by ( int ): The value to increment the incremental_param after each set of results. limit ( str ): The max value the incremental_param can reach.","title":"Configuration details"},{"location":"saas_connectors/saas_pagination/#example","text":"This example would take the page query param and increment it by 1 until the limit of 10 is reached or no more results are returned (whichever comes first). 1 2 3 4 5 6 pagination : strategy : offset configuration : incremental_param : page increment_by : 1 limit : 10","title":"Example"},{"location":"saas_connectors/saas_pagination/#link","text":"This strategy is used when the link to the next page is provided as part of the API response. The link is read from the headers or the body and used to get the next page of results.","title":"Link"},{"location":"saas_connectors/saas_pagination/#configuration-details_1","text":"source ( str ): The location to get the link from, can be either headers or body . path ( str ): The expression used to refer to the location of the link within the headers or the body.","title":"Configuration details"},{"location":"saas_connectors/saas_pagination/#examples","text":"The source value of headers is meant to be used with responses following RFC 5988 . 1 2 Link: <https://api.host.com/conversations?page_ref=ad6f38r3>; rel=\"next\", <https://api.host.com/conversations?page_ref=gss8ap4g>; rel=\"prev\" Given this Link header, we can specify a rel of next (case-insensitive). This indicates that we are looking in the Link header with a rel of next. 1 2 3 4 5 pagination : strategy : link configuration : source : headers rel : next We can also access links returned in the body. If we receive this value in the body: 1 2 3 4 5 6 7 { ... \"next_page\" : { \"url\" : \"https://api.host.com/conversations?page_ref=ad6f38r3\" } ... } We can use the path value of next_page.url as the expression to access the url. 1 2 3 4 5 pagination : strategy : link configuration : source : body path : next_page.url","title":"Examples"},{"location":"saas_connectors/saas_pagination/#cursor","text":"This strategy is used when a specific value from a response object is used as a cursor to determine the starting point for the next set of results.","title":"Cursor"},{"location":"saas_connectors/saas_pagination/#configuration-details_2","text":"cursor_param ( str ): The name of the query param to assign the cursor value to. field ( str ): The field to read from the most recently retrieved object to use as the cursor value.","title":"Configuration Details"},{"location":"saas_connectors/saas_pagination/#examples_1","text":"If an API request returns the following: 1 2 3 4 5 6 7 { \"messages\" : [ { \"id\" : 1 , \"msg\" : \"this is\" }, { \"id\" : 2 , \"msg\" : \"a\" } { \"id\" : 3 , \"msg\" : \"test\" } ] } This strategy will take the field id from the last item returned and generate a new request with a query param of after=3 1 2 3 4 5 pagination : strategy : cursor configuration : cursor_param : after field : id","title":"Examples"},{"location":"saas_connectors/saas_postprocessors/","text":"SaaS Post-Processors Post-processors are, in essence, data transformers. Given data from an endpoint, we can add specific processors to transform the data into a format we need for subject requests. Configuration Post-processors are configured within the endpoints section of a saas_config : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 endpoints : - name : messages requests : read : method : GET path : /conversations/<id>/messages param_values : ... postprocessors : - strategy : unwrap configuration : data_path : conversation_messages - strategy : filter configuration : field : from_email value : identity : email Note: Order matters as it's defined in the config. In the above example, unwrap will be run first, then the output of unwrap will be used in the filter strategy. Format subsequent requests Post-processors can format the results of your access requests for use in subsequent update or delete statements. For example, if we need to return the following in an access request: 1 2 3 4 5 { \"recipient\" : \"test@email.com\" , \"subscriptions\" : [{ \"id\" : \"123\" , \"subscribed\" : \"TRUE\" }]} And we needed to perform an update request for each item within subscriptions , where subscribed = TRUE , then we'd need the following config for our update request: 1 2 3 4 5 6 7 8 update : ... data_path : subscriptionStatuses postprocessors : - strategy : filter configuration : field : subscribed value : TRUE Supported Strategies unwrap : Gets object at given data path. filter : Removes data that does not match a given field and value. Filter Filters object or array given field name and value. Value can reference a dynamic identity passed in through the request OR be a hard-coded value. Configuration details strategy : filter configuration : field ( str ): Corresponds to the field on which to filter. For example, we wish to filter where email_contact == \"bob@mail.com\" , then field will be email_contact . value ( str ): Value to search for when filtering (e.g. hard-coded bob@mail.com ) or Dict of identity path: identity ( str ): Identity object from subject request (e.g. email or phone_number ) exact (optional bool defaults to True): value and field value must be the same length (no extra characters). case_sensitive (optional bool defaults to True): Cases must match between value and field value. Examples Post-Processor Config: 1 2 3 4 5 - strategy : filter configuration : field : email_contact value : identity : email Identity data passed in through request: 1 2 3 { \"email\" : \"somebody@email.com\" } Data to be processed: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 238475234 , \"email_contact\" : \"somebody-else@email.com\" , \"name\" : \"Somebody Cool\" } ] Result: 1 2 3 4 5 6 7 [ { \"id\" : 1397429347 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] By default, this filter is exact and case-sensitive. Post-Processor Config: 1 2 3 4 5 6 7 - strategy : filter configuration : field : email_contact value : identity : email exact : False case_sensitive : False Identity data passed in through request: 1 2 3 { \"email\" : \"somebody@email.com\" } Data to be processed: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"[Somebody Awesome] SOMEBODY@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 1397429348 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] Result: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"[Somebody Awesome] SOMEBODY@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 1397429348 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] We can configure how strict the filter is by setting exact and case_sensitive both to False. This allows our value to be a substring of a longer string, and to ignore case (upper vs lower case). Note: Type casting is not supported at this time. We currently only support filtering by string values. e.g. bob@mail.com and not 12344245 . Unwrap Given a path to a dict/list, returns the dict/list at that location. Configuration details strategy : unwrap configuration : data_path ( str ): Gives the path to desired object. E.g. exact_matches.members will attempt to get the members object on the exact_matches object. Example Post-Processor Config: 1 2 3 - strategy : unwrap configuration : data_path : exact_matches.members Data to be processed: 1 2 3 4 5 6 7 8 { \"exact_matches\" : { \"members\" : [ { \"howdy\" : 123 }, { \"meow\" : 841 } ] } } Result: 1 2 3 4 [ { \"howdy\" : 123 }, { \"meow\" : 841 } ]","title":"SaaS Post-Processors"},{"location":"saas_connectors/saas_postprocessors/#saas-post-processors","text":"Post-processors are, in essence, data transformers. Given data from an endpoint, we can add specific processors to transform the data into a format we need for subject requests.","title":"SaaS Post-Processors"},{"location":"saas_connectors/saas_postprocessors/#configuration","text":"Post-processors are configured within the endpoints section of a saas_config : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 endpoints : - name : messages requests : read : method : GET path : /conversations/<id>/messages param_values : ... postprocessors : - strategy : unwrap configuration : data_path : conversation_messages - strategy : filter configuration : field : from_email value : identity : email Note: Order matters as it's defined in the config. In the above example, unwrap will be run first, then the output of unwrap will be used in the filter strategy.","title":"Configuration"},{"location":"saas_connectors/saas_postprocessors/#format-subsequent-requests","text":"Post-processors can format the results of your access requests for use in subsequent update or delete statements. For example, if we need to return the following in an access request: 1 2 3 4 5 { \"recipient\" : \"test@email.com\" , \"subscriptions\" : [{ \"id\" : \"123\" , \"subscribed\" : \"TRUE\" }]} And we needed to perform an update request for each item within subscriptions , where subscribed = TRUE , then we'd need the following config for our update request: 1 2 3 4 5 6 7 8 update : ... data_path : subscriptionStatuses postprocessors : - strategy : filter configuration : field : subscribed value : TRUE","title":"Format subsequent requests"},{"location":"saas_connectors/saas_postprocessors/#supported-strategies","text":"unwrap : Gets object at given data path. filter : Removes data that does not match a given field and value.","title":"Supported Strategies"},{"location":"saas_connectors/saas_postprocessors/#filter","text":"Filters object or array given field name and value. Value can reference a dynamic identity passed in through the request OR be a hard-coded value.","title":"Filter"},{"location":"saas_connectors/saas_postprocessors/#configuration-details","text":"strategy : filter configuration : field ( str ): Corresponds to the field on which to filter. For example, we wish to filter where email_contact == \"bob@mail.com\" , then field will be email_contact . value ( str ): Value to search for when filtering (e.g. hard-coded bob@mail.com ) or Dict of identity path: identity ( str ): Identity object from subject request (e.g. email or phone_number ) exact (optional bool defaults to True): value and field value must be the same length (no extra characters). case_sensitive (optional bool defaults to True): Cases must match between value and field value.","title":"Configuration details"},{"location":"saas_connectors/saas_postprocessors/#examples","text":"Post-Processor Config: 1 2 3 4 5 - strategy : filter configuration : field : email_contact value : identity : email Identity data passed in through request: 1 2 3 { \"email\" : \"somebody@email.com\" } Data to be processed: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 238475234 , \"email_contact\" : \"somebody-else@email.com\" , \"name\" : \"Somebody Cool\" } ] Result: 1 2 3 4 5 6 7 [ { \"id\" : 1397429347 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] By default, this filter is exact and case-sensitive. Post-Processor Config: 1 2 3 4 5 6 7 - strategy : filter configuration : field : email_contact value : identity : email exact : False case_sensitive : False Identity data passed in through request: 1 2 3 { \"email\" : \"somebody@email.com\" } Data to be processed: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"[Somebody Awesome] SOMEBODY@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 1397429348 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] Result: 1 2 3 4 5 6 7 8 9 10 11 12 [ { \"id\" : 1397429347 , \"email_contact\" : \"[Somebody Awesome] SOMEBODY@email.com\" , \"name\" : \"Somebody Awesome\" }, { \"id\" : 1397429348 , \"email_contact\" : \"somebody@email.com\" , \"name\" : \"Somebody Awesome\" } ] We can configure how strict the filter is by setting exact and case_sensitive both to False. This allows our value to be a substring of a longer string, and to ignore case (upper vs lower case). Note: Type casting is not supported at this time. We currently only support filtering by string values. e.g. bob@mail.com and not 12344245 .","title":"Examples"},{"location":"saas_connectors/saas_postprocessors/#unwrap","text":"Given a path to a dict/list, returns the dict/list at that location.","title":"Unwrap"},{"location":"saas_connectors/saas_postprocessors/#configuration-details_1","text":"strategy : unwrap configuration : data_path ( str ): Gives the path to desired object. E.g. exact_matches.members will attempt to get the members object on the exact_matches object.","title":"Configuration details"},{"location":"saas_connectors/saas_postprocessors/#example","text":"Post-Processor Config: 1 2 3 - strategy : unwrap configuration : data_path : exact_matches.members Data to be processed: 1 2 3 4 5 6 7 8 { \"exact_matches\" : { \"members\" : [ { \"howdy\" : 123 }, { \"meow\" : 841 } ] } } Result: 1 2 3 4 [ { \"howdy\" : 123 }, { \"meow\" : 841 } ]","title":"Example"},{"location":"saas_connectors/example_configs/adobe/","text":"Adobe Campaign Implementation Summary Fidesops uses the following Adobe Campaign endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Profile Yes Yes History Yes Yes Privacy Tool Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Adobe Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 saas_config : fides_key : adobe_campaign_connector_example name : Adobe Campaign SaaS Config type : adobe_campaign description : A schema representing the Adobe Campaign connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : mc.adobe.io - name : organization_id - name : namespace default_value : defaultNamespace1 description : The namespace to use for data protections requests - name : regulation description : The regulation to follow for data protection requests - name : client_id - name : access_token client_config : protocol : https host : <domain>/<organization_id> authentication : strategy : bearer configuration : token : <access_token> test_request : method : GET path : /campaign/profileAndServices/profile/PKey headers : - name : X-Api-Key value : <client_id> query_params : - name : _lineCount value : 1 param_values : - name : client_id connector_param : client_id endpoints : - name : profile requests : read : method : GET path : /campaign/profileAndServices/profile/byEmail headers : - name : X-Api-Key value : <client_id> query_params : - name : email value : <email> param_values : - name : client_id connector_param : client_id - name : email identity : email data_path : content - name : marketing_history requests : read : method : GET path : /campaign/profileAndServices/history/byEmail headers : - name : X-Api-Key value : <client_id> query_params : - name : email value : <email> param_values : - name : client_id connector_param : client_id - name : email identity : email data_path : content data_protection_request : method : POST path : /campaign/privacy/privacyTool headers : - name : X-Api-Key value : <client_id> param_values : - name : client_id connector_param : client_id - name : regulation connector_param : regulation - name : namespace connector_param : namespace - name : reconciliation_value identity : email body : | { \"name\": \"<privacy_request_id>\", \"namespaceName\": \"<namespace>\", \"reconciliationValue\": \"<reconciliation_value>\", \"regulation\": \"<regulation>\", \"label\": \"Erasure Request\", \"type\": \"delete\" }","title":"Adobe Campaign"},{"location":"saas_connectors/example_configs/adobe/#adobe-campaign","text":"","title":"Adobe Campaign"},{"location":"saas_connectors/example_configs/adobe/#implementation-summary","text":"Fidesops uses the following Adobe Campaign endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Profile Yes Yes History Yes Yes Privacy Tool Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/adobe/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/adobe/#example-adobe-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 saas_config : fides_key : adobe_campaign_connector_example name : Adobe Campaign SaaS Config type : adobe_campaign description : A schema representing the Adobe Campaign connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : mc.adobe.io - name : organization_id - name : namespace default_value : defaultNamespace1 description : The namespace to use for data protections requests - name : regulation description : The regulation to follow for data protection requests - name : client_id - name : access_token client_config : protocol : https host : <domain>/<organization_id> authentication : strategy : bearer configuration : token : <access_token> test_request : method : GET path : /campaign/profileAndServices/profile/PKey headers : - name : X-Api-Key value : <client_id> query_params : - name : _lineCount value : 1 param_values : - name : client_id connector_param : client_id endpoints : - name : profile requests : read : method : GET path : /campaign/profileAndServices/profile/byEmail headers : - name : X-Api-Key value : <client_id> query_params : - name : email value : <email> param_values : - name : client_id connector_param : client_id - name : email identity : email data_path : content - name : marketing_history requests : read : method : GET path : /campaign/profileAndServices/history/byEmail headers : - name : X-Api-Key value : <client_id> query_params : - name : email value : <email> param_values : - name : client_id connector_param : client_id - name : email identity : email data_path : content data_protection_request : method : POST path : /campaign/privacy/privacyTool headers : - name : X-Api-Key value : <client_id> param_values : - name : client_id connector_param : client_id - name : regulation connector_param : regulation - name : namespace connector_param : namespace - name : reconciliation_value identity : email body : | { \"name\": \"<privacy_request_id>\", \"namespaceName\": \"<namespace>\", \"reconciliationValue\": \"<reconciliation_value>\", \"regulation\": \"<regulation>\", \"label\": \"Erasure Request\", \"type\": \"delete\" }","title":"Example Adobe Configuration"},{"location":"saas_connectors/example_configs/hubspot/","text":"Hubspot Implementation Summary Fidesops uses the following Hubspot endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Search Yes No Contacts Yes Yes Owners Yes No Communication Preferences Yes Yes Users Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Hubspot Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 saas_config : fides_key : hubspot_connector_example name : Hubspot SaaS Config type : hubspot description : A sample schema representing the Hubspot connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : api.hubapi.com - name : private_app_token client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <private_app_token> test_request : method : GET path : /companies/v2/companies/paged endpoints : - name : contacts requests : read : path : /crm/v3/objects/contacts/search method : POST body : | { \"filterGroups\": [{ \"filters\": [{ \"value\": \"<email>\", \"propertyName\": \"email\", \"operator\": \"EQ\" }] }] } query_params : - name : limit value : 100 param_values : - name : email identity : email data_path : results pagination : strategy : link configuration : source : body path : paging.next.link update : path : /crm/v3/objects/contacts/<contactId> method : PATCH body : | { <masked_object_fields> } param_values : - name : contactId references : - dataset : hubspot_connector_example field : contacts.id direction : from - name : owners requests : read : path : /crm/v3/owners method : GET query_params : - name : limit value : 100 param_values : - name : placeholder identity : email postprocessors : - strategy : unwrap configuration : data_path : results - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : body path : paging.next.link - name : subscription_preferences requests : read : path : /communication-preferences/v3/status/email/<email> method : GET param_values : - name : email identity : email update : path : /communication-preferences/v3/unsubscribe method : POST body : | { \"emailAddress\": \"<email>\", \"subscriptionId\": \"<subscriptionId>\", \"legalBasis\": \"LEGITIMATE_INTEREST_CLIENT\", \"legalBasisExplanation\": \"At users request, we opted them out\" } data_path : subscriptionStatuses param_values : - name : email identity : email - name : subscriptionId references : - dataset : hubspot_connector_example field : subscription_preferences.id direction : from postprocessors : - strategy : filter configuration : field : status value : SUBSCRIBED - name : users requests : read : path : /settings/v3/users/ method : GET query_params : - name : limit value : 100 param_values : - name : placeholder identity : email postprocessors : - strategy : unwrap configuration : data_path : results - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : body path : paging.next.link delete : path : /settings/v3/users/<userId> method : DELETE param_values : - name : userId references : - dataset : hubspot_connector_example field : users.id direction : from","title":"Hubspot"},{"location":"saas_connectors/example_configs/hubspot/#hubspot","text":"","title":"Hubspot"},{"location":"saas_connectors/example_configs/hubspot/#implementation-summary","text":"Fidesops uses the following Hubspot endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Search Yes No Contacts Yes Yes Owners Yes No Communication Preferences Yes Yes Users Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/hubspot/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/hubspot/#example-hubspot-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 saas_config : fides_key : hubspot_connector_example name : Hubspot SaaS Config type : hubspot description : A sample schema representing the Hubspot connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : api.hubapi.com - name : private_app_token client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <private_app_token> test_request : method : GET path : /companies/v2/companies/paged endpoints : - name : contacts requests : read : path : /crm/v3/objects/contacts/search method : POST body : | { \"filterGroups\": [{ \"filters\": [{ \"value\": \"<email>\", \"propertyName\": \"email\", \"operator\": \"EQ\" }] }] } query_params : - name : limit value : 100 param_values : - name : email identity : email data_path : results pagination : strategy : link configuration : source : body path : paging.next.link update : path : /crm/v3/objects/contacts/<contactId> method : PATCH body : | { <masked_object_fields> } param_values : - name : contactId references : - dataset : hubspot_connector_example field : contacts.id direction : from - name : owners requests : read : path : /crm/v3/owners method : GET query_params : - name : limit value : 100 param_values : - name : placeholder identity : email postprocessors : - strategy : unwrap configuration : data_path : results - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : body path : paging.next.link - name : subscription_preferences requests : read : path : /communication-preferences/v3/status/email/<email> method : GET param_values : - name : email identity : email update : path : /communication-preferences/v3/unsubscribe method : POST body : | { \"emailAddress\": \"<email>\", \"subscriptionId\": \"<subscriptionId>\", \"legalBasis\": \"LEGITIMATE_INTEREST_CLIENT\", \"legalBasisExplanation\": \"At users request, we opted them out\" } data_path : subscriptionStatuses param_values : - name : email identity : email - name : subscriptionId references : - dataset : hubspot_connector_example field : subscription_preferences.id direction : from postprocessors : - strategy : filter configuration : field : status value : SUBSCRIBED - name : users requests : read : path : /settings/v3/users/ method : GET query_params : - name : limit value : 100 param_values : - name : placeholder identity : email postprocessors : - strategy : unwrap configuration : data_path : results - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : body path : paging.next.link delete : path : /settings/v3/users/<userId> method : DELETE param_values : - name : userId references : - dataset : hubspot_connector_example field : users.id direction : from","title":"Example Hubspot Configuration"},{"location":"saas_connectors/example_configs/mailchimp/","text":"Mailchimp Implementation Summary Fidesops uses the following Mailchimp endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Messages Yes No Conversations Yes No Members Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Mailchimp Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 saas_config : fides_key : mailchimp_connector_example name : Mailchimp SaaS Config description : A sample schema representing the Mailchimp connector for fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /3.0/lists endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from data_path : conversation_messages postprocessors : - strategy : filter configuration : field : from_email value : identity : email - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email data_path : conversations pagination : strategy : offset configuration : incremental_param : offset increment_by : 1000 limit : 10000 - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email data_path : exact_matches.members update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from","title":"Mailchimp"},{"location":"saas_connectors/example_configs/mailchimp/#mailchimp","text":"","title":"Mailchimp"},{"location":"saas_connectors/example_configs/mailchimp/#implementation-summary","text":"Fidesops uses the following Mailchimp endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Messages Yes No Conversations Yes No Members Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/mailchimp/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/mailchimp/#example-mailchimp-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 saas_config : fides_key : mailchimp_connector_example name : Mailchimp SaaS Config description : A sample schema representing the Mailchimp connector for fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /3.0/lists endpoints : - name : messages requests : read : method : GET path : /3.0/conversations/<conversation_id>/messages param_values : - name : conversation_id references : - dataset : mailchimp_connector_example field : conversations.id direction : from data_path : conversation_messages postprocessors : - strategy : filter configuration : field : from_email value : identity : email - name : conversations requests : read : method : GET path : /3.0/conversations query_params : - name : count value : 1000 - name : offset value : 0 param_values : - name : placeholder identity : email data_path : conversations pagination : strategy : offset configuration : incremental_param : offset increment_by : 1000 limit : 10000 - name : member requests : read : method : GET path : /3.0/search-members query_params : - name : query value : <email> param_values : - name : email identity : email data_path : exact_matches.members update : method : PUT path : /3.0/lists/<list_id>/members/<subscriber_hash> param_values : - name : list_id references : - dataset : mailchimp_connector_example field : member.list_id direction : from - name : subscriber_hash references : - dataset : mailchimp_connector_example field : member.id direction : from","title":"Example Mailchimp Configuration"},{"location":"saas_connectors/example_configs/outreach/","text":"Outreach Implementation Summary Fidesops uses the following Outreach endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Prospects Yes Yes Recipients Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Outreach Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 saas_config : fides_key : outreach_connector_example name : Outreach Example Config type : outreach description : A sample schema representing the Outreach connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : platform.segmentapis.com - name : requester_email description : The email of the Outreach user to associate with each automated compliance request (data_protection_request) - name : client_id - name : client_secret - name : redirect_uri - name : page_size description : The number of entries to return per page client_config : protocol : https host : <domain> authentication : strategy : oauth2_authorization_code configuration : authorization_request : method : GET path : /auth/authorize query_params : - name : client_id value : <client_id> - name : redirect_uri value : <redirect_uri> - name : response_type value : code - name : scope value : prospects.all recipients.all teams.all roles.all accounts.all audits.all callDispositions.all callPurposes.all calls.all complianceRequests.all contentCategories.all contentCategoryMemberships.all contentCategoryOwnerships.all duties.all emailAddresses.all events.all favorites.all mailAliases.all mailboxes.all mailings.all opportunities.all opportunityProspectRoles.all opportunityStages.all personas.all phoneNumbers.all profiles.all rulesets.all sequenceStates.all sequenceSteps.all sequenceTemplates.all sequences.all snippets.all stages.all taskPriorities.all tasks.all templates.all users.all webhooks.all - name : state value : <state> token_request : method : POST path : /oauth/token headers : - name : Content-Type value : application/x-www-form-urlencoded query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : authorization_code - name : code value : <code> - name : redirect_uri value : <redirect_uri> refresh_request : method : POST path : /oauth/token headers : - name : Content-Type value : application/x-www-form-urlencoded query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : redirect_uri value : <redirect_uri> - name : grant_type value : refresh_token - name : refresh_token value : <refresh_token> test_request : method : GET path : /api/v2/roles endpoints : - name : prospects requests : read : method : GET path : /api/v2/prospects query_params : - name : filter[emails] value : <email> param_values : - name : email identity : email data_path : data delete : method : POST path : /api/v2/complianceRequests param_values : - name : requester_email connector_param : requester_email - name : email identity : email body : | { \"data\": { \"type\": \"complianceRequest\", \"attributes\": { \"requester_email\": \"<requester_email>\", \"request_type\": \"Delete\", \"object_type\": \"Prospect\", \"request_object_email\": \"<email>\" } } } - name : recipients requests : read : method : GET path : /api/v2/recipients query_params : - name : page[size] value : <page_size> param_values : - name : page_size connector_param : page_size - name : placeholder identity : email data_path : data pagination : strategy : link configuration : source : body path : links.next postprocessors : - strategy : filter configuration : field : attributes.value value : identity : email exact : False case_sensitive : False delete : method : POST path : /api/v2/complianceRequests param_values : - name : requester_email connector_param : requester_email - name : email identity : email body : | { \"data\": { \"type\": \"complianceRequest\", \"attributes\": { \"requester_email\": \"<requester_email>\", \"request_type\": \"Delete\", \"object_type\": \"Recipient\", \"request_object_email\": \"<email>\" } } }","title":"Outreach"},{"location":"saas_connectors/example_configs/outreach/#outreach","text":"","title":"Outreach"},{"location":"saas_connectors/example_configs/outreach/#implementation-summary","text":"Fidesops uses the following Outreach endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Prospects Yes Yes Recipients Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/outreach/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/outreach/#example-outreach-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 saas_config : fides_key : outreach_connector_example name : Outreach Example Config type : outreach description : A sample schema representing the Outreach connector for Fidesops version : 0.0.1 connector_params : - name : domain default_value : platform.segmentapis.com - name : requester_email description : The email of the Outreach user to associate with each automated compliance request (data_protection_request) - name : client_id - name : client_secret - name : redirect_uri - name : page_size description : The number of entries to return per page client_config : protocol : https host : <domain> authentication : strategy : oauth2_authorization_code configuration : authorization_request : method : GET path : /auth/authorize query_params : - name : client_id value : <client_id> - name : redirect_uri value : <redirect_uri> - name : response_type value : code - name : scope value : prospects.all recipients.all teams.all roles.all accounts.all audits.all callDispositions.all callPurposes.all calls.all complianceRequests.all contentCategories.all contentCategoryMemberships.all contentCategoryOwnerships.all duties.all emailAddresses.all events.all favorites.all mailAliases.all mailboxes.all mailings.all opportunities.all opportunityProspectRoles.all opportunityStages.all personas.all phoneNumbers.all profiles.all rulesets.all sequenceStates.all sequenceSteps.all sequenceTemplates.all sequences.all snippets.all stages.all taskPriorities.all tasks.all templates.all users.all webhooks.all - name : state value : <state> token_request : method : POST path : /oauth/token headers : - name : Content-Type value : application/x-www-form-urlencoded query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : grant_type value : authorization_code - name : code value : <code> - name : redirect_uri value : <redirect_uri> refresh_request : method : POST path : /oauth/token headers : - name : Content-Type value : application/x-www-form-urlencoded query_params : - name : client_id value : <client_id> - name : client_secret value : <client_secret> - name : redirect_uri value : <redirect_uri> - name : grant_type value : refresh_token - name : refresh_token value : <refresh_token> test_request : method : GET path : /api/v2/roles endpoints : - name : prospects requests : read : method : GET path : /api/v2/prospects query_params : - name : filter[emails] value : <email> param_values : - name : email identity : email data_path : data delete : method : POST path : /api/v2/complianceRequests param_values : - name : requester_email connector_param : requester_email - name : email identity : email body : | { \"data\": { \"type\": \"complianceRequest\", \"attributes\": { \"requester_email\": \"<requester_email>\", \"request_type\": \"Delete\", \"object_type\": \"Prospect\", \"request_object_email\": \"<email>\" } } } - name : recipients requests : read : method : GET path : /api/v2/recipients query_params : - name : page[size] value : <page_size> param_values : - name : page_size connector_param : page_size - name : placeholder identity : email data_path : data pagination : strategy : link configuration : source : body path : links.next postprocessors : - strategy : filter configuration : field : attributes.value value : identity : email exact : False case_sensitive : False delete : method : POST path : /api/v2/complianceRequests param_values : - name : requester_email connector_param : requester_email - name : email identity : email body : | { \"data\": { \"type\": \"complianceRequest\", \"attributes\": { \"requester_email\": \"<requester_email>\", \"request_type\": \"Delete\", \"object_type\": \"Recipient\", \"request_object_email\": \"<email>\" } } }","title":"Example Outreach Configuration"},{"location":"saas_connectors/example_configs/salesforce/","text":"Salesforce Implementation Summary Fidesops uses the following Salesforce endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. For more information, see the Salesforce sObject API reference . Endpoint Right to Access Right to Delete Query Yes No Contact Yes Yes Case Yes Yes Lead Yes Yes Account Yes Yes CampaignMember Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Salesforce Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 saas_config : fides_key : salesforce_connector_example name : Salesforce SaaS Config type : salesforce description : A sample schema representing the Salesforce connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : password - name : client_id - name : client_secret - name : access_token client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <access_token> test_request : method : GET path : /services/data/v54.0/sobjects endpoints : - name : contact_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Contact WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : contacts requests : read : method : GET path : /services/data/v54.0/sobjects/Contact/<contact_id> param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contact_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Contact/<contact_id> body : | { <masked_object_fields> } param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contacts.Id direction : from - name : case_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Case WHERE ContactId='<contact_id>' param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contact_list.Id direction : from data_path : records - name : cases requests : read : method : GET path : /services/data/v54.0/sobjects/Case/<case_id> param_values : - name : case_id references : - dataset : salesforce_connector_example field : case_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Case/<case_id> body : | { <masked_object_fields> } param_values : - name : case_id references : - dataset : salesforce_connector_example field : cases.Id direction : from - name : lead_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Lead WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : leads requests : read : method : GET path : /services/data/v54.0/sobjects/Lead/<lead_id> param_values : - name : lead_id references : - dataset : salesforce_connector_example field : lead_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Lead/<lead_id> body : | { <masked_object_fields> } param_values : - name : lead_id references : - dataset : salesforce_connector_example field : leads.Id direction : from - name : accounts requests : read : method : GET path : /services/data/v54.0/sobjects/Account/<account_id> param_values : - name : account_id references : - dataset : salesforce_connector_example field : contacts.AccountId update : method : PATCH path : /services/data/v54.0/sobjects/Account/<account_id> body : | { <masked_object_fields> } param_values : - name : account_id references : - dataset : salesforce_connector_example field : accounts.Id direction : from - name : campaign_member_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM CampaignMember WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : campaign_members requests : read : method : GET path : /services/data/v54.0/sobjects/CampaignMember/<campaign_member_id> param_values : - name : campaign_member_id references : - dataset : salesforce_connector_example field : campaign_member_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/CampaignMember/<campaign_member_id> body : | { <masked_object_fields> } param_values : - name : campaign_member_id references : - dataset : salesforce_connector_example field : campaign_members.Id direction : from","title":"Salesforce"},{"location":"saas_connectors/example_configs/salesforce/#salesforce","text":"","title":"Salesforce"},{"location":"saas_connectors/example_configs/salesforce/#implementation-summary","text":"Fidesops uses the following Salesforce endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. For more information, see the Salesforce sObject API reference . Endpoint Right to Access Right to Delete Query Yes No Contact Yes Yes Case Yes Yes Lead Yes Yes Account Yes Yes CampaignMember Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/salesforce/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/salesforce/#example-salesforce-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 saas_config : fides_key : salesforce_connector_example name : Salesforce SaaS Config type : salesforce description : A sample schema representing the Salesforce connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : password - name : client_id - name : client_secret - name : access_token client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <access_token> test_request : method : GET path : /services/data/v54.0/sobjects endpoints : - name : contact_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Contact WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : contacts requests : read : method : GET path : /services/data/v54.0/sobjects/Contact/<contact_id> param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contact_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Contact/<contact_id> body : | { <masked_object_fields> } param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contacts.Id direction : from - name : case_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Case WHERE ContactId='<contact_id>' param_values : - name : contact_id references : - dataset : salesforce_connector_example field : contact_list.Id direction : from data_path : records - name : cases requests : read : method : GET path : /services/data/v54.0/sobjects/Case/<case_id> param_values : - name : case_id references : - dataset : salesforce_connector_example field : case_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Case/<case_id> body : | { <masked_object_fields> } param_values : - name : case_id references : - dataset : salesforce_connector_example field : cases.Id direction : from - name : lead_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM Lead WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : leads requests : read : method : GET path : /services/data/v54.0/sobjects/Lead/<lead_id> param_values : - name : lead_id references : - dataset : salesforce_connector_example field : lead_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/Lead/<lead_id> body : | { <masked_object_fields> } param_values : - name : lead_id references : - dataset : salesforce_connector_example field : leads.Id direction : from - name : accounts requests : read : method : GET path : /services/data/v54.0/sobjects/Account/<account_id> param_values : - name : account_id references : - dataset : salesforce_connector_example field : contacts.AccountId update : method : PATCH path : /services/data/v54.0/sobjects/Account/<account_id> body : | { <masked_object_fields> } param_values : - name : account_id references : - dataset : salesforce_connector_example field : accounts.Id direction : from - name : campaign_member_list requests : read : method : GET path : /services/data/v54.0/query query_params : - name : q value : SELECT Id FROM CampaignMember WHERE Email='<email>' param_values : - name : email identity : email data_path : records - name : campaign_members requests : read : method : GET path : /services/data/v54.0/sobjects/CampaignMember/<campaign_member_id> param_values : - name : campaign_member_id references : - dataset : salesforce_connector_example field : campaign_member_list.Id direction : from update : method : PATCH path : /services/data/v54.0/sobjects/CampaignMember/<campaign_member_id> body : | { <masked_object_fields> } param_values : - name : campaign_member_id references : - dataset : salesforce_connector_example field : campaign_members.Id direction : from","title":"Example Salesforce Configuration"},{"location":"saas_connectors/example_configs/segment/","text":"Segment Implementation Summary Fidesops uses the following Segment endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Users Yes No Events Yes No Traits Yes No External IDs Yes No Regulations Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Segment Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 saas_config : fides_key : segment_connector_example name : Segment SaaS Config description : A sample schema representing the Segment connector for fidesops version : 0.0.1 connector_params : - name : domain - name : personas_domain - name : workspace - name : access_token - name : namespace_id - name : access_secret client_config : protocol : https host : connector_param : domain authentication : strategy : bearer_authentication configuration : token : connector_param : access_token test_request : method : GET path : /v1beta/workspaces/ endpoints : - name : segment_user requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/user_id:<user_id>/metadata param_values : - name : namespace_id connector_param : namespace_id - name : user_id identity : email client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : track_events requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/events param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : data pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : traits requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/traits query_params : - name : limit value : 17 param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : traits pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : external_ids requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/external_ids param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : data pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret data_protection_request : method : POST path : /v1beta/workspaces/<workspace_name>/regulations headers : - name : Content-Type value : application/json param_values : - name : workspace_name connector_param : workspace - name : user_id identity : email body : '{\"regulation_type\": \"Suppress_With_Delete\", \"attributes\": {\"name\": \"userId\", \"values\": [\"<user_id>\"]}}' client_config : protocol : https host : connector_param : domain authentication : strategy : bearer_authentication configuration : token : connector_param : access_token","title":"Segment"},{"location":"saas_connectors/example_configs/segment/#segment","text":"","title":"Segment"},{"location":"saas_connectors/example_configs/segment/#implementation-summary","text":"Fidesops uses the following Segment endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Users Yes No Events Yes No Traits Yes No External IDs Yes No Regulations Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/segment/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/segment/#example-segment-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 saas_config : fides_key : segment_connector_example name : Segment SaaS Config description : A sample schema representing the Segment connector for fidesops version : 0.0.1 connector_params : - name : domain - name : personas_domain - name : workspace - name : access_token - name : namespace_id - name : access_secret client_config : protocol : https host : connector_param : domain authentication : strategy : bearer_authentication configuration : token : connector_param : access_token test_request : method : GET path : /v1beta/workspaces/ endpoints : - name : segment_user requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/user_id:<user_id>/metadata param_values : - name : namespace_id connector_param : namespace_id - name : user_id identity : email client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : track_events requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/events param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : data pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : traits requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/traits query_params : - name : limit value : 17 param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : traits pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret - name : external_ids requests : read : method : GET path : /v1/spaces/<namespace_id>/collections/users/profiles/<segment_id>/external_ids param_values : - name : namespace_id connector_param : namespace_id - name : segment_id references : - dataset : segment_connector_example field : segment_user.segment_id direction : from data_path : data pagination : strategy : link configuration : source : body path : cursor.url client_config : protocol : https host : connector_param : personas_domain authentication : strategy : basic_authentication configuration : username : connector_param : access_secret data_protection_request : method : POST path : /v1beta/workspaces/<workspace_name>/regulations headers : - name : Content-Type value : application/json param_values : - name : workspace_name connector_param : workspace - name : user_id identity : email body : '{\"regulation_type\": \"Suppress_With_Delete\", \"attributes\": {\"name\": \"userId\", \"values\": [\"<user_id>\"]}}' client_config : protocol : https host : connector_param : domain authentication : strategy : bearer_authentication configuration : token : connector_param : access_token","title":"Example Segment Configuration"},{"location":"saas_connectors/example_configs/sendgrid/","text":"Sendgrid Implementation Summary Fidesops uses the following Sendgrid endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Contacts Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to fALSE . Example Sendgrid Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 saas_config : fides_key : sendgrid_connector_example name : Sendgrid SaaS Config type : sendgrid description : A sample schema representing the Sendgrid connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : api_key client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <api_key> test_request : method : GET path : /v3/marketing/contacts endpoints : - name : contacts requests : read : method : POST path : /v3/marketing/contacts/search body : | { \"query\": \"email = '<email>'\" } param_values : - name : email identity : email data_path : result delete : method : DELETE path : /v3/marketing/contacts?ids=<contact_id> param_values : - name : contact_id references : - dataset : sendgrid_connector_example field : contacts.id direction : from","title":"Sendgrid"},{"location":"saas_connectors/example_configs/sendgrid/#sendgrid","text":"","title":"Sendgrid"},{"location":"saas_connectors/example_configs/sendgrid/#implementation-summary","text":"Fidesops uses the following Sendgrid endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Contacts Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/sendgrid/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to fALSE .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/sendgrid/#example-sendgrid-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 saas_config : fides_key : sendgrid_connector_example name : Sendgrid SaaS Config type : sendgrid description : A sample schema representing the Sendgrid connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : api_key client_config : protocol : https host : <domain> authentication : strategy : bearer configuration : token : <api_key> test_request : method : GET path : /v3/marketing/contacts endpoints : - name : contacts requests : read : method : POST path : /v3/marketing/contacts/search body : | { \"query\": \"email = '<email>'\" } param_values : - name : email identity : email data_path : result delete : method : DELETE path : /v3/marketing/contacts?ids=<contact_id> param_values : - name : contact_id references : - dataset : sendgrid_connector_example field : contacts.id direction : from","title":"Example Sendgrid Configuration"},{"location":"saas_connectors/example_configs/sentry/","text":"Sentry Implementation Summary Fidesops uses the following Sentry endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Organizations Yes No Users Yes No Projects Yes Yes Issues Yes No User Feedback Yes No Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Sentry Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 saas_config : fides_key : sentry_connector name : Sentry SaaS Config description : A sample schema representing the Sentry connector for fidesops version : 0.0.1 connector_params : - name : host - name : access_token client_config : protocol : https host : connector_param : host authentication : strategy : bearer_authentication configuration : token : connector_param : access_token test_request : method : GET path : /api/0/organizations/ endpoints : - name : organizations requests : read : method : GET path : /api/0/organizations/ param_values : - name : placeholder identity : email pagination : strategy : link configuration : source : headers rel : next - name : employees requests : read : method : GET path : /api/0/organizations/<organization_slug>/users/ param_values : - name : organization_slug references : - dataset : sentry_connector field : organizations.slug direction : from postprocessors : - strategy : filter configuration : field : email value : identity : email - name : projects requests : read : method : GET path : /api/0/projects/ param_values : - name : placeholder identity : email pagination : strategy : link configuration : source : headers rel : next - name : issues requests : update : method : PUT path : /api/0/issues/<issue_id>/ headers : - name : Content-Type value : application/json param_values : - name : issue_id references : - dataset : sentry_connector field : issues.id direction : from body : '{\"assignedTo\": \"\"}' read : method : GET path : /api/0/projects/<organization_slug>/<project_slug>/issues/ grouped_inputs : [ organization_slug , project_slug , query ] query_params : - name : query value : assigned:<query> param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from - name : query identity : email pagination : strategy : link configuration : source : headers rel : next - name : user_feedback requests : read : method : GET path : /api/0/projects/<organization_slug>/<project_slug>/user-feedback/ grouped_inputs : [ organization_slug , project_slug ] param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from postprocessors : - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : headers rel : next - name : person after : [ sentry_connector.projects ] requests : read : method : GET ignore_errors : true path : /api/0/projects/<organization_slug>/<project_slug>/users/ grouped_inputs : [ organization_slug , project_slug , query ] query_params : - name : query value : email:<query> param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from - name : query identity : email pagination : strategy : link configuration : source : headers rel : next","title":"Sentry"},{"location":"saas_connectors/example_configs/sentry/#sentry","text":"","title":"Sentry"},{"location":"saas_connectors/example_configs/sentry/#implementation-summary","text":"Fidesops uses the following Sentry endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Organizations Yes No Users Yes No Projects Yes Yes Issues Yes No User Feedback Yes No","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/sentry/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/sentry/#example-sentry-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 saas_config : fides_key : sentry_connector name : Sentry SaaS Config description : A sample schema representing the Sentry connector for fidesops version : 0.0.1 connector_params : - name : host - name : access_token client_config : protocol : https host : connector_param : host authentication : strategy : bearer_authentication configuration : token : connector_param : access_token test_request : method : GET path : /api/0/organizations/ endpoints : - name : organizations requests : read : method : GET path : /api/0/organizations/ param_values : - name : placeholder identity : email pagination : strategy : link configuration : source : headers rel : next - name : employees requests : read : method : GET path : /api/0/organizations/<organization_slug>/users/ param_values : - name : organization_slug references : - dataset : sentry_connector field : organizations.slug direction : from postprocessors : - strategy : filter configuration : field : email value : identity : email - name : projects requests : read : method : GET path : /api/0/projects/ param_values : - name : placeholder identity : email pagination : strategy : link configuration : source : headers rel : next - name : issues requests : update : method : PUT path : /api/0/issues/<issue_id>/ headers : - name : Content-Type value : application/json param_values : - name : issue_id references : - dataset : sentry_connector field : issues.id direction : from body : '{\"assignedTo\": \"\"}' read : method : GET path : /api/0/projects/<organization_slug>/<project_slug>/issues/ grouped_inputs : [ organization_slug , project_slug , query ] query_params : - name : query value : assigned:<query> param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from - name : query identity : email pagination : strategy : link configuration : source : headers rel : next - name : user_feedback requests : read : method : GET path : /api/0/projects/<organization_slug>/<project_slug>/user-feedback/ grouped_inputs : [ organization_slug , project_slug ] param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from postprocessors : - strategy : filter configuration : field : email value : identity : email pagination : strategy : link configuration : source : headers rel : next - name : person after : [ sentry_connector.projects ] requests : read : method : GET ignore_errors : true path : /api/0/projects/<organization_slug>/<project_slug>/users/ grouped_inputs : [ organization_slug , project_slug , query ] query_params : - name : query value : email:<query> param_values : - name : organization_slug references : - dataset : sentry_connector field : projects.organization.slug direction : from - name : project_slug references : - dataset : sentry_connector field : projects.slug direction : from - name : query identity : email pagination : strategy : link configuration : source : headers rel : next","title":"Example Sentry Configuration"},{"location":"saas_connectors/example_configs/stripe/","text":"Stripe Implementation Summary Fidesops uses the following Stripe endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Customers Yes Yes Charges Yes No Disputes Yes No Payment Intents Yes Yes Payment Methods Yes No Bank Accounts Yes Yes Cards Yes Yes Credit Notes Yes No Customer Balance Transactions Yes No Tax IDs Yes Yes Invoices Yes Yes Invoice Items Yes Yes Subscriptions Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Stripe Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 saas_config : fides_key : stripe_connector_example name : Stripe SaaS Config description : A sample schema representing the Stripe connector for fidesops version : 0.0.1 connector_params : - name : host - name : api_key - name : payment_types - name : items_per_page client_config : protocol : https host : connector_param : host authentication : strategy : bearer_authentication configuration : token : connector_param : api_key test_request : method : GET path : /v1/customers endpoints : - name : customer requests : read : method : GET path : /v1/customers query_params : - name : email value : <email> param_values : - name : email identity : email data_path : data update : method : POST path : /v1/customers/<customer_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from body : '{<all_object_fields>}' - name : charge requests : read : method : GET path : /v1/charges query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : dispute requests : read : method : GET path : /v1/disputes query_params : - name : charge value : <charge_id> - name : payment_intent value : <payment_intent_id> - name : limit value : <limit> param_values : - name : charge_id references : - dataset : stripe_connector_example field : charge.id direction : from - name : payment_intent_id references : - dataset : stripe_connector_example field : payment_intent.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : payment_intent requests : read : method : GET path : /v1/payment_intents query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : payment_method requests : read : method : GET path : /v1/customers/<customer_id>/payment_methods query_params : - name : type value : <type> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : type connector_param : payment_types - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/payment_methods/<payment_method_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : payment_method_id references : - dataset : stripe_connector_example field : payment_method.id direction : from body : '{<masked_object_fields>}' - name : bank_account requests : read : method : GET path : /v1/customers/<customer_id>/sources query_params : - name : object value : bank_account - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/customers/<customer_id>/sources/<bank_account_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : bank_account.customer direction : from - name : bank_account_id references : - dataset : stripe_connector_example field : bank_account.id direction : from body : '{<masked_object_fields>}' - name : card requests : read : method : GET path : /v1/customers/<customer_id>/sources query_params : - name : object value : card - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/customers/<customer_id>/sources/<card_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : card.customer direction : from - name : card_id references : - dataset : stripe_connector_example field : card.id direction : from body : '{<masked_object_fields>}' - name : credit_note requests : read : method : GET path : /v1/credit_notes query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : customer_balance_transaction requests : read : method : GET path : /v1/customers/<customer_id>/balance_transactions query_params : - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : tax_id requests : read : method : GET path : /v1/customers/<customer_id>/tax_ids query_params : - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE path : /v1/customers/<customer_id>/tax_ids/<tax_id> param_values : - name : customer_id references : - dataset : stripe_connector_example field : tax_id.customer direction : from - name : tax_id references : - dataset : stripe_connector_example field : tax_id.id direction : from - name : invoice requests : read : method : GET path : /v1/invoices query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE ignore_errors : true # You can only delete draft invoices. You can't delete invoices created by subscriptions. path : /v1/invoices/<invoice_id> param_values : - name : invoice_id references : - dataset : stripe_connector_example field : invoice.id direction : from - name : invoice_item requests : read : method : GET path : /v1/invoiceitems query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE ignore_errors : true # Can't delete an invoice item that is attached to an invoice that is no longer editable path : /v1/invoiceitems/<invoice_item_id> param_values : - name : invoice_item_id references : - dataset : stripe_connector_example field : invoice_item.id direction : from - name : subscription requests : read : method : GET path : /v1/subscriptions query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE path : /v1/subscriptions/<subscription_id> param_values : - name : subscription_id references : - dataset : stripe_connector_example field : subscription.id direction : from","title":"Stripe"},{"location":"saas_connectors/example_configs/stripe/#stripe","text":"","title":"Stripe"},{"location":"saas_connectors/example_configs/stripe/#implementation-summary","text":"Fidesops uses the following Stripe endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Customers Yes Yes Charges Yes No Disputes Yes No Payment Intents Yes Yes Payment Methods Yes No Bank Accounts Yes Yes Cards Yes Yes Credit Notes Yes No Customer Balance Transactions Yes No Tax IDs Yes Yes Invoices Yes Yes Invoice Items Yes Yes Subscriptions Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/stripe/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/stripe/#example-stripe-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 saas_config : fides_key : stripe_connector_example name : Stripe SaaS Config description : A sample schema representing the Stripe connector for fidesops version : 0.0.1 connector_params : - name : host - name : api_key - name : payment_types - name : items_per_page client_config : protocol : https host : connector_param : host authentication : strategy : bearer_authentication configuration : token : connector_param : api_key test_request : method : GET path : /v1/customers endpoints : - name : customer requests : read : method : GET path : /v1/customers query_params : - name : email value : <email> param_values : - name : email identity : email data_path : data update : method : POST path : /v1/customers/<customer_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from body : '{<all_object_fields>}' - name : charge requests : read : method : GET path : /v1/charges query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : dispute requests : read : method : GET path : /v1/disputes query_params : - name : charge value : <charge_id> - name : payment_intent value : <payment_intent_id> - name : limit value : <limit> param_values : - name : charge_id references : - dataset : stripe_connector_example field : charge.id direction : from - name : payment_intent_id references : - dataset : stripe_connector_example field : payment_intent.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : payment_intent requests : read : method : GET path : /v1/payment_intents query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : payment_method requests : read : method : GET path : /v1/customers/<customer_id>/payment_methods query_params : - name : type value : <type> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : type connector_param : payment_types - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/payment_methods/<payment_method_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : payment_method_id references : - dataset : stripe_connector_example field : payment_method.id direction : from body : '{<masked_object_fields>}' - name : bank_account requests : read : method : GET path : /v1/customers/<customer_id>/sources query_params : - name : object value : bank_account - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/customers/<customer_id>/sources/<bank_account_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : bank_account.customer direction : from - name : bank_account_id references : - dataset : stripe_connector_example field : bank_account.id direction : from body : '{<masked_object_fields>}' - name : card requests : read : method : GET path : /v1/customers/<customer_id>/sources query_params : - name : object value : card - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id update : method : POST path : /v1/customers/<customer_id>/sources/<card_id> headers : - name : Content-Type value : application/x-www-form-urlencoded param_values : - name : customer_id references : - dataset : stripe_connector_example field : card.customer direction : from - name : card_id references : - dataset : stripe_connector_example field : card.id direction : from body : '{<masked_object_fields>}' - name : credit_note requests : read : method : GET path : /v1/credit_notes query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : customer_balance_transaction requests : read : method : GET path : /v1/customers/<customer_id>/balance_transactions query_params : - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id - name : tax_id requests : read : method : GET path : /v1/customers/<customer_id>/tax_ids query_params : - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE path : /v1/customers/<customer_id>/tax_ids/<tax_id> param_values : - name : customer_id references : - dataset : stripe_connector_example field : tax_id.customer direction : from - name : tax_id references : - dataset : stripe_connector_example field : tax_id.id direction : from - name : invoice requests : read : method : GET path : /v1/invoices query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE ignore_errors : true # You can only delete draft invoices. You can't delete invoices created by subscriptions. path : /v1/invoices/<invoice_id> param_values : - name : invoice_id references : - dataset : stripe_connector_example field : invoice.id direction : from - name : invoice_item requests : read : method : GET path : /v1/invoiceitems query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE ignore_errors : true # Can't delete an invoice item that is attached to an invoice that is no longer editable path : /v1/invoiceitems/<invoice_item_id> param_values : - name : invoice_item_id references : - dataset : stripe_connector_example field : invoice_item.id direction : from - name : subscription requests : read : method : GET path : /v1/subscriptions query_params : - name : customer value : <customer_id> - name : limit value : <limit> param_values : - name : customer_id references : - dataset : stripe_connector_example field : customer.id direction : from - name : limit connector_param : items_per_page data_path : data pagination : strategy : cursor configuration : cursor_param : starting_after field : id delete : method : DELETE path : /v1/subscriptions/<subscription_id> param_values : - name : subscription_id references : - dataset : stripe_connector_example field : subscription.id direction : from","title":"Example Stripe Configuration"},{"location":"saas_connectors/example_configs/zendesk/","text":"Zendesk Implementation Summary Fidesops uses the following Zendesk endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Search Yes No Identities Yes No Tickets Yes Yes Ticket Comments Yes Yes Connection Settings Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false . Example Zendesk Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 saas_config : fides_key : zendesk_connector_example name : Zendesk SaaS Config type : zendesk description : A sample schema representing the Zendesk connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key - name : page_size client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /api/v2/users/search.json query_params : - name : query value : test@ethyca endpoints : - name : users requests : read : method : GET path : /api/v2/users/search.json query_params : - name : query value : <email> param_values : - name : email identity : email data_path : users delete : method : DELETE path : /api/v2/users/<user_id>.json param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : user_identities requests : read : method : GET path : /api/v2/users/<user_id>/identities.json query_params : - name : page[size] value : <page_size> param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : page_size connector_param : page_size data_path : identities pagination : strategy : link configuration : source : body path : links.next - name : tickets requests : read : method : GET path : /api/v2/users/<user_id>/tickets/requested.json query_params : - name : page[size] value : <page_size> param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : page_size connector_param : page_size data_path : tickets pagination : strategy : link configuration : source : body path : links.next delete : method : DELETE path : /api/v2/tickets/<ticket_id>.json param_values : - name : ticket_id references : - dataset : zendesk_connector_example field : tickets.id direction : from - name : ticket_comments requests : read : method : GET path : /api/v2/tickets/<ticket_id>/comments.json query_params : - name : page[size] value : <page_size> param_values : - name : ticket_id references : - dataset : zendesk_connector_example field : tickets.id direction : from - name : page_size connector_param : page_size data_path : comments pagination : strategy : link configuration : source : body path : links.next","title":"Zendesk"},{"location":"saas_connectors/example_configs/zendesk/#zendesk","text":"","title":"Zendesk"},{"location":"saas_connectors/example_configs/zendesk/#implementation-summary","text":"Fidesops uses the following Zendesk endpoints to retrieve and delete Personally Identifiable Information (PII) when processing a Data Subject Request (DSR). Right to Access and Right to Delete (Right to Forget) support for each endpoint is noted below. Endpoint Right to Access Right to Delete Search Yes No Identities Yes No Tickets Yes Yes Ticket Comments Yes Yes","title":"Implementation Summary"},{"location":"saas_connectors/example_configs/zendesk/#connection-settings","text":"Fidesops provides a Postman collection for easily establishing connections to your third party applications. Additional connection instructions may be found in the configuration guide . Deletion requests are fulfilled by masking PII via UPDATE endpoints. To give fidesops permission to remove PII using DELETE endpoints, ensure the masking_strict variable in your fidesops.toml file is set to false .","title":"Connection Settings"},{"location":"saas_connectors/example_configs/zendesk/#example-zendesk-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 saas_config : fides_key : zendesk_connector_example name : Zendesk SaaS Config type : zendesk description : A sample schema representing the Zendesk connector for Fidesops version : 0.0.1 connector_params : - name : domain - name : username - name : api_key - name : page_size client_config : protocol : https host : <domain> authentication : strategy : basic configuration : username : <username> password : <api_key> test_request : method : GET path : /api/v2/users/search.json query_params : - name : query value : test@ethyca endpoints : - name : users requests : read : method : GET path : /api/v2/users/search.json query_params : - name : query value : <email> param_values : - name : email identity : email data_path : users delete : method : DELETE path : /api/v2/users/<user_id>.json param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : user_identities requests : read : method : GET path : /api/v2/users/<user_id>/identities.json query_params : - name : page[size] value : <page_size> param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : page_size connector_param : page_size data_path : identities pagination : strategy : link configuration : source : body path : links.next - name : tickets requests : read : method : GET path : /api/v2/users/<user_id>/tickets/requested.json query_params : - name : page[size] value : <page_size> param_values : - name : user_id references : - dataset : zendesk_connector_example field : users.id direction : from - name : page_size connector_param : page_size data_path : tickets pagination : strategy : link configuration : source : body path : links.next delete : method : DELETE path : /api/v2/tickets/<ticket_id>.json param_values : - name : ticket_id references : - dataset : zendesk_connector_example field : tickets.id direction : from - name : ticket_comments requests : read : method : GET path : /api/v2/tickets/<ticket_id>/comments.json query_params : - name : page[size] value : <page_size> param_values : - name : ticket_id references : - dataset : zendesk_connector_example field : tickets.id direction : from - name : page_size connector_param : page_size data_path : comments pagination : strategy : link configuration : source : body path : links.next","title":"Example Zendesk Configuration"},{"location":"tutorial/","text":"Tutorial Going from Zero to Privacy Request in Ten Minutes In this tutorial, we will be walking through the steps needed to execute a Privacy Request against an application. We will install fidesops in a test app and write a Python script that will make a series of API requests to fidesops to set up the required configuration, like the connection to an app's database, the instructions on how to traverse its tables, and where to upload any data it finds. Finally, we'll execute an access request to fetch all the data that our test application has collected about a customer.","title":"Zero to Privacy Request"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#going-from-zero-to-privacy-request-in-ten-minutes","text":"In this tutorial, we will be walking through the steps needed to execute a Privacy Request against an application. We will install fidesops in a test app and write a Python script that will make a series of API requests to fidesops to set up the required configuration, like the connection to an app's database, the instructions on how to traverse its tables, and where to upload any data it finds. Finally, we'll execute an access request to fetch all the data that our test application has collected about a customer.","title":"Going from Zero to Privacy Request in Ten Minutes"},{"location":"tutorial/annotate_datasets/","text":"Create DatasetConfigs Annotate Datasets with fidesops_meta Next, fidesops needs to know how to traverse through our Flask App's database tables. For more detailed information, see the Datasets Guide . We should upload a YAML file that describes our Flask App's database in a language that Fides understands. See fidesdemo/fides_resources/flaskr_postgres_dataset.yml where we've already annotated the tables and fields in our Postgres database with the relevant Data Categories. We just need a few more annotations: Add a fidesops_meta attribute to flaskr_postgres_dataset.collections.seller_id . Fidesops will be able to take the users id and use that to look up the seller_id . 1 2 3 4 5 6 7 8 - name : seller_id data_categories : [ user.unique_id ] fidesops_meta : data_type : integer references : - dataset : flaskr_postgres_dataset field : users.id direction : from Similarly, add a fidesops_meta attribute to flaskr_postgres_dataset.purchases.buyer_id . Fidesops will be able to take the user id and use that to look up purchases by buyer_id . 1 2 3 4 5 6 7 8 - name : buyer_id data_categories : [ user.unique_id ] fidesops_meta : data_type : integer references : - dataset : flaskr_postgres_dataset field : users.id direction : from Lastly, annotate flaskr_postgres_dataset.users.email field. This is our entry point: fidesops will first look up the user by email , and from there, travel through other tables linked to user . 1 2 3 4 5 - name : email data_categories : [ user.contact.email ] fidesops_meta : data_type : string identity : email Upload this Dataset to fidesops We need to create a method that takes the Dataset we've just annotated and upload it to fidesops: Define a helper method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_dataset ( connection_key , yaml_path , access_token ): \"\"\" Create a Dataset in fidesops given a YAML manifest file. Requires the `connection_key` for the PostgreSQL connection, and `yaml_path` that is a local filepath to a .yml Dataset Fides manifest file. Returns the response JSON if successful, or throws an error otherwise. \"\"\" with open ( yaml_path , \"r\" ) as file : dataset = yaml . safe_load ( file ) . get ( \"dataset\" , [])[ 0 ] dataset_create_data = [ dataset ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/connection/ { connection_key } /dataset\" , headers = oauth_headers ( access_token = access_token ), json = dataset_create_data , ) logger . info ( \"Creating an annotated Dataset. Status %s \" , response . status_code ) return response . json () Call the helper method to create a dataset Our connection_key is the flaskr_postgres ConnectionConfig we created in the previous step, and we're also passing in our completed YAML file: 1 2 3 4 5 6 7 8 9 if __name__ == \"__main__\" : ... # Upload the Dataset YAML for our PostgreSQL schema datasets = create_dataset ( connection_key = \"flaskr_postgres\" , yaml_path = \"fides_resources/flaskr_postgres_dataset.yml\" , access_token = access_token , ) ...","title":"Annotate a Database"},{"location":"tutorial/annotate_datasets/#create-datasetconfigs","text":"","title":"Create DatasetConfigs"},{"location":"tutorial/annotate_datasets/#annotate-datasets-with-fidesops_meta","text":"Next, fidesops needs to know how to traverse through our Flask App's database tables. For more detailed information, see the Datasets Guide . We should upload a YAML file that describes our Flask App's database in a language that Fides understands. See fidesdemo/fides_resources/flaskr_postgres_dataset.yml where we've already annotated the tables and fields in our Postgres database with the relevant Data Categories. We just need a few more annotations: Add a fidesops_meta attribute to flaskr_postgres_dataset.collections.seller_id . Fidesops will be able to take the users id and use that to look up the seller_id . 1 2 3 4 5 6 7 8 - name : seller_id data_categories : [ user.unique_id ] fidesops_meta : data_type : integer references : - dataset : flaskr_postgres_dataset field : users.id direction : from Similarly, add a fidesops_meta attribute to flaskr_postgres_dataset.purchases.buyer_id . Fidesops will be able to take the user id and use that to look up purchases by buyer_id . 1 2 3 4 5 6 7 8 - name : buyer_id data_categories : [ user.unique_id ] fidesops_meta : data_type : integer references : - dataset : flaskr_postgres_dataset field : users.id direction : from Lastly, annotate flaskr_postgres_dataset.users.email field. This is our entry point: fidesops will first look up the user by email , and from there, travel through other tables linked to user . 1 2 3 4 5 - name : email data_categories : [ user.contact.email ] fidesops_meta : data_type : string identity : email","title":"Annotate Datasets with fidesops_meta"},{"location":"tutorial/annotate_datasets/#upload-this-dataset-to-fidesops","text":"We need to create a method that takes the Dataset we've just annotated and upload it to fidesops:","title":"Upload this Dataset to fidesops"},{"location":"tutorial/annotate_datasets/#define-a-helper-method","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_dataset ( connection_key , yaml_path , access_token ): \"\"\" Create a Dataset in fidesops given a YAML manifest file. Requires the `connection_key` for the PostgreSQL connection, and `yaml_path` that is a local filepath to a .yml Dataset Fides manifest file. Returns the response JSON if successful, or throws an error otherwise. \"\"\" with open ( yaml_path , \"r\" ) as file : dataset = yaml . safe_load ( file ) . get ( \"dataset\" , [])[ 0 ] dataset_create_data = [ dataset ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/connection/ { connection_key } /dataset\" , headers = oauth_headers ( access_token = access_token ), json = dataset_create_data , ) logger . info ( \"Creating an annotated Dataset. Status %s \" , response . status_code ) return response . json ()","title":"Define a helper method"},{"location":"tutorial/annotate_datasets/#call-the-helper-method-to-create-a-dataset","text":"Our connection_key is the flaskr_postgres ConnectionConfig we created in the previous step, and we're also passing in our completed YAML file: 1 2 3 4 5 6 7 8 9 if __name__ == \"__main__\" : ... # Upload the Dataset YAML for our PostgreSQL schema datasets = create_dataset ( connection_key = \"flaskr_postgres\" , yaml_path = \"fides_resources/flaskr_postgres_dataset.yml\" , access_token = access_token , ) ...","title":"Call the helper method to create a dataset"},{"location":"tutorial/define_policy/","text":"Define Policies Creating a Policy with Rules and Targets We're almost there: we need to create a Policy to describe how to handle a Privacy Request. Very detailed configurations are supported to define how different data is treated. You can create Policies with multiple Rules (how the data is handled), that each have Rule Targets (what data we care about). Below are methods to add a Policy, a Rule, and a Rule Target, plus a cleanup method that deletes Rules for convenience (handy if you'll be running this script multiple times). For more detailed information, see the Policy Guide . Define helper methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def create_policy ( key , access_token ): \"\"\" Create a request policy in fidesops with the given key.Returns the response JSON if successful, or throws an error otherwise. \"\"\" policy_create_data = [ { \"name\" : key , \"key\" : key , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy\" , headers = oauth_headers ( access_token = access_token ), json = policy_create_data , ) logger . info ( \"Creating a Policy. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def create_policy_rule ( policy_key , key , action_type , storage_destination_key , access_token ): \"\"\" Create a Policy Rule to return matched data in an access request to the given Storage destination. Returns the response JSON if successful, or throws an error otherwise. \"\"\" rule_create_data = [ { \"name\" : key , \"key\" : key , \"action_type\" : action_type , \"storage_destination_key\" : storage_destination_key , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule\" , headers = oauth_headers ( access_token = access_token ), json = rule_create_data , ) logger . info ( \"Creating a rule. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_policy_rule_target ( policy_key , rule_key , data_category , access_token ): \"\"\" Create a Policy Rule Target that matches the given data_category. Returns the response JSON if successful, or throws an error otherwise. \"\"\" target_create_data = [ { \"data_category\" : data_category , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule/ { rule_key } /target\" , headers = oauth_headers ( access_token = access_token ), json = target_create_data , ) logger . info ( \"Creating a Rule Target. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 def delete_policy_rule ( policy_key , key , access_token ): \"\"\" Deletes a Policy rule with the given key. Returns the response JSON. \"\"\" return requests . delete ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule/ { key } \" , headers = oauth_headers ( access_token = access_token ), ) Call helper methods to create the Policy For simplicity's sake, let's just create one Policy, one Rule, and one Target. Our single Policy will have one Rule with type access , meaning we just want to retrieve user data, not delete it. We also configure on the Rule that any results will be uploaded to our local Storage example_storage . Finally, we create a RuleTarget, that is looking for all data with the category user (and included subcategories). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if __name__ == \"__main__\" : ... # Create a Policy that returns all user data policy = create_policy ( key = \"example_request_policy\" , access_token = access_token , ) delete_policy_rule ( \"example_request_policy\" , \"access_user_data\" , access_token ) create_policy_rule ( policy_key = \"example_request_policy\" , key = \"access_user_data\" , action_type = \"access\" , storage_destination_key = \"example_storage\" , access_token = access_token , ) data_category = \"user\" create_policy_rule_target ( \"example_request_policy\" , \"access_user_data\" , data_category , access_token ) If you look back at our annotated YAML fides_resources/flaskr_postgres_dataset.yml , we can see the relevant fields associated with this Data Category that we will expect in our final upload package: products collection: description , name , and price user collection: email , first_name , last_name , and password purchases collection: city , state , street_1 , street_2 , and zip","title":"Define a Policy"},{"location":"tutorial/define_policy/#define-policies","text":"","title":"Define Policies"},{"location":"tutorial/define_policy/#creating-a-policy-with-rules-and-targets","text":"We're almost there: we need to create a Policy to describe how to handle a Privacy Request. Very detailed configurations are supported to define how different data is treated. You can create Policies with multiple Rules (how the data is handled), that each have Rule Targets (what data we care about). Below are methods to add a Policy, a Rule, and a Rule Target, plus a cleanup method that deletes Rules for convenience (handy if you'll be running this script multiple times). For more detailed information, see the Policy Guide .","title":"Creating a Policy with Rules and Targets"},{"location":"tutorial/define_policy/#define-helper-methods","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def create_policy ( key , access_token ): \"\"\" Create a request policy in fidesops with the given key.Returns the response JSON if successful, or throws an error otherwise. \"\"\" policy_create_data = [ { \"name\" : key , \"key\" : key , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy\" , headers = oauth_headers ( access_token = access_token ), json = policy_create_data , ) logger . info ( \"Creating a Policy. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def create_policy_rule ( policy_key , key , action_type , storage_destination_key , access_token ): \"\"\" Create a Policy Rule to return matched data in an access request to the given Storage destination. Returns the response JSON if successful, or throws an error otherwise. \"\"\" rule_create_data = [ { \"name\" : key , \"key\" : key , \"action_type\" : action_type , \"storage_destination_key\" : storage_destination_key , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule\" , headers = oauth_headers ( access_token = access_token ), json = rule_create_data , ) logger . info ( \"Creating a rule. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_policy_rule_target ( policy_key , rule_key , data_category , access_token ): \"\"\" Create a Policy Rule Target that matches the given data_category. Returns the response JSON if successful, or throws an error otherwise. \"\"\" target_create_data = [ { \"data_category\" : data_category , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule/ { rule_key } /target\" , headers = oauth_headers ( access_token = access_token ), json = target_create_data , ) logger . info ( \"Creating a Rule Target. Status %s \" , response . status_code ) return response . json () 1 2 3 4 5 6 7 8 9 def delete_policy_rule ( policy_key , key , access_token ): \"\"\" Deletes a Policy rule with the given key. Returns the response JSON. \"\"\" return requests . delete ( f \" { FIDESOPS_URL } /api/v1/policy/ { policy_key } /rule/ { key } \" , headers = oauth_headers ( access_token = access_token ), )","title":"Define helper methods"},{"location":"tutorial/define_policy/#call-helper-methods-to-create-the-policy","text":"For simplicity's sake, let's just create one Policy, one Rule, and one Target. Our single Policy will have one Rule with type access , meaning we just want to retrieve user data, not delete it. We also configure on the Rule that any results will be uploaded to our local Storage example_storage . Finally, we create a RuleTarget, that is looking for all data with the category user (and included subcategories). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if __name__ == \"__main__\" : ... # Create a Policy that returns all user data policy = create_policy ( key = \"example_request_policy\" , access_token = access_token , ) delete_policy_rule ( \"example_request_policy\" , \"access_user_data\" , access_token ) create_policy_rule ( policy_key = \"example_request_policy\" , key = \"access_user_data\" , action_type = \"access\" , storage_destination_key = \"example_storage\" , access_token = access_token , ) data_category = \"user\" create_policy_rule_target ( \"example_request_policy\" , \"access_user_data\" , data_category , access_token ) If you look back at our annotated YAML fides_resources/flaskr_postgres_dataset.yml , we can see the relevant fields associated with this Data Category that we will expect in our final upload package: products collection: description , name , and price user collection: email , first_name , last_name , and password purchases collection: city , state , street_1 , street_2 , and zip","title":"Call helper methods to create the Policy"},{"location":"tutorial/execute_privacy_request/","text":"Execute a Privacy Request See a Privacy Request in Action To summarize so far, we have: Created a client for authentication Created a connection from fidesops to our Flask App's Postgres Database Uploaded an annotated Dataset to fidesops so it knows how to traverse through the Flask App's tables Defined where to upload our user data after we've retrieved it from the Flask App Defined Policies describing what data we're looking for and what to do with that data. For our last step, we'll write a method that will let us create a Privacy Request. We need to specify the Policy we want applied to that Privacy Request, as well as the starting identity of the user we'll need to locate the remaining user information. For more detailed information, see the Privacy Request Guide . Define a helper method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def create_privacy_request ( email , policy_key ): \"\"\" Create a Privacy Request that is executed against the given request Policy. Returns the response JSON if successful, or throws an error otherwise. \"\"\" privacy_request_data = [ { \"requested_at\" : datetime ( 2021 , 1 , 1 ) . isoformat (), \"policy_key\" : policy_key , \"identity\" : { \"email\" : email }, }, ] response = requests . post ( f \" { FIDESOPS_URL } /api/v1/privacy-request\" , json = privacy_request_data , ) logger . info ( \"Executing a Privacy Request. Status %s \" , response . status_code ) logger . info ( \"Check fidesdemo/fides_uploads for upload package.\" ) return response . json () Call the helper method to run the Privacy Request This will create a request to fetch for all user data with category user associated with email user@example.com and save it to our local Storage destination, by specifying the email and the Policy. 1 2 3 4 5 6 7 8 9 ... if __name__ == \"__main__\" : ... # Execute a Privacy Request for user@example.com email = \"user@example.com\" privacy_requests = create_privacy_request ( email = email , policy_key = \"example_request_policy\" , ) Execute the Privacy Request In your terminal, within the fidesdemo directory, we'll run our script to execute the Privacy Request: 1 python3 flaskr/fidesops.py Success statuses 1 2 3 4 5 6 7 8 9 10 11 12 13 INFO:__main__:Creating access token. Status 200 INFO:__main__:Creating Oauth Client. Status 200 INFO:__main__:Adding scopes to oauth client. Status 200 INFO:__main__:Creating access token. Status 200 INFO:__main__:Creating PostgreSQL ConnectionConfig. Status 200 INFO:__main__:Updating PostgreSQL Secrets. Status 200 . INFO:__main__:Defining an upload location. Status 200 INFO:__main__:Creating an annotated Dataset. Status 200 INFO:__main__:Creating a Policy. Status 200 INFO:__main__:Creating a Rule. Status 200 INFO:__main__:Creating a Rule Target. Status 200 INFO:__main__:Executing a Privacy Request. Status 200 INFO:__main__:Check fidesdemo/fidesuploads for upload package. Check your fidesdemo/fides_uploads directory for your data package (you may have to wait a few moments for the file to appear): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"flaskr_postgres_dataset:products\" : [ { \"description\" : \"A description for example product #3\" , \"name\" : \"Example Product 3\" , \"price\" : 50 } ], \"flaskr_postgres_dataset:purchases\" : [ { \"city\" : \"Exampletown\" , \"state\" : \"NY\" , \"street_1\" : \"123 Example St\" , \"street_2\" : \"Apt 123\" , \"zip\" : \"12345\" } ], \"flaskr_postgres_dataset:users\" : [ { \"email\" : \"user@example.com\" , \"first_name\" : \"Example\" , \"last_name\" : \"User\" , \"password\" : \"pbkdf2:sha256:260000$PGcBy5NzZeDdlu0b$a91ee29eefad98920fe47a6ef4d53b5abffe593300f766f02de041af93ae51f8\" } ] } Issues? Is nox -s dev running? Reference the full script here for pieces you may be missing. This script has more detailed logging and error handling. Make sure your dataset is annotated properly Add breakpoints by inserting import pdb; pdb.set_trace() into the line where you want the breakpoint to set, then run your script. Many of the endpoints used here are Bulk endpoints that return a 200 and then a mixture of a succeeded/failed resources. Check the docker logs: 1 docker ps 1 2 3 4 5 6 Name Command State Ports ------------------------------------------------------------------------------------------------------------------ fidesdemo_db_1 docker-entrypoint.sh postgres Up 0 .0.0.0:5432->5432/tcp,:::5432->5432/tcp fidesdemo_fidesctl_1 fidesctl webserver Up 0 .0.0.0:8080->8080/tcp,:::8080->8080/tcp fidesdemo_fidesops_1 fidesops webserver Up 8000 /tcp, 0 .0.0.0:8000->8080/tcp,:::8000->8080/tcp fidesdemo_redis_1 docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp,:::6379->6379/tcp 1 docker logs fidesdemo_fidesops_1","title":"Execute a Privacy Request"},{"location":"tutorial/execute_privacy_request/#execute-a-privacy-request","text":"","title":"Execute a Privacy Request"},{"location":"tutorial/execute_privacy_request/#see-a-privacy-request-in-action","text":"To summarize so far, we have: Created a client for authentication Created a connection from fidesops to our Flask App's Postgres Database Uploaded an annotated Dataset to fidesops so it knows how to traverse through the Flask App's tables Defined where to upload our user data after we've retrieved it from the Flask App Defined Policies describing what data we're looking for and what to do with that data. For our last step, we'll write a method that will let us create a Privacy Request. We need to specify the Policy we want applied to that Privacy Request, as well as the starting identity of the user we'll need to locate the remaining user information. For more detailed information, see the Privacy Request Guide .","title":"See a Privacy Request in Action"},{"location":"tutorial/execute_privacy_request/#define-a-helper-method","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def create_privacy_request ( email , policy_key ): \"\"\" Create a Privacy Request that is executed against the given request Policy. Returns the response JSON if successful, or throws an error otherwise. \"\"\" privacy_request_data = [ { \"requested_at\" : datetime ( 2021 , 1 , 1 ) . isoformat (), \"policy_key\" : policy_key , \"identity\" : { \"email\" : email }, }, ] response = requests . post ( f \" { FIDESOPS_URL } /api/v1/privacy-request\" , json = privacy_request_data , ) logger . info ( \"Executing a Privacy Request. Status %s \" , response . status_code ) logger . info ( \"Check fidesdemo/fides_uploads for upload package.\" ) return response . json ()","title":"Define a helper method"},{"location":"tutorial/execute_privacy_request/#call-the-helper-method-to-run-the-privacy-request","text":"This will create a request to fetch for all user data with category user associated with email user@example.com and save it to our local Storage destination, by specifying the email and the Policy. 1 2 3 4 5 6 7 8 9 ... if __name__ == \"__main__\" : ... # Execute a Privacy Request for user@example.com email = \"user@example.com\" privacy_requests = create_privacy_request ( email = email , policy_key = \"example_request_policy\" , )","title":"Call the helper method to run the Privacy Request"},{"location":"tutorial/execute_privacy_request/#execute-the-privacy-request","text":"In your terminal, within the fidesdemo directory, we'll run our script to execute the Privacy Request: 1 python3 flaskr/fidesops.py Success statuses 1 2 3 4 5 6 7 8 9 10 11 12 13 INFO:__main__:Creating access token. Status 200 INFO:__main__:Creating Oauth Client. Status 200 INFO:__main__:Adding scopes to oauth client. Status 200 INFO:__main__:Creating access token. Status 200 INFO:__main__:Creating PostgreSQL ConnectionConfig. Status 200 INFO:__main__:Updating PostgreSQL Secrets. Status 200 . INFO:__main__:Defining an upload location. Status 200 INFO:__main__:Creating an annotated Dataset. Status 200 INFO:__main__:Creating a Policy. Status 200 INFO:__main__:Creating a Rule. Status 200 INFO:__main__:Creating a Rule Target. Status 200 INFO:__main__:Executing a Privacy Request. Status 200 INFO:__main__:Check fidesdemo/fidesuploads for upload package. Check your fidesdemo/fides_uploads directory for your data package (you may have to wait a few moments for the file to appear): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"flaskr_postgres_dataset:products\" : [ { \"description\" : \"A description for example product #3\" , \"name\" : \"Example Product 3\" , \"price\" : 50 } ], \"flaskr_postgres_dataset:purchases\" : [ { \"city\" : \"Exampletown\" , \"state\" : \"NY\" , \"street_1\" : \"123 Example St\" , \"street_2\" : \"Apt 123\" , \"zip\" : \"12345\" } ], \"flaskr_postgres_dataset:users\" : [ { \"email\" : \"user@example.com\" , \"first_name\" : \"Example\" , \"last_name\" : \"User\" , \"password\" : \"pbkdf2:sha256:260000$PGcBy5NzZeDdlu0b$a91ee29eefad98920fe47a6ef4d53b5abffe593300f766f02de041af93ae51f8\" } ] }","title":"Execute the Privacy Request"},{"location":"tutorial/execute_privacy_request/#issues","text":"Is nox -s dev running? Reference the full script here for pieces you may be missing. This script has more detailed logging and error handling. Make sure your dataset is annotated properly Add breakpoints by inserting import pdb; pdb.set_trace() into the line where you want the breakpoint to set, then run your script. Many of the endpoints used here are Bulk endpoints that return a 200 and then a mixture of a succeeded/failed resources. Check the docker logs: 1 docker ps 1 2 3 4 5 6 Name Command State Ports ------------------------------------------------------------------------------------------------------------------ fidesdemo_db_1 docker-entrypoint.sh postgres Up 0 .0.0.0:5432->5432/tcp,:::5432->5432/tcp fidesdemo_fidesctl_1 fidesctl webserver Up 0 .0.0.0:8080->8080/tcp,:::8080->8080/tcp fidesdemo_fidesops_1 fidesops webserver Up 8000 /tcp, 0 .0.0.0:8000->8080/tcp,:::8000->8080/tcp fidesdemo_redis_1 docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp,:::6379->6379/tcp 1 docker logs fidesdemo_fidesops_1","title":"Issues?"},{"location":"tutorial/installation/","text":"Installation Requirements To run this project, ensure you have the following requirements installed and running on your machine: Docker 12+ Python 3.8+ Make pg_config ( brew install libpq or brew install postgres on Mac) Clone the fidesdemo repo Clone Fides Demo , and run make install to begin setup. Among other things, this will create a Flask app to mimic your application, and provide several YAML files that annotate the Flask app's databases. 1 2 3 4 git clone https://github.com/ethyca/fidesdemo cd fidesdemo make install source venv/bin/activate Next, run make server . You can now visit http://127.0.0.1:2000/ to explore the test app. It is a simple e-commerce marketplace where users can buy and sell products. Similarly you can visit http://127.0.0.1:8080/docs to check that fidesops is up and running and preview the set of API endpoints that are available for us to run requests on fidesops.","title":"Install Fidesops"},{"location":"tutorial/installation/#installation","text":"","title":"Installation"},{"location":"tutorial/installation/#requirements","text":"To run this project, ensure you have the following requirements installed and running on your machine: Docker 12+ Python 3.8+ Make pg_config ( brew install libpq or brew install postgres on Mac)","title":"Requirements"},{"location":"tutorial/installation/#clone-the-fidesdemo-repo","text":"Clone Fides Demo , and run make install to begin setup. Among other things, this will create a Flask app to mimic your application, and provide several YAML files that annotate the Flask app's databases. 1 2 3 4 git clone https://github.com/ethyca/fidesdemo cd fidesdemo make install source venv/bin/activate Next, run make server . You can now visit http://127.0.0.1:2000/ to explore the test app. It is a simple e-commerce marketplace where users can buy and sell products. Similarly you can visit http://127.0.0.1:8080/docs to check that fidesops is up and running and preview the set of API endpoints that are available for us to run requests on fidesops.","title":"Clone the fidesdemo repo"},{"location":"tutorial/oauth_client/","text":"Authentication Creating our Oauth Client Our first step is to create an Oauth Client that we can use to authenticate all of our requests. For more detailed information, see the Oauth Guide . Add a method to our Python script that will call the fidesops API to create a token given a client_id and a client_secret : Define helper methods fidesdemo/flaskr/fidesops.py 1 2 3 4 5 6 7 8 9 10 11 12 def get_access_token ( client_id , client_secret ): \"\"\" Authorize with fidesops via OAuth. Returns a valid access token if successful. \"\"\" data = { \"grant_type\" : \"client_credentials\" , \"client_id\" : client_id , \"client_secret\" : client_secret , } response = requests . post ( f \" { FIDESOPS_URL } /api/v1/oauth/token\" , data = data ) logger . info ( \"Creating access token. Status %s \" , response . status_code ) return response . json ()[ \"access_token\" ] Add another method that will both create a client and assign scopes to that client. It's also useful to define a helper method to build Oauth headers at this point: fidesdemo/flaskr/fidesops.py 1 2 3 def oauth_headers ( access_token ): \"\"\"Return valid authorization headers given the provided OAuth access token\"\"\" return { \"Authorization\" : f \"Bearer { access_token } \" } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def create_oauth_client ( access_token ): \"\"\" Create a new OAuth client in fidesops.Returns the response JSON if successful. \"\"\" # Here we're giving the client many scopes, but in a production app, just give the client the scopes they actually need. scopes_data = [ \"client:create\" , \"client:update\" , \"client:read\" , \"client:delete\" , \"policy:create_or_update\" , \"policy:read\" , \"policy:delete\" , \"connection:create_or_update\" , \"connection:read\" , \"connection:delete\" , \"privacy-request:read\" , \"privacy-request:delete\" , \"rule:create_or_update\" , \"rule:read\" , \"rule:delete\" , \"storage:create_or_update\" , \"storage:read\" , \"storage:delete\" , \"dataset:create_or_update\" , \"dataset:read\" , \"dataset:delete\" , ] response = requests . post ( f \" { FIDESOPS_URL } /api/v1/oauth/client\" , headers = oauth_headers ( access_token ), json = scopes_data ) logger . info ( \"Creating Oauth Client. Status %s \" , response . status_code ) return response . json () Call helper methods to create an Oauth token Update our script to call our new functions to create a token for the root client, and then use that token to create a new client with all the scopes. Finally, we create another token for the new client, and that's what we'll use to authenticate subsequent requests. Do not use the root client for anything other than creating other clients. fidesdemo/flaskr/fidesops.py 1 2 3 4 5 6 7 8 9 10 11 12 13 ... if __name__ == \"__main__\" : # Create a new OAuth client to use for our app root_token = get_access_token ( client_id = ROOT_CLIENT_ID , client_secret = ROOT_CLIENT_SECRET ) client = create_oauth_client ( access_token = root_token ) access_token = get_access_token ( client_id = client [ \"client_id\" ], client_secret = client [ \"client_secret\" ] ) ...","title":"Create an Oauth Client"},{"location":"tutorial/oauth_client/#authentication","text":"","title":"Authentication"},{"location":"tutorial/oauth_client/#creating-our-oauth-client","text":"Our first step is to create an Oauth Client that we can use to authenticate all of our requests. For more detailed information, see the Oauth Guide . Add a method to our Python script that will call the fidesops API to create a token given a client_id and a client_secret :","title":"Creating our Oauth Client"},{"location":"tutorial/oauth_client/#define-helper-methods","text":"fidesdemo/flaskr/fidesops.py 1 2 3 4 5 6 7 8 9 10 11 12 def get_access_token ( client_id , client_secret ): \"\"\" Authorize with fidesops via OAuth. Returns a valid access token if successful. \"\"\" data = { \"grant_type\" : \"client_credentials\" , \"client_id\" : client_id , \"client_secret\" : client_secret , } response = requests . post ( f \" { FIDESOPS_URL } /api/v1/oauth/token\" , data = data ) logger . info ( \"Creating access token. Status %s \" , response . status_code ) return response . json ()[ \"access_token\" ] Add another method that will both create a client and assign scopes to that client. It's also useful to define a helper method to build Oauth headers at this point: fidesdemo/flaskr/fidesops.py 1 2 3 def oauth_headers ( access_token ): \"\"\"Return valid authorization headers given the provided OAuth access token\"\"\" return { \"Authorization\" : f \"Bearer { access_token } \" } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def create_oauth_client ( access_token ): \"\"\" Create a new OAuth client in fidesops.Returns the response JSON if successful. \"\"\" # Here we're giving the client many scopes, but in a production app, just give the client the scopes they actually need. scopes_data = [ \"client:create\" , \"client:update\" , \"client:read\" , \"client:delete\" , \"policy:create_or_update\" , \"policy:read\" , \"policy:delete\" , \"connection:create_or_update\" , \"connection:read\" , \"connection:delete\" , \"privacy-request:read\" , \"privacy-request:delete\" , \"rule:create_or_update\" , \"rule:read\" , \"rule:delete\" , \"storage:create_or_update\" , \"storage:read\" , \"storage:delete\" , \"dataset:create_or_update\" , \"dataset:read\" , \"dataset:delete\" , ] response = requests . post ( f \" { FIDESOPS_URL } /api/v1/oauth/client\" , headers = oauth_headers ( access_token ), json = scopes_data ) logger . info ( \"Creating Oauth Client. Status %s \" , response . status_code ) return response . json ()","title":"Define helper methods"},{"location":"tutorial/oauth_client/#call-helper-methods-to-create-an-oauth-token","text":"Update our script to call our new functions to create a token for the root client, and then use that token to create a new client with all the scopes. Finally, we create another token for the new client, and that's what we'll use to authenticate subsequent requests. Do not use the root client for anything other than creating other clients. fidesdemo/flaskr/fidesops.py 1 2 3 4 5 6 7 8 9 10 11 12 13 ... if __name__ == \"__main__\" : # Create a new OAuth client to use for our app root_token = get_access_token ( client_id = ROOT_CLIENT_ID , client_secret = ROOT_CLIENT_SECRET ) client = create_oauth_client ( access_token = root_token ) access_token = get_access_token ( client_id = client [ \"client_id\" ], client_secret = client [ \"client_secret\" ] ) ...","title":"Call helper methods to create an Oauth token"},{"location":"tutorial/outline/","text":"Outline Let's sketch out a Python file in fidesdemo/flaskr/fidesops.py where we'll add functions that use Python's requests library to call the fidesops API to build our required configuration. As we go through each step in the tutorial, you'll add a couple of helper methods that are wrappers to API calls, and then add calls to these functions at the bottom to be executed when we run this script. Create the file fidesdemo/flaskr/fidesops.py and add the following imports, environment variables, and outline the methods we'll be creating together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import logging import requests import yaml from datetime import datetime logging . basicConfig () logger = logging . getLogger ( __name__ ) logger . setLevel ( logging . INFO ) # For tutorial simplicity. In prod, this should go in an ENV file or similar. FIDESOPS_URL = \"http://localhost:8000\" ROOT_CLIENT_ID = \"fidesopsadmin\" ROOT_CLIENT_SECRET = \"fidesopsadminsecret\" POSTGRES_SERVER = \"db\" POSTGRES_USER = \"postgres\" POSTGRES_PASSWORD = \"postgres\" POSTGRES_PORT = \"5432\" # We'll define some functions here: if __name__ == \"__main__\" : \"\"\"We'll add calls to our functions here\"\"\" # TODO Create a new OAuth client to use for our app # TODO Connect to our PostgreSQL database # TODO Upload the dataset YAML for our PostgreSQL schema # TODO Configure a Storage Config to upload the results # TODO Create a Policy that returns all user data # TODO Execute a Privacy Request for user@example.com","title":"Outline a Python Script"},{"location":"tutorial/outline/#outline","text":"Let's sketch out a Python file in fidesdemo/flaskr/fidesops.py where we'll add functions that use Python's requests library to call the fidesops API to build our required configuration. As we go through each step in the tutorial, you'll add a couple of helper methods that are wrappers to API calls, and then add calls to these functions at the bottom to be executed when we run this script. Create the file fidesdemo/flaskr/fidesops.py and add the following imports, environment variables, and outline the methods we'll be creating together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import logging import requests import yaml from datetime import datetime logging . basicConfig () logger = logging . getLogger ( __name__ ) logger . setLevel ( logging . INFO ) # For tutorial simplicity. In prod, this should go in an ENV file or similar. FIDESOPS_URL = \"http://localhost:8000\" ROOT_CLIENT_ID = \"fidesopsadmin\" ROOT_CLIENT_SECRET = \"fidesopsadminsecret\" POSTGRES_SERVER = \"db\" POSTGRES_USER = \"postgres\" POSTGRES_PASSWORD = \"postgres\" POSTGRES_PORT = \"5432\" # We'll define some functions here: if __name__ == \"__main__\" : \"\"\"We'll add calls to our functions here\"\"\" # TODO Create a new OAuth client to use for our app # TODO Connect to our PostgreSQL database # TODO Upload the dataset YAML for our PostgreSQL schema # TODO Configure a Storage Config to upload the results # TODO Create a Policy that returns all user data # TODO Execute a Privacy Request for user@example.com","title":"Outline"},{"location":"tutorial/postgres_connection/","text":"Connect to the Flask App Database Creating a Postgres ConnectionConfig Next, we need to create a ConnectionConfig so fidesops can connect to our Flask App's database. For more detailed information, see the Database Connectors Guide . Let's add a method that hits the PATCH connection endpoint, and creates a ConnectionConfig for a postgres database: Define helper methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_postgres_connection ( key , access_token ): \"\"\" Create a connection in fidesops for our PostgreSQL database. Returns the response JSON if successful. \"\"\" connection_create_data = [ { \"name\" : key , \"key\" : key , \"connection_type\" : \"postgres\" , \"access\" : \"write\" , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/connection\" , headers = oauth_headers ( access_token = access_token ), json = connection_create_data , ) logger . info ( \"Creating PostgreSQL ConnectionConfig. Status %s \" , response . status_code ) return response . json () Secrets, like a username and password that are needed to access the Flask App's databases, are added separately: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def configure_postgres_connection ( key , host , port , dbname , username , password , access_token ): \"\"\" Configure the connection with the given `key` in fidesops with our PostgreSQL database credentials. Returns the response JSON if successful. \"\"\" connection_secrets_data = { \"host\" : host , \"port\" : port , \"dbname\" : dbname , \"username\" : username , \"password\" : password , } response = requests . put ( f \" { FIDESOPS_URL } /api/v1/connection/ { key } /secret\" , headers = oauth_headers ( access_token = access_token ), json = connection_secrets_data , ) logger . info ( \"Updating PostgreSQL Secrets. Status %s .\" , response . status_code ) return response . json () Call helper methods to connect to Postgres Add calls for our new methods, to create a Postgres ConnectionConfig called flaskr_postgres , and then update that connection's secrets with individual URI components. This will encrypt and save the URI components and also attempt to make a test connection to our Flask App's Postgres Database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if __name__ == \"__main__\" : ... # Connect to our PostgreSQL database create_postgres_connection ( key = \"flaskr_postgres\" , access_token = access_token ) configure_postgres_connection ( key = \"flaskr_postgres\" , host = POSTGRES_SERVER , port = POSTGRES_PORT , dbname = \"flaskr\" , username = POSTGRES_USER , password = POSTGRES_PASSWORD , access_token = access_token , ) ...","title":"Connect to Postgres"},{"location":"tutorial/postgres_connection/#connect-to-the-flask-app-database","text":"","title":"Connect to the Flask App Database"},{"location":"tutorial/postgres_connection/#creating-a-postgres-connectionconfig","text":"Next, we need to create a ConnectionConfig so fidesops can connect to our Flask App's database. For more detailed information, see the Database Connectors Guide . Let's add a method that hits the PATCH connection endpoint, and creates a ConnectionConfig for a postgres database:","title":"Creating a Postgres ConnectionConfig"},{"location":"tutorial/postgres_connection/#define-helper-methods","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def create_postgres_connection ( key , access_token ): \"\"\" Create a connection in fidesops for our PostgreSQL database. Returns the response JSON if successful. \"\"\" connection_create_data = [ { \"name\" : key , \"key\" : key , \"connection_type\" : \"postgres\" , \"access\" : \"write\" , }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/connection\" , headers = oauth_headers ( access_token = access_token ), json = connection_create_data , ) logger . info ( \"Creating PostgreSQL ConnectionConfig. Status %s \" , response . status_code ) return response . json () Secrets, like a username and password that are needed to access the Flask App's databases, are added separately: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def configure_postgres_connection ( key , host , port , dbname , username , password , access_token ): \"\"\" Configure the connection with the given `key` in fidesops with our PostgreSQL database credentials. Returns the response JSON if successful. \"\"\" connection_secrets_data = { \"host\" : host , \"port\" : port , \"dbname\" : dbname , \"username\" : username , \"password\" : password , } response = requests . put ( f \" { FIDESOPS_URL } /api/v1/connection/ { key } /secret\" , headers = oauth_headers ( access_token = access_token ), json = connection_secrets_data , ) logger . info ( \"Updating PostgreSQL Secrets. Status %s .\" , response . status_code ) return response . json ()","title":"Define helper methods"},{"location":"tutorial/postgres_connection/#call-helper-methods-to-connect-to-postgres","text":"Add calls for our new methods, to create a Postgres ConnectionConfig called flaskr_postgres , and then update that connection's secrets with individual URI components. This will encrypt and save the URI components and also attempt to make a test connection to our Flask App's Postgres Database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if __name__ == \"__main__\" : ... # Connect to our PostgreSQL database create_postgres_connection ( key = \"flaskr_postgres\" , access_token = access_token ) configure_postgres_connection ( key = \"flaskr_postgres\" , host = POSTGRES_SERVER , port = POSTGRES_PORT , dbname = \"flaskr\" , username = POSTGRES_USER , password = POSTGRES_PASSWORD , access_token = access_token , ) ...","title":"Call helper methods to connect to Postgres"},{"location":"tutorial/storage_config/","text":"Set up Storage Destination Creating a StorageConfig We need to configure a location to upload the user's PII after fidesops has retrieved it from the Flask App's database. For tutorial purposes, we'll just write to a local file under /fides_uploads , but typically we'd want to upload this to a Storage location like S3. S3 would require a follow-up step to set up AWS access keys and secrets. For more detailed information, see the Storage Config Guide . Define a helper method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def create_local_storage ( key , format , access_token ): \"\"\" Create a StorageConfig in fidesops to write to a local file. Returns the response JSON if successful. \"\"\" storage_create_data = [ { \"name\" : key , \"key\" : key , \"type\" : \"local\" , \"format\" : format , \"details\" : { \"naming\" : \"request_id\" , }, }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/storage/config\" , headers = oauth_headers ( access_token = access_token ), json = storage_create_data , ) logger . info ( \"Defining an upload location. Status %s \" , response . status_code ) return response . json () Call the helper method to set up storage This will define a local Storage location called example_storage that expects JSON data. 1 2 3 4 5 6 7 8 9 if __name__ == \"__main__\" : ... # Configure a Storage Config to upload the results create_local_storage ( key = \"example_storage\" , format = \"json\" , access_token = access_token , ) ...","title":"Configure a Storage Destination"},{"location":"tutorial/storage_config/#set-up-storage-destination","text":"","title":"Set up Storage Destination"},{"location":"tutorial/storage_config/#creating-a-storageconfig","text":"We need to configure a location to upload the user's PII after fidesops has retrieved it from the Flask App's database. For tutorial purposes, we'll just write to a local file under /fides_uploads , but typically we'd want to upload this to a Storage location like S3. S3 would require a follow-up step to set up AWS access keys and secrets. For more detailed information, see the Storage Config Guide .","title":"Creating a StorageConfig"},{"location":"tutorial/storage_config/#define-a-helper-method","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def create_local_storage ( key , format , access_token ): \"\"\" Create a StorageConfig in fidesops to write to a local file. Returns the response JSON if successful. \"\"\" storage_create_data = [ { \"name\" : key , \"key\" : key , \"type\" : \"local\" , \"format\" : format , \"details\" : { \"naming\" : \"request_id\" , }, }, ] response = requests . patch ( f \" { FIDESOPS_URL } /api/v1/storage/config\" , headers = oauth_headers ( access_token = access_token ), json = storage_create_data , ) logger . info ( \"Defining an upload location. Status %s \" , response . status_code ) return response . json ()","title":"Define a helper method"},{"location":"tutorial/storage_config/#call-the-helper-method-to-set-up-storage","text":"This will define a local Storage location called example_storage that expects JSON data. 1 2 3 4 5 6 7 8 9 if __name__ == \"__main__\" : ... # Configure a Storage Config to upload the results create_local_storage ( key = \"example_storage\" , format = \"json\" , access_token = access_token , ) ...","title":"Call the helper method to set up storage"},{"location":"ui/datastores/","text":"Managing Datastores Datastores represent connections to third party applications, databases and datasets, or manual storage locations. Viewing Datastores All currently configured datastores will appear in the paginated Datastore Connections panel. Search options are available to filter the datastore list. Active datastores are included when fulfilling privacy requests. Disabled datastores have their connection information saved, but are not included when privacy requests are executed. Panel Options Option Description Search Retrieve a datastore by name. Datastore Type Filter datastores by type: SaaS, Postgres, Mongo, etc. System Type Filter datastores by system: SaaS, Database, or Manual. Testing Status Filter stores by the result of their last test: Passed, Failed, or Untested. Status Filter datastores by status: Active or Disabled. Testing datastores Each configured datastore includes an option to Test its connection. Fidesops will record the last tested time to the datastore's card, and update the current connection status. Green connections have passed their most recent test. Red connections have failed. Grey connections have not been tested. Disabling and deleting datastores Selecting the three dots menu [...] beside a datastore's connection status will bring up Disable and Delete options for that datastore. Selecting either Disable or Delete will display a warning to confirm the action. Deleted datastores will have their connection information removed entirely from fidesops, while Disabled datastores may be enabled again from the same menu at a later date.","title":"Managing Datastores"},{"location":"ui/datastores/#managing-datastores","text":"Datastores represent connections to third party applications, databases and datasets, or manual storage locations.","title":"Managing Datastores"},{"location":"ui/datastores/#viewing-datastores","text":"All currently configured datastores will appear in the paginated Datastore Connections panel. Search options are available to filter the datastore list. Active datastores are included when fulfilling privacy requests. Disabled datastores have their connection information saved, but are not included when privacy requests are executed.","title":"Viewing Datastores"},{"location":"ui/datastores/#panel-options","text":"Option Description Search Retrieve a datastore by name. Datastore Type Filter datastores by type: SaaS, Postgres, Mongo, etc. System Type Filter datastores by system: SaaS, Database, or Manual. Testing Status Filter stores by the result of their last test: Passed, Failed, or Untested. Status Filter datastores by status: Active or Disabled.","title":"Panel Options"},{"location":"ui/datastores/#testing-datastores","text":"Each configured datastore includes an option to Test its connection. Fidesops will record the last tested time to the datastore's card, and update the current connection status. Green connections have passed their most recent test. Red connections have failed. Grey connections have not been tested.","title":"Testing datastores"},{"location":"ui/datastores/#disabling-and-deleting-datastores","text":"Selecting the three dots menu [...] beside a datastore's connection status will bring up Disable and Delete options for that datastore. Selecting either Disable or Delete will display a warning to confirm the action. Deleted datastores will have their connection information removed entirely from fidesops, while Disabled datastores may be enabled again from the same menu at a later date.","title":"Disabling and deleting datastores"},{"location":"ui/deployment/","text":"Deployment","title":"Deployment"},{"location":"ui/deployment/#deployment","text":"","title":"Deployment"},{"location":"ui/local_dev/","text":"Local Development To test the UI locally, clone the FidesOps repository , and ensure you have Node.js installed to run the application. Creating the root user A root user can be created by adding a root_username and root_password to the security section of fidesops.toml file, or by setting FIDESOPS__SECURITY__ROOT_USERNAME and FIDESOPS__SECURITY__ROOT_PASSWORD environment variables. This will allow you to login in with a root user that can be used to access additional user endpoints . Accessing the Control Panel From the root fidesops directory, run the following: 1 2 3 cd clients/ops/admin-ui npm install npm run dev This will navigate you to the admin-ui directory, and run the development environment. Visit http://localhost:3000/ in your browser, and provide your user credentials to log in. Authentication To enable stable authentication you must supply a NEXTAUTH_SECRET environment variable. The best way to do this is by creating a .env.local file, which Next will automatically pick up: 1 echo NEXTAUTH_SECRET = ` openssl rand -base64 32 ` >> .env.local Backend deployment Fidesops automatically serves a version of the UI when running nox -s dev . To deploy a full version of the UI from a backend, run the following from the root fidesops directory: 1 2 3 cd clients/ops/admin-ui npm install npm run prod-export This will build and place the Admin UI files into a location accessible by backend fidesops deployments. To test the UI, run nox -s dev from the root directory, and visit http://0.0.0.0:8080/index.html .","title":"Local dev"},{"location":"ui/local_dev/#local-development","text":"To test the UI locally, clone the FidesOps repository , and ensure you have Node.js installed to run the application.","title":"Local Development"},{"location":"ui/local_dev/#creating-the-root-user","text":"A root user can be created by adding a root_username and root_password to the security section of fidesops.toml file, or by setting FIDESOPS__SECURITY__ROOT_USERNAME and FIDESOPS__SECURITY__ROOT_PASSWORD environment variables. This will allow you to login in with a root user that can be used to access additional user endpoints .","title":"Creating the root user"},{"location":"ui/local_dev/#accessing-the-control-panel","text":"From the root fidesops directory, run the following: 1 2 3 cd clients/ops/admin-ui npm install npm run dev This will navigate you to the admin-ui directory, and run the development environment. Visit http://localhost:3000/ in your browser, and provide your user credentials to log in.","title":"Accessing the Control Panel"},{"location":"ui/local_dev/#authentication","text":"To enable stable authentication you must supply a NEXTAUTH_SECRET environment variable. The best way to do this is by creating a .env.local file, which Next will automatically pick up: 1 echo NEXTAUTH_SECRET = ` openssl rand -base64 32 ` >> .env.local","title":"Authentication"},{"location":"ui/local_dev/#backend-deployment","text":"Fidesops automatically serves a version of the UI when running nox -s dev . To deploy a full version of the UI from a backend, run the following from the root fidesops directory: 1 2 3 cd clients/ops/admin-ui npm install npm run prod-export This will build and place the Admin UI files into a location accessible by backend fidesops deployments. To test the UI, run nox -s dev from the root directory, and visit http://0.0.0.0:8080/index.html .","title":"Backend deployment"},{"location":"ui/overview/","text":"Fidesops UI Fidesops provides several user interfaces to assist in receiving and managing privacy requests. The Privacy Center and Admin UI work together to allow users to submit data subject requests (DSRs), which can then be reviewed and executed by privacy administrators. Privacy Center The fidesops Privacy Center is a configurable webpage where users can request to download or delete their data. Requests submitted through the Privacy Center are available for review in the Admin UI. Admin UI The Admin UI organizes processes like fulfilling data subject requests , customizing database connections , and managing user access into a single control panel. Once configured, the Admin UI allows authorized users to approve or deny privacy requests, manage datastores, and create or update fidesops policies .","title":"Overview"},{"location":"ui/overview/#fidesops-ui","text":"Fidesops provides several user interfaces to assist in receiving and managing privacy requests. The Privacy Center and Admin UI work together to allow users to submit data subject requests (DSRs), which can then be reviewed and executed by privacy administrators.","title":"Fidesops UI"},{"location":"ui/overview/#privacy-center","text":"The fidesops Privacy Center is a configurable webpage where users can request to download or delete their data. Requests submitted through the Privacy Center are available for review in the Admin UI.","title":"Privacy Center"},{"location":"ui/overview/#admin-ui","text":"The Admin UI organizes processes like fulfilling data subject requests , customizing database connections , and managing user access into a single control panel. Once configured, the Admin UI allows authorized users to approve or deny privacy requests, manage datastores, and create or update fidesops policies .","title":"Admin UI"},{"location":"ui/privacy_center/","text":"Privacy Center The fidesops Privacy Center is a configurable webpage where users can request to download or delete their data. Configuration The fidesops Privacy Center's text and actions are managed by a config.json file in the fidesops /privacy-center/config directory. config.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"title\" : \"Take control of your data\" , \"description\" : \"When you use our services, you\u2019re trusting us with your information. We understand this is a big responsibility and work hard to protect your information and put you in control.\" , \"fidesops_host_development\" : \"http://localhost:8080/api/v1\" , \"fidesops_host_production\" : \"\" , \"logo_path\" : \"/logo.svg\" , \"actions\" : [ { \"policy_key\" : \"download\" , \"icon_path\" : \"/download.svg\" , \"title\" : \"Download your data\" , \"description\" : \"We will email you a report of the data related to your account.\" , \"identity_inputs\" : { \"name\" : \"optional\" , \"email\" : \"required\" , \"phone\" : \"optional\" } }, { \"policy_key\" : \"delete\" , \"icon_path\" : \"/delete.svg\" , \"title\" : \"Delete your data\" , \"description\" : \"We will delete all of your account data. This action cannot be undone.\" , \"identity_inputs\" : { \"name\" : \"optional\" , \"email\" : \"required\" , \"phone\" : \"optional\" } } ] } Key Description title and dscription Text fields to override the default text of either the main portal, or the associated action. fidesops_host_development The URL to use for development deployments. fidesops_host_production The URL to use for production deployments. logo_path The relative path to a brand or site logo to replace the default. actions A list of action objects , each of which represent a new tile available in the portal, and are associated to a single fidesops policy. policy_key The key of the policy to use for this action. icon_path The relative path of an icon to replace the defaults. identity_inputs The list of personally identifiable information required by an action. Actions Actions represent available privacy rights executable from the Privacy Center. The provided config.json includes Download and Delete default, representing common requests to access or remove data under most privacy regulations. Each action is associated with a fidesops policy key , which defines the policy executed when the DSR is approved. Additional actions can be added to this list, and removed at any time. Styling Any overrides for CSS styling can be included in a config.css file in the /privacy-center/config directory.","title":"Privacy Center"},{"location":"ui/privacy_center/#privacy-center","text":"The fidesops Privacy Center is a configurable webpage where users can request to download or delete their data.","title":"Privacy Center"},{"location":"ui/privacy_center/#configuration","text":"The fidesops Privacy Center's text and actions are managed by a config.json file in the fidesops /privacy-center/config directory. config.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"title\" : \"Take control of your data\" , \"description\" : \"When you use our services, you\u2019re trusting us with your information. We understand this is a big responsibility and work hard to protect your information and put you in control.\" , \"fidesops_host_development\" : \"http://localhost:8080/api/v1\" , \"fidesops_host_production\" : \"\" , \"logo_path\" : \"/logo.svg\" , \"actions\" : [ { \"policy_key\" : \"download\" , \"icon_path\" : \"/download.svg\" , \"title\" : \"Download your data\" , \"description\" : \"We will email you a report of the data related to your account.\" , \"identity_inputs\" : { \"name\" : \"optional\" , \"email\" : \"required\" , \"phone\" : \"optional\" } }, { \"policy_key\" : \"delete\" , \"icon_path\" : \"/delete.svg\" , \"title\" : \"Delete your data\" , \"description\" : \"We will delete all of your account data. This action cannot be undone.\" , \"identity_inputs\" : { \"name\" : \"optional\" , \"email\" : \"required\" , \"phone\" : \"optional\" } } ] } Key Description title and dscription Text fields to override the default text of either the main portal, or the associated action. fidesops_host_development The URL to use for development deployments. fidesops_host_production The URL to use for production deployments. logo_path The relative path to a brand or site logo to replace the default. actions A list of action objects , each of which represent a new tile available in the portal, and are associated to a single fidesops policy. policy_key The key of the policy to use for this action. icon_path The relative path of an icon to replace the defaults. identity_inputs The list of personally identifiable information required by an action.","title":"Configuration"},{"location":"ui/privacy_center/#actions","text":"Actions represent available privacy rights executable from the Privacy Center. The provided config.json includes Download and Delete default, representing common requests to access or remove data under most privacy regulations. Each action is associated with a fidesops policy key , which defines the policy executed when the DSR is approved. Additional actions can be added to this list, and removed at any time.","title":"Actions"},{"location":"ui/privacy_center/#styling","text":"Any overrides for CSS styling can be included in a config.css file in the /privacy-center/config directory.","title":"Styling"},{"location":"ui/subject_requests/","text":"Subject Requests The FidesOps Admin UI is designed to provide easy, at-a-glance access to submitted Subject Requests. The Subject Request panel provides search and sort capabilities, quick approve and deny functions, and in-depth details on a request's history and status. Panel options Option Description Status Requests can be filtered by their current status: Error , Denied , In Progress , New , Canceled , and Complete . Search The search bar filters on a given field: status, reviewer, etc. Date Filter Retrieve requests received within a certain date window. Reveal PII Toggling Reveal PII will display all personal information for the shown requests. Download Download a .csv of the shown requests. Clear Remove all search options and filters. Approve or deny requests Hovering over a request row will provide access to the approve and deny options for that request. Approving a request will log the action, the approver's account, and begin the process of executing the request based on the associated policy . Denying a request allows the user to input a denial reason before confirming the action. View request details Double-clicking a request row will display the request detail page, which allows access to additional information about the request, including the request ID, request type, and current status. Requests with a status of Error can also be retried from this panel by selecting the Retry button. The bottom of the Request Details panel displays the selected request's full event history. Selecting View Details on any event displays a summary of the event. View Log displays a detailed event log, which includes fidesops' traversal through third-party connections and collections.","title":"Subject Requests"},{"location":"ui/subject_requests/#subject-requests","text":"The FidesOps Admin UI is designed to provide easy, at-a-glance access to submitted Subject Requests. The Subject Request panel provides search and sort capabilities, quick approve and deny functions, and in-depth details on a request's history and status.","title":"Subject Requests"},{"location":"ui/subject_requests/#panel-options","text":"Option Description Status Requests can be filtered by their current status: Error , Denied , In Progress , New , Canceled , and Complete . Search The search bar filters on a given field: status, reviewer, etc. Date Filter Retrieve requests received within a certain date window. Reveal PII Toggling Reveal PII will display all personal information for the shown requests. Download Download a .csv of the shown requests. Clear Remove all search options and filters.","title":"Panel options"},{"location":"ui/subject_requests/#approve-or-deny-requests","text":"Hovering over a request row will provide access to the approve and deny options for that request. Approving a request will log the action, the approver's account, and begin the process of executing the request based on the associated policy . Denying a request allows the user to input a denial reason before confirming the action.","title":"Approve or deny requests"},{"location":"ui/subject_requests/#view-request-details","text":"Double-clicking a request row will display the request detail page, which allows access to additional information about the request, including the request ID, request type, and current status. Requests with a status of Error can also be retried from this panel by selecting the Retry button. The bottom of the Request Details panel displays the selected request's full event history. Selecting View Details on any event displays a summary of the event. View Log displays a detailed event log, which includes fidesops' traversal through third-party connections and collections.","title":"View request details"},{"location":"ui/user_management/","text":"User Management Fidesops users can be easily managed from both the built-in control panel, and a series of API endpoints . Managing Users from the UI The User Management panel displays a view of all users within the system, and provides a search bar for retrieving users by username. Creating New Users The Add New User button can create a new user: Managing User Privileges New users can be created with a series of privileges, or permissions, to allow or restrict their access to individual parts of your fidesops configuration. Privileges Privileges represent individual user permissions. Ensure each user is created with the permissions applicable for their role. Privilege Description View subject requests All users are able to view subject requests by default. Approve subject requests Allows the user to process/approve submitted DSRs. View datastore connections Allows the user to view, but not edit, any existing connections to your datastores. Create or Update datastore connections Allows the user to create new datastore connections, and update existing connections. Delete datastore connections Allows the user to delete existing datastore connections, removing them entirely from fidesops. View policies Allows the user to view existing fidesops policies. Create policies Allows the user to create new fidesops policies. View users Allows the user to view the User Management panel. Create users Allows the user to create new users from the User Management panel. View roles Allows the user to view, but not edit, existing roles. Create roles Allows the user to create new roles. Editing Existing Users Existing users can be edited by selecting the \"Edit\" button from the side of the user row. Users may also be deleted from this drop-down menu. Note that an individual's username may not be changed. Managing Users from the API Fidesops provides several user-related endpoints for managing access to the control panel. Example requests are included in the fidesops Postman collection . User and Endpoint Scopes User permissions are managed through access tokens, which contain scopes associated to individual endpoints. Endpoint access can be restricted by removing their scope from an access token. Creating a user currently provides access to all scopes. User Passwords All user passwords must by Base64 encoded before creating a new user, logging in, or changing a users password. This can be done with base64encode.org . After Base64 encoding, the password Suitablylongwithnumber8andsymbol$ would become U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk . Logging in 1 POST api/v1/login Request Body 1 2 3 4 { \"username\" : \"test_username\" , \"password\" : \"U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk\" } Successful POST requests to the login endpoint will return an access_token with all available scopes. This token can be used to make subsequent requests to the Users endpoints. Logging out 1 POST api/v1/logout Authentication Scope Description Bearer token N/A An access_token returned from login . The logout endpoint will invalidate the provided access_token , which must be included as the Bearer token in your request. Creating a user 1 POST api/v1/user Request Body 1 2 3 4 { \"username\" : \"new_username\" , \"password\" : \"U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk\" } Authentication Scope Description Bearer token user:create An access_token returned from login . The user endpoint will create an additional user with the username and password provided in the request body. An access_token with a scope of user:create is required. Deleting a user 1 DELETE api/v1/user/<user_id> Authentication Scope Description Bearer token user:delete An access_token returned from login . An access_token with a scope of user:delete is required, and must be associated to the Admin UI Root User, or the user you are trying to delete.","title":"User Management"},{"location":"ui/user_management/#user-management","text":"Fidesops users can be easily managed from both the built-in control panel, and a series of API endpoints .","title":"User Management"},{"location":"ui/user_management/#managing-users-from-the-ui","text":"The User Management panel displays a view of all users within the system, and provides a search bar for retrieving users by username.","title":"Managing Users from the UI"},{"location":"ui/user_management/#creating-new-users","text":"The Add New User button can create a new user:","title":"Creating New Users"},{"location":"ui/user_management/#managing-user-privileges","text":"New users can be created with a series of privileges, or permissions, to allow or restrict their access to individual parts of your fidesops configuration.","title":"Managing User Privileges"},{"location":"ui/user_management/#privileges","text":"Privileges represent individual user permissions. Ensure each user is created with the permissions applicable for their role. Privilege Description View subject requests All users are able to view subject requests by default. Approve subject requests Allows the user to process/approve submitted DSRs. View datastore connections Allows the user to view, but not edit, any existing connections to your datastores. Create or Update datastore connections Allows the user to create new datastore connections, and update existing connections. Delete datastore connections Allows the user to delete existing datastore connections, removing them entirely from fidesops. View policies Allows the user to view existing fidesops policies. Create policies Allows the user to create new fidesops policies. View users Allows the user to view the User Management panel. Create users Allows the user to create new users from the User Management panel. View roles Allows the user to view, but not edit, existing roles. Create roles Allows the user to create new roles.","title":"Privileges"},{"location":"ui/user_management/#editing-existing-users","text":"Existing users can be edited by selecting the \"Edit\" button from the side of the user row. Users may also be deleted from this drop-down menu. Note that an individual's username may not be changed.","title":"Editing Existing Users"},{"location":"ui/user_management/#managing-users-from-the-api","text":"Fidesops provides several user-related endpoints for managing access to the control panel. Example requests are included in the fidesops Postman collection .","title":"Managing Users from the API"},{"location":"ui/user_management/#user-and-endpoint-scopes","text":"User permissions are managed through access tokens, which contain scopes associated to individual endpoints. Endpoint access can be restricted by removing their scope from an access token. Creating a user currently provides access to all scopes.","title":"User and Endpoint Scopes"},{"location":"ui/user_management/#user-passwords","text":"All user passwords must by Base64 encoded before creating a new user, logging in, or changing a users password. This can be done with base64encode.org . After Base64 encoding, the password Suitablylongwithnumber8andsymbol$ would become U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk .","title":"User Passwords"},{"location":"ui/user_management/#logging-in","text":"1 POST api/v1/login Request Body 1 2 3 4 { \"username\" : \"test_username\" , \"password\" : \"U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk\" } Successful POST requests to the login endpoint will return an access_token with all available scopes. This token can be used to make subsequent requests to the Users endpoints.","title":"Logging in"},{"location":"ui/user_management/#logging-out","text":"1 POST api/v1/logout Authentication Scope Description Bearer token N/A An access_token returned from login . The logout endpoint will invalidate the provided access_token , which must be included as the Bearer token in your request.","title":"Logging out"},{"location":"ui/user_management/#creating-a-user","text":"1 POST api/v1/user Request Body 1 2 3 4 { \"username\" : \"new_username\" , \"password\" : \"U3VpdGFibHlsb25nd2l0aG51bWJlcjhhbmRzeW1ib2wk\" } Authentication Scope Description Bearer token user:create An access_token returned from login . The user endpoint will create an additional user with the username and password provided in the request body. An access_token with a scope of user:create is required.","title":"Creating a user"},{"location":"ui/user_management/#deleting-a-user","text":"1 DELETE api/v1/user/<user_id> Authentication Scope Description Bearer token user:delete An access_token returned from login . An access_token with a scope of user:delete is required, and must be associated to the Admin UI Root User, or the user you are trying to delete.","title":"Deleting a user"}]}